<html xmlns="http://www.w3.org/TR/xhtml1/transitional"><head xmlns="">
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;10.&nbsp;Examples</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot_6797"><link rel="start" href="title.html" title="Drools"><link rel="up" href="pt01.html" title="Part&nbsp;I.&nbsp;Reference Manual"><link rel="prev" href="ch09s04.html" title="9.4.&nbsp;Quick start guide"><link rel="next" href="ix01.html" title="Index"><base xmlns="http://www.w3.org/TR/xhtml1/transitional" target="body"></base></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns="" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;10.&nbsp;Examples</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch09s04.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;I.&nbsp;Reference Manual</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ix01.html">Next</a></td></tr></table><hr></div><div xmlns="" class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e5978"></a>Chapter&nbsp;10.&nbsp;Examples</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5981"></a>10.1.&nbsp;Getting the examples</h2></div></div></div><p>Make sure the Drools Eclipse plugin is installed, which needs GEF
  dependency installed first. Then download and extract the drools-examples
  zip file, which includes an already created Eclipse project. Import that
  project into a new Eclipse workspace. The rules all have example classes
  that execute the rules. If you want to try the examples in another project
  (or another IDE) then you will need to setup the dependencies by hand of
  course. Many, but not all of the examples are documented below, enjoy
  :)</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5986"></a>10.1.1.&nbsp;Hello World</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Hello World
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.HelloWorldExample
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> HelloWorld.drl
<span class="bold"><strong>Objective:</strong></span> demonstrate basic rules in use
</pre><p>The "Hello World" example shows a simple example of rules usage, and
    both the MVEL and Java dialects.</p><p>In this example it will be shown how to build rulebases and sessions
    and how to add audit logging and debug outputs, this information is
    ommitted from other examples as it's all very similar. PackageBuilder is
    used to turn a drl source file into Package objects which the RuleBase can
    consume, addPackageFromDrl takes a Reader interface as the parameter.
    Reader can be used to retrieve a source drl file from various locations,
    in this case the drl file is being retrieved from the classpath as an
    InputStream which we turn into a Reader by wrapping it with
    InputStreamReader; but it could come the disk or a url. The use of the
    Reader interface means that Drools does not have to care. In this case we
    only add a single drl source file, but multiple drl files can be added and
    all are merged into a single Package. All drl files added to the
    PackageBuilder must declare themselves in the same package namespace, if
    you wish to build a Package in a different namespace a new instance of
    PackageBuilder must be created; multiple packages of differerent
    namespaces can be added to the same RuleBase. When all the drl files have
    been added we should check the builder for errors; while the RuleBase will
    validate the packge it will only have access to the error information as a
    String, so if you wish to debug the error information you should do it on
    the builder instance. Once we know the builder is error free get the
    Package, instantiate a RuleBase from the RuleBaseFactory and add the
    package.</p><div class="example"><a name="d0e6009"></a><p class="title"><b>Example&nbsp;10.1.&nbsp;HelloWorld example: Creating the RuleBase and Session</b></p><div class="example-contents"><pre class="programlisting">//read in the source
Reader source = new InputStreamReader( HelloWorldExample.class.getResourceAsStream( "HelloWorld.drl" ) );

PackageBuilder builder = new PackageBuilder();

//this wil parse and compile in one step
builder.addPackageFromDrl( source );

// Check the builder for errors
if ( builder.hasErrors() ) {
    System.out.println( builder.getErrors().toString() );
    throw new RuntimeException( "Unable to compile \"HelloWorld.drl\".");
}

//get the compiled package (which is serializable)
Package pkg = builder.getPackage();

//add the package to a rulebase (deploy the rule package).
RuleBase ruleBase = RuleBaseFactory.newRuleBase();
ruleBase.addPackage( pkg );

StatefulSession session = ruleBase.newStatefulSession();</pre></div></div><br class="example-break"><p>Drools has an event model that exposes much of whats happening
    internally, two default debug listeners are supplied
    DebugAgendaEventListener and DebugWorkingMemoryEventListener which print
    out debug event information to the err console, adding listeners to a
    session is trivial and shown below. The WorkingMemoryFileLogger provides
    execution auditing which can be viewed in a graphical viewer; it's
    actually a specialised implementation built on the agenda and working
    memory listeners, when the engine has finished executing
    logger.writeToDisk() must be called.</p><p>Most of the examples use the Audit logging features of Drools to
    record execution flow for later inspection.</p><div class="example"><a name="d0e6018"></a><p class="title"><b>Example&nbsp;10.2.&nbsp;HelloWorld example: Event logging and Auditing</b></p><div class="example-contents"><pre class="programlisting">// setup the debug listeners
session.addEventListener( new DebugAgendaEventListener() );
session.addEventListener( new DebugWorkingMemoryEventListener() );
        
// setup the audit logging
WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger( session );
logger.setFileName( "log/helloworld" );     </pre></div></div><br class="example-break"><p>The single class used in this example is very simple, it has two
    fields: the message, which is a String and the status which can be either
    the int HELLO or the int GOODBYE.</p><div class="example"><a name="d0e6025"></a><p class="title"><b>Example&nbsp;10.3.&nbsp;HelloWorld example: Message Class</b></p><div class="example-contents"><pre class="programlisting">public static class Message {
    public static final int HELLO   = 0;
    public static final int GOODBYE = 1;

    private String          message;
    private int             status; 
    ...
}</pre></div></div><br class="example-break"><p>A single Message object is created with the message "Hello World"
    and status HELLO and then inserted into the engine, at which point
    fireAllRules() is executed. Remember all the network evaluation is done
    during the insert time, by the time the program execution reaches the
    fireAllRules() method it already knows which rules are fully matches and
    able to fire.</p><div class="example"><a name="d0e6032"></a><p class="title"><b>Example&nbsp;10.4.&nbsp;HelloWorld example: Execution</b></p><div class="example-contents"><pre class="programlisting">Message message = new Message();
message.setMessage( "Hello World" );
message.setStatus( Message.HELLO );
session.insert( message );
        
session.fireAllRules();
        
logger.writeToDisk();
      
session.dispose();    </pre></div></div><br class="example-break"><p>To execute the example from Java.</p><div class="orderedlist"><ol type="1"><li><p>Open the class org.drools.examples.FibonacciExample in your
          Eclipse IDE</p></li><li><p>Right-click the class an select "Run as..." -&gt; "Java
          application"</p></li></ol></div><p>If we put a breakpoint on the fireAllRules() method and select the
    session variable we can see that the "Hello World" view is already
    activated and on the Agenda, showing that all the pattern matching work
    was already done during the insert.</p><div class="figure"><a name="d0e6049"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/helloworld_agenda1.png" alt="Hello World : fireAllRules Agenda View"></div></div><p class="title"><b>Figure&nbsp;10.1.&nbsp;Hello World : fireAllRules Agenda View</b></p></div><br class="figure-break"><p>The may application print outs go to to System.out while the debug
    listener print outs go to System.err.</p><div class="example"><a name="d0e6057"></a><p class="title"><b>Example&nbsp;10.5.&nbsp;HelloWorld example: Console.out</b></p><div class="example-contents"><pre class="programlisting">Hello World
Goodbyte cruel world</pre></div></div><br class="example-break"><div class="example"><a name="d0e6062"></a><p class="title"><b>Example&nbsp;10.6.&nbsp;HelloWorld example: Console.err</b></p><div class="example-contents"><pre class="programlisting">==&gt;[ActivationCreated(0): rule=Hello World; 
                          tuple=[fid:1:1:org.drools.examples.HelloWorldExample$Message@17cec96]]
[ObjectInserted: handle=[fid:1:1:org.drools.examples.HelloWorldExample$Message@17cec96]; 
                 object=org.drools.examples.HelloWorldExample$Message@17cec96]
[BeforeActivationFired: rule=Hello World; 
                        tuple=[fid:1:1:org.drools.examples.HelloWorldExample$Message@17cec96]]
==&gt;[ActivationCreated(4): rule=Good Bye; 
                          tuple=[fid:1:2:org.drools.examples.HelloWorldExample$Message@17cec96]]
[ObjectUpdated: handle=[fid:1:2:org.drools.examples.HelloWorldExample$Message@17cec96]; 
                old_object=org.drools.examples.HelloWorldExample$Message@17cec96; 
                new_object=org.drools.examples.HelloWorldExample$Message@17cec96]
[AfterActivationFired(0): rule=Hello World]
[BeforeActivationFired: rule=Good Bye; 
                        tuple=[fid:1:2:org.drools.examples.HelloWorldExample$Message@17cec96]]
[AfterActivationFired(4): rule=Good Bye]  </pre></div></div><br class="example-break"><p>The <span class="bold"><strong>LHS (when)</strong></span> section of the rule
    states that it will be activated for each <span class="emphasis"><em>Message</em></span>
    object inserted into the working memory whose <span class="emphasis"><em>status</em></span>
    is <span class="emphasis"><em>Message.HELLO</em></span>. Besides that, two variable binds
    are created: "<span class="emphasis"><em>message</em></span>" variable is bound to the
    <span class="emphasis"><em>message</em></span> attribute and "<span class="emphasis"><em>m</em></span>"
    variable is bound to the <span class="emphasis"><em>object matched pattern</em></span>
    itself.</p><p>The <span class="bold"><strong>RHS (consequence, then)</strong></span> section
    of the rule is written using the MVEL expression language, as declared by
    the rule's attribute <span class="emphasis"><em>dialect</em></span>. After printing the
    content of the <span class="emphasis"><em>message</em></span> bound variable to the default
    console, the rule changes the values of the <span class="emphasis"><em>message</em></span>
    and <span class="emphasis"><em>status</em></span> attributes of the <span class="emphasis"><em>m</em></span>
    bound variable; using MVEL's 'modify' keyword which allows you to apply a
    block of setters in one statement, with the engine being automatically
    notified of the changes at the end of the block.</p><div class="example"><a name="d0e6113"></a><p class="title"><b>Example&nbsp;10.7.&nbsp;HelloWorld example: rule "Hello World"</b></p><div class="example-contents"><pre class="programlisting">rule "Hello World"
      dialect "mvel"
  when
      m : Message( status == Message.HELLO, message : message )
  then
      System.out.println( message ); 
      modify ( m ) { message = "Goodbyte cruel world",
                     status = Message.GOODBYE };
end</pre></div></div><br class="example-break"><p>We can add a break point into the DRL for when modify is called
    during the execution of the "Hello World" consequence and inspect the
    Agenda view again. Notice this time we "Debug As" a "Drools application"
    and not a "Java application".</p><div class="orderedlist"><ol type="1"><li><p>Open the class org.drools.examples.FibonacciExample in your
          Eclipse IDE</p></li><li><p>Right-click the class an select "Debug as..." -&gt; "Drools
          application"</p></li></ol></div><p>Now we can see that the other rule "Good Bye" which uses
    the java dialect is activated and placed on the agenda.</p><div class="figure"><a name="d0e6129"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/helloworld_agenda2.png" alt="Hello World : rule &#34;Hello World&#34; Agenda View"></div></div><p class="title"><b>Figure&nbsp;10.2.&nbsp;Hello World : rule "Hello World" Agenda View</b></p></div><br class="figure-break"><p>The "Good Bye" rule is similar to the "Hello World" rule but matches
    Message objects whose status is Message.GOODBYE instead, printing its
    message to the default console, it specifies the "java" dialect.</p><div class="example"><a name="d0e6137"></a><p class="title"><b>Example&nbsp;10.8.&nbsp;HelloWorld example: rule "Good Bye"</b></p><div class="example-contents"><pre class="programlisting">rule "Good Bye"
      dialect "java"
  when
      Message( status == Message.GOODBYE, message : message )
  then
      System.out.println( message ); 
end</pre></div></div><br class="example-break"><p>If you remember at the start of this example in the java code we
    created a WorkingMemoryFileLogger and called logger.writeToDisk() at the
    end, this created an audit log file that can be shown in the Audit view.
    We use the audit view in many of the examples to try and understand the
    example execution flow. In the view below we can see the object is
    inserted which creates an activation for the "Hello World" rule, the
    activation is then executed which updated the Message object causing the
    "Good Bye" rule to activate, the "Good Bye" rule then also executes. When
    an event in the Audit view is select it highlights the origin event in
    green, so below the Activation created event is highlighted in greed as
    the origin of the Activation executed event.</p><div class="figure"><a name="d0e6144"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/helloworld_auditview1.png" alt="Hello World : Audit View"></div></div><p class="title"><b>Figure&nbsp;10.3.&nbsp;Hello World : Audit View</b></p></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6150"></a>10.1.2.&nbsp;State Example</h3></div></div></div><p>This example is actually implemented in three different versions to
    demonstrate different ways of implementing the same basic behavior: rules
    forward chaining, i.e., the ability the engine has to evaluate, activate
    and fire rules in sequence, based on changes on the facts in the working
    memory.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6155"></a>10.1.2.1.&nbsp;Understanding the State Example</h4></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> State Example
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.StateExampleUsingSalience
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> StateExampleUsingSalience.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates basic rule use and Conflict Resolution for rule firing priority.</pre><p>Each
      State class has fields for its name and its current state (see
      org.drools.examples.State class). The two possible states for each
      objects are:</p><div class="itemizedlist"><ul type="disc"><li><p>NOTRUN</p></li><li><p>FINISHED</p></li></ul></div><div class="example"><a name="d0e6183"></a><p class="title"><b>Example&nbsp;10.9.&nbsp;State Classs</b></p><div class="example-contents"><pre class="programlisting">public class State {
    public static final int       NOTRUN   = 0;
    public static final int       FINISHED = 1;

    private final PropertyChangeSupport changes  = new PropertyChangeSupport( this );

    private String                name;
    private int                   state;

    ... setters and getters go here...
}</pre></div></div><br class="example-break"><p>Ignore the PropertyChangeSupport for now, that will be explained
      later. In the example we create four State objects with names: A, B, C
      and D. Initially all are set to state NOTRUN, which is default for the
      used constructor. Each instance is asserted in turn into the session and
      then fireAllRules() is called.</p><div class="example"><a name="d0e6190"></a><p class="title"><b>Example&nbsp;10.10.&nbsp;Salience State Example Execution</b></p><div class="example-contents"><pre class="programlisting">State a = new State( "A" );
State b = new State( "B" );
State c = new State( "C" );
final State d = new State( "D" );

// By setting dynamic to TRUE, Drools will use JavaBean
// PropertyChangeListeners so you don't have to call update().
boolean dynamic = true;

session.insert( a,
                dynamic );
session.insert( b,
                dynamic );
session.insert( c,
                dynamic );
session.insert( d,
                dynamic );

session.fireAllRules();
session.dispose(); // Stateful rule session must always be disposed when finished</pre></div></div><br class="example-break"><p>To execute the application:</p><div class="orderedlist"><ol type="1"><li><p>Open the class org.drools.examples.StateExampleUsingSalience
            in your Eclipse IDE</p></li><li><p>Right-click the class an select "Run as..." -&gt; "Java
            application"</p></li></ol></div><p>And you will see the following output in the Eclipse console
      output:</p><div class="example"><a name="d0e6207"></a><p class="title"><b>Example&nbsp;10.11.&nbsp;Salience State Example Console Output</b></p><div class="example-contents"><pre class="programlisting">A finished
B finished
C finished
D finished
</pre></div></div><br class="example-break"><p>There are four rules in total, first a Bootstrap rule fires
      setting A to state FINISHED which then causes B to change to state
      FINISHED. C and D are both dependent on B - causing a conflict which is
      resolved by setting salience values. First lets look at how this was
      executed</p><p>The best way to understand what is happening is to use the "Audit
      Log" feature to graphically see the results of each operation. The Audit
      log was generated when the example was previously run. To view the Audit
      log in Eclipse:</p><div class="orderedlist"><ol type="1"><li><p>If the "Audit View" is not visible, click on:
          "Window"-&gt;"Show View"-&gt;"Other..."-&gt;"Drools"-&gt;"Audit
          View"</p></li><li><p>In the "Audit View" click in the "Open Log" button and select
          the file "&lt;drools-examples-drl-dir&gt;/log/state.log"</p></li></ol></div><p>After that, the "Audit view" will look like the following
      screenshot.</p><div class="figure"><a name="d0e6225"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/state_example_audit1.png" alt="Salience State Example Audit View"></div></div><p class="title"><b>Figure&nbsp;10.4.&nbsp;Salience State Example Audit View</b></p></div><br class="figure-break"><p>Reading the log in the "Audit View", top to down, we see every
      action and the corresponding changes in the working memory. This way we
      see that the assertion of the State "A" object with the "NOTRUN" state
      activates the "Bootstrap" rule, while the assertions of the other state
      objects have no immediate effect.</p><div class="example"><a name="d0e6233"></a><p class="title"><b>Example&nbsp;10.12.&nbsp;Salience State Example: Rule "Bootstrap"</b></p><div class="example-contents"><pre class="programlisting">rule Bootstrap
    when
        a : State(name == "A", state == State.NOTRUN )
    then
        System.out.println(a.getName() + " finished" );
        a.setState( State.FINISHED );
end</pre></div></div><br class="example-break"><p>The execution of "Bootstrap" rule changes the state of "A" to
      "FINISHED", that in turn activates the "A to B" rule.</p><div class="example"><a name="d0e6240"></a><p class="title"><b>Example&nbsp;10.13.&nbsp;Salience State Example: Rule "A to B"</b></p><div class="example-contents"><pre class="programlisting">rule "A to B"
    when
        State(name == "A", state == State.FINISHED )
        b : State(name == "B", state == State.NOTRUN )
    then
        System.out.println(b.getName() + " finished" );
        b.setState( State.FINISHED );
end
</pre></div></div><br class="example-break"><p>The execution of "A to B" rule changes the state of "B" to
      "FINISHED", which activates both rules "B to C" and "B to D", placing
      both Activations onto the Agenda. In this moment the two rules may fire
      and are said to be in conflict. The conflict resolution strategy allows
      the engine's Agenda to decide which rule to fire. As the "B to C" rule
      has a <span class="bold"><strong>higher salience value</strong></span> (10 versus
      the default salience value of 0), it fires first, modifying the "C"
      object to state "FINISHED". The Audit view above shows the modification
      of the State object in the rule "A to B" which results in two
      highlighted activations being in conflict. The Agenda view can also be
      used to investigate the state of the Agenda, debug points can be placed
      in the rules themselves and the Agenda view opened; the screen shot
      below shows the break point in the rule "A to B" and the state of the
      Agenda with the two conflicting rules.</p><div class="figure"><a name="d0e6250"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/state_example_agenda1.png" alt="State Example Agenda View"></div></div><p class="title"><b>Figure&nbsp;10.5.&nbsp;State Example Agenda View</b></p></div><br class="figure-break"><div class="example"><a name="d0e6256"></a><p class="title"><b>Example&nbsp;10.14.&nbsp;Salience State Example: Rule "B to C"</b></p><div class="example-contents"><pre class="programlisting">rule "B to C"
        salience 10
    when
        State(name == "B", state == State.FINISHED )
        c : State(name == "C", state == State.NOTRUN )
    then
        System.out.println(c.getName() + " finished" );
        c.setState( State.FINISHED );
end
</pre></div></div><br class="example-break"><p>The "B to D" rule fires last, modifying the "D" object to state
      "FINISHED".</p><div class="example"><a name="d0e6263"></a><p class="title"><b>Example&nbsp;10.15.&nbsp;Salience State Example: Rule "B to D"</b></p><div class="example-contents"><pre class="programlisting">rule "B to D"
    when
        State(name == "B", state == State.FINISHED )
        d : State(name == "D", state == State.NOTRUN )
    then
        System.out.println(d.getName() + " finished" );
        d.setState( State.FINISHED );
end</pre></div></div><br class="example-break"><p>There are no more rules to execute and so the engine stops.</p><p>Another notable concept in this example is the use of <span class="bold"><strong>dynamic facts</strong></span>, which is the
      PropertyChangeListener part. As mentioned previously in the
      documentation, in order for the engine to see and react to fact's
      properties change, the application must tell the engine that changes
      occurred. This can be done explicitly in the rules, by calling the
      <span class="bold"><strong>update()</strong></span> memory action, or implicitly
      by letting the engine know that the facts implement
      PropertyChangeSupport as defined by the <span class="emphasis"><em>Javabeans
      specification</em></span>. This example demonstrates how to use
      PropertyChangeSupport to avoid the need for explicit update() calls in
      the rules. To make use of this feature, make sure your facts implement
      the PropertyChangeSupport as the org.drools.example.State class does and
      use the following code to insert the facts into the working
      memory:</p><div class="example"><a name="d0e6281"></a><p class="title"><b>Example&nbsp;10.16.&nbsp;Inserting a Dynamic Fact</b></p><div class="example-contents"><pre class="programlisting">// By setting dynamic to TRUE, Drools will use JavaBean
// PropertyChangeListeners so you don't have to call update().
final boolean dynamic = true;

session.insert( fact,
                dynamic );
</pre></div></div><br class="example-break"><p>When using PropertyChangeListeners each setter must implement a
      little extra code to do the notification, here is the state setter for
      thte org.drools.examples.State class:</p><div class="example"><a name="d0e6288"></a><p class="title"><b>Example&nbsp;10.17.&nbsp;Setter Example with PropertyChangeSupport</b></p><div class="example-contents"><pre class="programlisting">public void setState(final int newState) {
    int oldState = this.state;
    this.state = newState;
    this.changes.firePropertyChange( "state",
                                     oldState,
                                     newState );
}</pre></div></div><br class="example-break"><p>There are two other State examples: StateExampleUsingAgendGroup
      and StateExampleWithDynamicRules. Both execute from A to B to C to D, as
      just shown, the StateExampleUsingAgendGroup uses agenda-groups to
      control the rule conflict and which one fires first and
      StateExampleWithDynamicRules shows how an additional rule can be added
      to an already running WorkingMemory with all the existing data applying
      to it at runtime.</p><p>Agenda groups are a way to partition the agenda into groups and
      controlling which groups can execute. All rules by default are in the
      "MAIN" agenda group, by simply using the "agenda-group" attribute you
      specify a different agenda group for the rule. A working memory
      initially only has focus on the "MAIN" agenda group, only when other
      groups are given the focus can their rules fire; this can be achieved by
      either using the method setFocus() or the rule attribute "auto-focus".
      "auto-focus" means that the rule automatically sets the focus to it's
      agenda group when the rule is matched and activated. It is this
      "auto-focus" that enables "B to C" to fire before "B to D".</p><div class="example"><a name="d0e6297"></a><p class="title"><b>Example&nbsp;10.18.&nbsp;Agenda Group State Example: Rule "B to C"</b></p><div class="example-contents"><pre class="programlisting">rule "B to C"
      agenda-group "B to C"
      auto-focus true       
  when
      State(name == "B", state == State.FINISHED )      
      c : State(name == "C", state == State.NOTRUN )
  then
      System.out.println(c.getName() + " finished" );
      c.setState( State.FINISHED );
      drools.setFocus( "B to D" );
end</pre></div></div><br class="example-break"><p>The rule "B to C" calls "drools.setFocus( "B to D" );" which gives
      the agenda group "B to D" focus allowing its active rules to fire; which
      allows the rule "B to D" to fire.</p><div class="example"><a name="d0e6304"></a><p class="title"><b>Example&nbsp;10.19.&nbsp;Agenda Group State Example: Rule "B to D"</b></p><div class="example-contents"><pre class="programlisting">rule "B to D"
      agenda-group "B to D"
  when
      State(name == "B", state == State.FINISHED )      
      d : State(name == "D", state == State.NOTRUN )
  then
      System.out.println(d.getName() + " finished" );
      d.setState( State.FINISHED );
end</pre></div></div><br class="example-break"><p>The example StateExampleWithDynamicRules adds another rule to the
      RuleBase after fireAllRules(), the rule it adds is just another State
      transition.</p><div class="example"><a name="d0e6311"></a><p class="title"><b>Example&nbsp;10.20.&nbsp;Dynamic State Example: Rule "D to E"</b></p><div class="example-contents"><pre class="programlisting">rule "D to E"
  when
      State(name == "D", state == State.FINISHED )      
      e : State(name == "E", state == State.NOTRUN )
  then
      System.out.println(e.getName() + " finished" );
      e.setState( State.FINISHED );
end</pre></div></div><br class="example-break"><p>It gives the following expected output:</p><div class="example"><a name="d0e6318"></a><p class="title"><b>Example&nbsp;10.21.&nbsp;Dynamic Sate Example Output</b></p><div class="example-contents"><pre class="programlisting">A finished
B finished
C finished
D finished
E finished
</pre></div></div><br class="example-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6323"></a>10.1.3.&nbsp;Banking Tutorial</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> BankingTutorial
<span class="bold"><strong>Main class:</strong></span> org.drools.tutorials.banking.*
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> org.drools.tutorials.banking.*
<span class="bold"><strong>Objective:</strong></span> tutorial that builds up knowledge of pattern matching, basic sorting and calculation rules.</pre><p>This tutorial will demonstrate the process of developing a complete
    personal banking application that will handle credits, debits, currencies
    and that will use a set of design patterns that have been created for the
    process. In order to make the examples documented here clear and modular,
    I will try and steer away from re-visiting existing code to add new
    functionality, and will instead extend and inject where
    appropriate.</p><p>The RuleRunner class is a simple harness to execute one or more drls
    against a set of data. It compiles the Packages and creates the RuleBase
    for each execution, this allows us to easy execute each scenario and see
    the outputs. In reality this is not a good solution for a production
    system where the RuleBase should be built just once and cached, but for
    the purposes of this tutorial it shall suffice.</p><div class="example"><a name="d0e6346"></a><p class="title"><b>Example&nbsp;10.22.&nbsp;Banking Tutorial : RuleRunner</b></p><div class="example-contents"><pre class="programlisting">public class RuleRunner {

    public RuleRunner() {
    }

    public void runRules(String[] rules,
                         Object[] facts) throws Exception {

        RuleBase ruleBase = RuleBaseFactory.newRuleBase();
        PackageBuilder builder = new PackageBuilder();

        for ( int i = 0; i &lt; rules.length; i++ ) {
            String ruleFile = rules[i];
            System.out.println( "Loading file: " + ruleFile );            
            builder.addPackageFromDrl(new InputStreamReader( RuleRunner.class.getResourceAsStream( ruleFile ) ) );
        }

        Package pkg = builder.getPackage();
        ruleBase.addPackage( pkg );
        WorkingMemory workingMemory = ruleBase.newStatefulSession();

        for ( int i = 0; i &lt; facts.length; i++ ) {
            Object fact = facts[i];
            System.out.println( "Inserting fact: " + fact );
            workingMemory.insert( fact );
        }

        workingMemory.fireAllRules();
    }
}</pre></div></div><br class="example-break"><p>This is our first Example1.java class it loads and executes a single
    drl file "Example.drl" but inserts no data.</p><div class="example"><a name="d0e6353"></a><p class="title"><b>Example&nbsp;10.23.&nbsp;Banking Tutorial : Java Example1</b></p><div class="example-contents"><pre class="programlisting">public class Example1 {
    public static void main(String[] args) throws Exception {
        new RuleRunner().runRules( new String[] { "Example1.drl" },
                                   new Object[0] );
    }
}</pre></div></div><br class="example-break"><p>And this is the first simple rule to execute. It has a single "eval"
    condition that will alway be true, thus this rul will always match and
    fire.</p><div class="example"><a name="d0e6360"></a><p class="title"><b>Example&nbsp;10.24.&nbsp;Banking Tutorial : Rule Example1</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 01"   
    when
        eval (1==1)
    then
        System.out.println("Rule 01 Works");
endh</pre></div></div><br class="example-break"><p>The output for the rule is below, the rule matches and executes the
    single print statement.</p><div class="example"><a name="d0e6367"></a><p class="title"><b>Example&nbsp;10.25.&nbsp;Banking Tutorial : Output Example1</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example1.drl
Rule 01 Works</pre></div></div><br class="example-break"><p>The next step is to assert some simple facts and print them out.
    </p><div class="example"><a name="d0e6374"></a><p class="title"><b>Example&nbsp;10.26.&nbsp;Banking Tutorial : Java Example2</b></p><div class="example-contents"><pre class="programlisting">public class Example2 {
    public static void main(String[] args) throws Exception {
        Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)};
        new RuleRunner().runRules( new String[] { "Example2.drl" },
                                   numbers );
    }
    
    private static Integer wrap(int i) {
        return new Integer(i);
    }
}</pre></div></div><br class="example-break"><p>This doesn&#8217;t use any specific facts but instead asserts a set of
    java.lang.Integer&#8217;s. This is not considered "best practice" as a number of
    a collection is not a fact, it is not a thing. A Bank acount has a number,
    its balance, thus the Account is the fact; but to get started asserting
    Integers shall suffice for demonstration purposes as the complexity is
    built up.</p><p>Now we will create a simple rule to print out these numbers.</p><div class="example"><a name="d0e6383"></a><p class="title"><b>Example&nbsp;10.27.&nbsp;Banking Tutorial : Rule Example2</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 02"   
    when
        Number( $intValue : intValue )
    then
        System.out.println("Number found with value: " + $intValue); 
end</pre></div></div><br class="example-break"><p>Once again, this rule does nothing special. It identifies any facts
    that are Numbers and prints out the values. Notice the user of interfaces
    here, we inserted Integers but the pattern matching engine is able to
    match the interfaces and super classes of the asserted objects.</p><p>The output shows the drl being loaded, the facts inserted and then
    the matched and fired rules. We can see that each inserted number is
    matched and fired and thus printed.</p><div class="example"><a name="d0e6392"></a><p class="title"><b>Example&nbsp;10.28.&nbsp;Banking Tutorial : Output Example2</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example2.drl
Inserting fact: 3
Inserting fact: 1
Inserting fact: 4
Inserting fact: 1
Inserting fact: 5
Number found with value: 5
Number found with value: 1
Number found with value: 4
Number found with value: 1
Number found with value: 3
</pre></div></div><br class="example-break"><p>here are probably a hundred and one better ways to sort numbers; but
    we will need to apply some cashflows in date order when we start looking
    at banking rules so let&#8217;s look at a simple rule based example.</p><div class="example"><a name="d0e6399"></a><p class="title"><b>Example&nbsp;10.29.&nbsp;Banking Tutorial : Java Example3</b></p><div class="example-contents"><pre class="programlisting">public class Example3 {
    public static void main(String[] args) throws Exception {
        Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)};
        new RuleRunner().runRules( new String[] { "Example3.drl" },
                                   numbers );
    }
    
    private static Integer wrap(int i) {
        return new Integer(i);
    }
}</pre></div></div><br class="example-break"><p>Again we insert our Integers as before, this time the rule is
    slightly different:</p><div class="example"><a name="d0e6406"></a><p class="title"><b>Example&nbsp;10.30.&nbsp;Banking Tutorial : Rule Example3</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 03"   
    when
        $number : Number( )
        not Number( intValue &lt; $number.intValue )
    then
        System.out.println("Number found with value: " + $number.intValue() ); 
        retract( $number );
end</pre></div></div><br class="example-break"><p>The first line of the rules identifies a Number and extracts the
    value. The second line ensures that there does not exist a smaller number
    than the one found. By executing this rule, we might expect to find only
    one number - the smallest in the set. However, the retraction of the
    number after it has been printed, means that the smallest number has been
    removed, revealing the next smallest number, and so on. </p><p>So, the output we generate is, notice the numbers are now sorted
    numerically.</p><div class="example"><a name="d0e6415"></a><p class="title"><b>Example&nbsp;10.31.&nbsp;Banking Tutorial : Output Example3</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example3.drl
Inserting fact: 3
Inserting fact: 1
Inserting fact: 4
Inserting fact: 1
Inserting fact: 5
Number found with value: 1
Number found with value: 1
Number found with value: 3
Number found with value: 4
Number found with value: 5
</pre></div></div><br class="example-break"><p>Now we want to start moving towards our personal accounting rules.
    The first step is to create a Cashflow POJO.</p><div class="example"><a name="d0e6422"></a><p class="title"><b>Example&nbsp;10.32.&nbsp;Banking Tutoria : Class Cashflow</b></p><div class="example-contents"><pre class="programlisting">public class Cashflow {
    private Date   date;
    private double amount;

    public Cashflow() {
    }

    public Cashflow(Date date,
                    double amount) {
        this.date = date;
        this.amount = amount;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public double getAmount() {
        return amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    public String toString() {
        return "Cashflow[date=" + date + ",amount=" + amount + "]";
    }
}</pre></div></div><br class="example-break"><p>The Cashflow has two simple attributes, a date and an amount. I have
    added a toString method to print it and overloaded the constructor to set
    the values. The Example4 java code inserts 5 Cashflow objecst with varying
    dates and amounts.</p><div class="example"><a name="d0e6429"></a><p class="title"><b>Example&nbsp;10.33.&nbsp;Banking Tutorial : Java Example4</b></p><div class="example-contents"><pre class="programlisting">public class Example4 {    
    public static void main(String[] args) throws Exception {
        Object[] cashflows = {
            new Cashflow(new SimpleDate("01/01/2007"), 300.00),
            new Cashflow(new SimpleDate("05/01/2007"), 100.00),
            new Cashflow(new SimpleDate("11/01/2007"), 500.00),
            new Cashflow(new SimpleDate("07/01/2007"), 800.00),
            new Cashflow(new SimpleDate("02/01/2007"), 400.00),
        };
        
        new RuleRunner().runRules( new String[] { "Example4.drl" },
                                   cashflows );
    }
}</pre></div></div><br class="example-break"><p>SimpleDate is a simple class that extends Date and takes a String as
    input. It allows for pre-formatted Data classes, for convienience. The
    code is listed below</p><div class="example"><a name="d0e6436"></a><p class="title"><b>Example&nbsp;10.34.&nbsp;Banking Tutorial : Java SimpleDate</b></p><div class="example-contents"><pre class="programlisting">public class SimpleDate extends Date {
    private static final SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy");
    
    public SimpleDate(String datestr) throws Exception {             
        setTime(format.parse(datestr).getTime());
    }
}</pre></div></div><br class="example-break"><p>Now, let&#8217;s look at rule04.drl to see how we print the sorted
    Cashflows:</p><div class="example"><a name="d0e6443"></a><p class="title"><b>Example&nbsp;10.35.&nbsp;Banking Tutorial : Rule Example4</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 04"   
    when
        $cashflow : Cashflow( $date : date, $amount : amount )
        not Cashflow( date &lt; $date)
    then
        System.out.println("Cashflow: "+$date+" :: "+$amount);  
        retract($cashflow);
end</pre></div></div><br class="example-break"><p>Here, we identify a Cashflow and extract the date and the amount. In
    the second line of the rules we ensure that there is not a Cashflow with
    an earlier date than the one found. In the consequences, we print the
    Cashflow that satisfies the rules and then retract it, making way for the
    next earliest Cashflow. So, the output we generate is:</p><div class="example"><a name="d0e6450"></a><p class="title"><b>Example&nbsp;10.36.&nbsp;Banking Tutorial : Output Example4</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example4.drl
Inserting fact: Cashflow[date=Mon Jan 01 00:00:00 GMT 2007,amount=300.0]
Inserting fact: Cashflow[date=Fri Jan 05 00:00:00 GMT 2007,amount=100.0]
Inserting fact: Cashflow[date=Thu Jan 11 00:00:00 GMT 2007,amount=500.0]
Inserting fact: Cashflow[date=Sun Jan 07 00:00:00 GMT 2007,amount=800.0]
Inserting fact: Cashflow[date=Tue Jan 02 00:00:00 GMT 2007,amount=400.0]
Cashflow: Mon Jan 01 00:00:00 GMT 2007 :: 300.0
Cashflow: Tue Jan 02 00:00:00 GMT 2007 :: 400.0
Cashflow: Fri Jan 05 00:00:00 GMT 2007 :: 100.0
Cashflow: Sun Jan 07 00:00:00 GMT 2007 :: 800.0
Cashflow: Thu Jan 11 00:00:00 GMT 2007 :: 500.0
</pre></div></div><br class="example-break"><p>Here we extend our Cashflow to give a TypedCashflow which can be
    CREDIT or DEBIT. Ideally, we would just add this to the Cashflow type, but
    so that we can keep all the examples simple, we will go with the
    extensions.</p><div class="example"><a name="d0e6457"></a><p class="title"><b>Example&nbsp;10.37.&nbsp;Banking Tutoria : Class TypedCashflow</b></p><div class="example-contents"><pre class="programlisting">public class TypedCashflow extends Cashflow {
    public static final int CREDIT = 0;
    public static final int DEBIT  = 1;

    private int             type;

    public TypedCashflow() {
    }

    public TypedCashflow(Date date,
                         int type,
                         double amount) {
        super( date,
               amount );
        this.type = type;
    }

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public String toString() {
        return "TypedCashflow[date=" + getDate() + ",type=" + (type == CREDIT ? "Credit" : "Debit") + ",amount=" + getAmount() + "]";
    }
}</pre></div></div><br class="example-break"><p>There are lots of ways to improve this code, but for the sake of the
    example this will do.</p><p>Nows lets create the Example5 runner.</p><div class="example"><a name="d0e6466"></a><p class="title"><b>Example&nbsp;10.38.&nbsp;Banking Tutorial : Java Example5</b></p><div class="example-contents"><pre class="programlisting">public class Example5 {    
    public static void main(String[] args) throws Exception {      
        Object[] cashflows = {
            new TypedCashflow(new SimpleDate("01/01/2007"),    
                              TypedCashflow.CREDIT, 300.00),
            new TypedCashflow(new SimpleDate("05/01/2007"),
                              TypedCashflow.CREDIT, 100.00),
            new TypedCashflow(new SimpleDate("11/01/2007"),
                              TypedCashflow.CREDIT, 500.00),
            new TypedCashflow(new SimpleDate("07/01/2007"),
                              TypedCashflow.DEBIT, 800.00),
            new TypedCashflow(new SimpleDate("02/01/2007"),
                              TypedCashflow.DEBIT, 400.00),
        };
        
        new RuleRunner().runRules( new String[] { "Example5.drl" },
                                   cashflows );
    }
}</pre></div></div><br class="example-break"><p>Here, we simply create a set of Cashflows which are either CREDIT or
    DEBIT Cashflows and supply them and rule05.drl to the RuleEngine. </p><p>Now, let&#8217;s look at rule0 Example5.drl to see how we print the sorted
    Cashflows:</p><div class="example"><a name="d0e6475"></a><p class="title"><b>Example&nbsp;10.39.&nbsp;Banking Tutorial : Rule Example5</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 05"  
    when
        $cashflow : TypedCashflow( $date : date,
                                   $amount : amount,
                                   type == TypedCashflow.CREDIT )
        not TypedCashflow( date &lt; $date,
                           type == TypedCashflow.CREDIT )
    then
        System.out.println("Credit: "+$date+" :: "+$amount);   
        retract($cashflow);
end</pre></div></div><br class="example-break"><p>Here, we identify a Cashflow with a type of CREDIT and extract the
    date and the amount. In the second line of the rules we ensure that there
    is not a Cashflow of type CREDIT with an earlier date than the one found.
    In the consequences, we print the Cashflow that satisfies the rules and
    then retract it, making way for the next earliest Cashflow of type
    CREDIT.</p><p>So, the output we generate is</p><div class="example"><a name="d0e6484"></a><p class="title"><b>Example&nbsp;10.40.&nbsp;Banking Tutorial : Output Example5</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example5.drl
Inserting fact: TypedCashflow[date=Mon Jan 01 00:00:00 GMT 2007,type=Credit,amount=300.0]
Inserting fact: TypedCashflow[date=Fri Jan 05 00:00:00 GMT 2007,type=Credit,amount=100.0]
Inserting fact: TypedCashflow[date=Thu Jan 11 00:00:00 GMT 2007,type=Credit,amount=500.0]
Inserting fact: TypedCashflow[date=Sun Jan 07 00:00:00 GMT 2007,type=Debit,amount=800.0]
Inserting fact: TypedCashflow[date=Tue Jan 02 00:00:00 GMT 2007,type=Debit,amount=400.0]
Credit: Mon Jan 01 00:00:00 GMT 2007 :: 300.0
Credit: Fri Jan 05 00:00:00 GMT 2007 :: 100.0
Credit: Thu Jan 11 00:00:00 GMT 2007 :: 500.0
</pre></div></div><br class="example-break"><p>Here we are going to process both CREDITs and DEBITs on 2 bank
    accounts to calculate the account balance. In order to do this, I am going
    to create two separate Account Objects and inject them into the Cashflows
    before passing them to the Rule Engine. The reason for this is to provide
    easy access to the correct Bank Accounts without having to resort to
    Helper classes. Let&#8217;s take a look at the Account class first. This is a
    simple POJO with an account number and balance:</p><div class="example"><a name="d0e6491"></a><p class="title"><b>Example&nbsp;10.41.&nbsp;Banking Tutoria : Class Account</b></p><div class="example-contents"><pre class="programlisting">public class Account {
    private long   accountNo;
    private double balance = 0;

    public Account() {
    }

    public Account(long accountNo) {
        this.accountNo = accountNo;
    }

    public long getAccountNo() {
        return accountNo;
    }

    public void setAccountNo(long accountNo) {
        this.accountNo = accountNo;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public String toString() {
        return "Account[" + "accountNo=" + accountNo + ",balance=" + balance + "]";
    }
}</pre></div></div><br class="example-break"><p>Now let&#8217;s extend our TypedCashflow to give AllocatedCashflow
    (allocated to an account).</p><div class="example"><a name="d0e6498"></a><p class="title"><b>Example&nbsp;10.42.&nbsp;Banking Tutoria : Class AllocatedCashflow</b></p><div class="example-contents"><pre class="programlisting">public class AllocatedCashflow extends TypedCashflow {
    private Account account;

    public AllocatedCashflow() {
    }

    public AllocatedCashflow(Account account,
                             Date date,
                             int type,
                             double amount) {
        super( date,
               type,
               amount );
        this.account = account;
    }

    public Account getAccount() {
        return account;
    }

    public void setAccount(Account account) {
        this.account = account;
    }

    public String toString() {
        return "AllocatedCashflow[" + "account=" + account + ",date=" + getDate() + 
                                  ",type=" + (getType() == CREDIT ? "Credit" : "Debit") + 
                                  ",amount=" + getAmount() + "]";
    }
}</pre></div></div><br class="example-break"><p>Now, let&#8217;s java code for Example5 execution. Here we create two
    Account objects and inject one into each cashflow as appropriate. For
    simplicity I have simply included them in the constructor.</p><div class="example"><a name="d0e6505"></a><p class="title"><b>Example&nbsp;10.43.&nbsp;Banking Tutorial : Java Example5</b></p><div class="example-contents"><pre class="programlisting">public class Example6 {    
    public static void main(String[] args) throws Exception {      
        Account acc1 = new Account(1);
        Account acc2 = new Account(2);
           
        Object[] cashflows = {
            new AllocatedCashflow(acc1,new SimpleDate("01/01/2007"),
                                  TypedCashflow.CREDIT, 300.00),
            new AllocatedCashflow(acc1,new SimpleDate("05/02/2007"),
                                  TypedCashflow.CREDIT, 100.00),
            new AllocatedCashflow(acc2,new SimpleDate("11/03/2007"),
                                  TypedCashflow.CREDIT, 500.00),
            new AllocatedCashflow(acc1,new SimpleDate("07/02/2007"),
                                  TypedCashflow.DEBIT,  800.00),
            new AllocatedCashflow(acc2,new SimpleDate("02/03/2007"),
                                  TypedCashflow.DEBIT,  400.00),
            new AllocatedCashflow(acc1,new SimpleDate("01/04/2007"),    
                                  TypedCashflow.CREDIT, 200.00),
            new AllocatedCashflow(acc1,new SimpleDate("05/04/2007"),
                                  TypedCashflow.CREDIT, 300.00),
            new AllocatedCashflow(acc2,new SimpleDate("11/05/2007"),
                                  TypedCashflow.CREDIT, 700.00),
            new AllocatedCashflow(acc1,new SimpleDate("07/05/2007"),
                                  TypedCashflow.DEBIT,  900.00),
            new AllocatedCashflow(acc2,new SimpleDate("02/05/2007"),
                                  TypedCashflow.DEBIT,  100.00)           
        };
        
        new RuleRunner().runRules( new String[] { "Example6.drl" },
                                   cashflows );
    }
}</pre></div></div><br class="example-break"><p>Now, let&#8217;s look at rule Example06.drl to see how we apply each
    cashflow in date order and calculate and print the balance. </p><div class="example"><a name="d0e6512"></a><p class="title"><b>Example&nbsp;10.44.&nbsp;Banking Tutorial : Rule Example6</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 06 - Credit"  
    when
        $cashflow : AllocatedCashflow( $account : account,
                                       $date : date, $amount : amount,
                                        type==TypedCashflow.CREDIT )
        not AllocatedCashflow( account == $account, date &lt; $date)
    then
        System.out.println("Credit: " + $date + " :: " + $amount);     
        $account.setBalance($account.getBalance()+$amount);
        System.out.println("Account: " + $account.getAccountNo() +
                           " - new balance: " + $account.getBalance());          
        retract($cashflow);
end

rule "Rule 06 - Debit"  
    when
        $cashflow : AllocatedCashflow( $account : account,
                            $date : date, $amount : amount,
                            type==TypedCashflow.DEBIT )
        not AllocatedCashflow( account == $account, date &lt; $date)
    then
        System.out.println("Debit: " + $date + " :: " + $amount);      
        $account.setBalance($account.getBalance() - $amount);
        System.out.println("Account: " + $account.getAccountNo() +
                           " - new balance: " + $account.getBalance());           
        retract($cashflow);
end</pre></div></div><br class="example-break"><p>Here, we have separate rules for CREDITs and DEBITs, however we do
    not specify a type when checking for earlier cashflows. This is so that
    all cashflows are applied in date order regardless of which type of
    cashflow type they are. In the rule section we identify the correct
    account to work with and in the consequences we update it with the
    cashflow amount.</p><div class="example"><a name="d0e6519"></a><p class="title"><b>Example&nbsp;10.45.&nbsp;Banking Tutorial : Output Example6</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example6.drl
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Jan 01 00:00:00 GMT 2007,type=Credit,amount=300.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Feb 05 00:00:00 GMT 2007,type=Credit,amount=100.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Sun Mar 11 00:00:00 GMT 2007,type=Credit,amount=500.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Wed Feb 07 00:00:00 GMT 2007,type=Debit,amount=800.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri Mar 02 00:00:00 GMT 2007,type=Debit,amount=400.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Sun Apr 01 00:00:00 BST 2007,type=Credit,amount=200.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Thu Apr 05 00:00:00 BST 2007,type=Credit,amount=300.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri May 11 00:00:00 BST 2007,type=Credit,amount=700.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon May 07 00:00:00 BST 2007,type=Debit,amount=900.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Wed May 02 00:00:00 BST 2007,type=Debit,amount=100.0]
Debit: Fri Mar 02 00:00:00 GMT 2007 :: 400.0
Account: 2 - new balance: -400.0
Credit: Sun Mar 11 00:00:00 GMT 2007 :: 500.0
Account: 2 - new balance: 100.0
Debit: Wed May 02 00:00:00 BST 2007 :: 100.0
Account: 2 - new balance: 0.0
Credit: Fri May 11 00:00:00 BST 2007 :: 700.0
Account: 2 - new balance: 700.0
Credit: Mon Jan 01 00:00:00 GMT 2007 :: 300.0
Account: 1 - new balance: 300.0
Credit: Mon Feb 05 00:00:00 GMT 2007 :: 100.0
Account: 1 - new balance: 400.0
Debit: Wed Feb 07 00:00:00 GMT 2007 :: 800.0
Account: 1 - new balance: -400.0
Credit: Sun Apr 01 00:00:00 BST 2007 :: 200.0
Account: 1 - new balance: -200.0
Credit: Thu Apr 05 00:00:00 BST 2007 :: 300.0
Account: 1 - new balance: 100.0
Debit: Mon May 07 00:00:00 BST 2007 :: 900.0
Account: 1 - new balance: -800.0
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6524"></a>10.1.4.&nbsp;Fibonacci Example</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Fibonacci 
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.FibonacciExample
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> Fibonacci.drl
<span class="bold"><strong>Objective:</strong></span> Demonsrates Recursion, 'not' CEs and Cross Product Matching</pre><p>The Fibonacci Numbers, <a class="ulink" href="http://en.wikipedia.org/wiki/Fibonacci_number" target="_top">http://en.wikipedia.org/wiki/Fibonacci_number</a>,
    invented by Leonardo of Pisa, <a class="ulink" href="http://en.wikipedia.org/wiki/Fibonacci" target="_top">http://en.wikipedia.org/wiki/Fibonacci</a>,
    are obtained by starting with 0 and 1, and then produce the next Fibonacci
    number by adding the two previous Fibonacci numbers. The first Fibonacci
    numbers for n = 0, 1,... are: * 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,
    144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946... The Fibonacci
    Example demonstrates recursion and conflict resolution with Salience
    values.</p><p>A single fact Class is used in this example, Fibonacci. It has two
    fields, sequence and value. The sequence field is used to indicate the
    position of the object in the Fibonacci number sequence and the value
    field shows the value of that Fibonacci object for that sequence
    position.</p><div class="example"><a name="d0e6553"></a><p class="title"><b>Example&nbsp;10.46.&nbsp;Fibonacci Class</b></p><div class="example-contents"><pre class="programlisting">public static class Fibonacci {
    private int  sequence;
    private long value;

    ... setters and getters go here...
}</pre></div></div><br class="example-break"><p>Execute the example:</p><div class="orderedlist"><ol type="1"><li><p>Open the class org.drools.examples.FibonacciExample in your
          Eclipse IDE</p></li><li><p>Right-click the class an select "Run as..." -&gt; "Java
          application"</p></li></ol></div><p>And the Eclipse show the following output in it's console,
    "...snip..." shows repeated bits removed to save space:</p><div class="example"><a name="d0e6569"></a><p class="title"><b>Example&nbsp;10.47.&nbsp;Fibonacci Example Console Output</b></p><div class="example-contents"><pre class="programlisting">recurse for 50
recurse for 49
recurse for 48
recurse for 47
...snip...
recurse for 5
recurse for 4
recurse for 3
recurse for 2
1 == 1
2 == 1
3 == 2
4 == 3
5 == 5
6 == 8
...snip...
47 == 2971215073
48 == 4807526976
49 == 7778742049
50 == 12586269025
</pre></div></div><br class="example-break"><p>To kick this off from java we only insert a single Fibonacci object,
    with a sequence of 50, a recurse rule is then used to insert the other 49
    Fibonacci objects. This example doesn't use PropertyChangeSupport and uses
    the MVEL dialect, this means we can use the <span class="bold"><strong>modify</strong></span> keyword, which allows a block setter action
    which also notifies the engine of changes.</p><div class="example"><a name="d0e6579"></a><p class="title"><b>Example&nbsp;10.48.&nbsp;Fibonacci Example Execution</b></p><div class="example-contents"><pre class="programlisting">session.insert( new Fibonacci( 50 ) );
session.fireAllRules();</pre></div></div><br class="example-break"><p>The recurse rule is very simple, it matches each asserted Fibonacci
    object with a value of -1, it then creates and asserts a new Fibonacci
    object with a sequence of one less than the currently matched object. Each
    time a Fibonacci object is added, as long as one with a "sequence == 1"
    does not exist, the rule re-matches again and fires; causing the
    recursion. The 'not' conditional element is used to stop the rule matching
    once we have all 50 Fibonacci objects in memory. The rule also has a
    salience value, this is because we need to have all 50 Fibonacci objects
    asserted before we execute the Bootstrap rule.</p><div class="example"><a name="d0e6586"></a><p class="title"><b>Example&nbsp;10.49.&nbsp;Fibonacci Example : Rule "Recurse"</b></p><div class="example-contents"><pre class="programlisting">rule Recurse
    salience 10
    when
        f : Fibonacci ( value == -1 )
        not ( Fibonacci ( sequence == 1 ) )
    then
        insert( new Fibonacci( f.sequence - 1 ) );
        System.out.println( "recurse for " + f.sequence );
end</pre></div></div><br class="example-break"><p>The audit view shows the original assertion of the Fibonacci object
    with a sequence of 50, this was done from Java land. From there the audit
    view shows the continual recursion of the rule, each asserted Fibonacci
    causes the "Recurse" rule to become activate again, which then
    fires.</p><div class="figure"><a name="d0e6593"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/fibonacci1.png" alt="Fibonacci Example &#34;Recurse&#34; Audit View 1"></div></div><p class="title"><b>Figure&nbsp;10.6.&nbsp;Fibonacci Example "Recurse" Audit View 1</b></p></div><br class="figure-break"><p>When a Fibonacci with a sequence of 2 is asserted the "Bootstrap"
    rule is matched and activated along with the "Recurse" rule.</p><div class="example"><a name="d0e6601"></a><p class="title"><b>Example&nbsp;10.50.&nbsp;Fibonacci Example : Rule "Bootstrap"</b></p><div class="example-contents"><pre class="programlisting">rule Bootstrap
    when
        f : Fibonacci( sequence == 1 || == 2, value == -1 ) // this is a multi-restriction || on a single field
    then 
        modify ( f ){ value = 1 };
        System.out.println( f.sequence + " == " + f.value );
end</pre></div></div><br class="example-break"><p>At this point the Agenda looks like the figure shown below. However
    the "Bootstrap" rule does not fire as the "Recurse" rule has a higher
    salience.</p><div class="figure"><a name="d0e6608"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/fibonacci_agenda1.png" alt="Fibonacci Example &#34;Recurse&#34; Agenda View 1"></div></div><p class="title"><b>Figure&nbsp;10.7.&nbsp;Fibonacci Example "Recurse" Agenda View 1</b></p></div><br class="figure-break"><p>When a Fibonacci with a sequence of 1 is asserted the "Bootstrap"
    rule is matched again, causing two activations for this rule; note that
    the "Recurse" rule does not match and activate because the 'not
    conditional element stops the rule matching when a Fibonacci with a
    sequence of 1 exists.</p><div class="figure"><a name="d0e6616"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/fibonacci_agenda2.png" alt="Fibonacci Example &#34;Recurse&#34; Agenda View 2"></div></div><p class="title"><b>Figure&nbsp;10.8.&nbsp;Fibonacci Example "Recurse" Agenda View 2</b></p></div><br class="figure-break"><p>Once we have two Fibonacci objects both with values not equal to -1
    the "calculate" rule is able to match; remember it was the "Bootstrap"
    rule that set the Fibonacci's with sequences 1 and 2 to values of 1. At
    this point we have 50 Fibonacci objects in the Working Memory and we some
    how need to select the correct ones to calculate each of their values in
    turn. With three Fibonacci patterns in a rule with no field constriants to
    correctly constrain the available cross products we have 50x50x50 possible
    permutations, thats 125K possible rule firings. The "Calculate" rule uses
    the field constraints to correctly constraint the thee Fibonacci patterns
    and in the correct order; this technique is called "cross product
    matching". The first pattern finds any Fibonacci with a value != -1 and
    binds both the pattern and the field. The second Fibonacci does too but it
    adds an additional field constraint to make sure that its sequence is one
    greater than the Fibonacci bound to f1. When this rule first fires we know
    that only sequences 1 and 2 have values of 1 and the two constraints
    ensure that f1 references sequence 1 and f2 references sequence2. The
    final pattern finds the Fibonacci of a value == -1 with a sequence one
    greater than f2. At this point we have three Fibonacci objects correctly
    selected from the available cross products and we can do the maths
    calculating the value for Fibonacci sequence = 3.</p><div class="example"><a name="d0e6624"></a><p class="title"><b>Example&nbsp;10.51.&nbsp;Fibonacci Example : Rule "Calculate"</b></p><div class="example-contents"><pre class="programlisting">rule Calculate
    when
        f1 : Fibonacci( s1 : sequence, value != -1 ) // here we bind sequence
        f2 : Fibonacci( sequence == (s1 + 1 ), value != -1 ) // here we don't, just to demonstrate the different way bindings can be used
        f3 : Fibonacci( s3 : sequence == (f2.sequence + 1 ), value == -1 )              
    then    
        modify ( f3 ) { value = f1.value + f2.value };
        System.out.println( s3 + " == " + f3.value ); // see how you can access pattern and field  bindings
end 
</pre></div></div><br class="example-break"><p>The MVEL modify keyword updated the value of the Fibonacci object
    bound to f3, this means we have a new Fibonacci object with a value != -1,
    this allows the "Calculate" rule to rematch and calculate the next
    Fibonacci number. The Audit view below shows the how the firing of the
    last "Bootstrap" modifies the Fibonacci object enabling the "Calculate"
    rule to match, which then modifies another Fibonacci object allowing the
    "Calculate" rule to rematch. This continues till the value is set for all
    Fibonacci objects.</p><div class="figure"><a name="d0e6631"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/fibonacci4.png" alt="Fibonacci Example &#34;Bootstrap&#34; Audit View 1"></div></div><p class="title"><b>Figure&nbsp;10.9.&nbsp;Fibonacci Example "Bootstrap" Audit View 1</b></p></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6637"></a>10.1.5.&nbsp;Golfing Example</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Golfing
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.GolfingExample
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> golf.drl
<span class="bold"><strong>Objective:</strong></span> Configuration example that finds the solution from a large number of available cross products
</pre><p>The golf example solves a "riddle" style problem that is simple
    enough to state in sentences, but for which a conventional algorithmic
    solition is not obvious. It does this by searching for a suitable
    combination from a "space" of possible solutions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6658"></a>10.1.5.1.&nbsp;The riddle</h4></div></div></div><p>The problem is written as a riddle:</p><div class="orderedlist"><ol type="1"><li><p>A foursome of golfers is standing at a tee, in a line from
          left to right.</p></li><li><p>Each golfer wears different colored pants; one is wearing red
          pants.</p></li><li><p>The golfer to Fred&#8217;s immediate right is wearing blue
          pants.</p></li><li><p>Joe is second in line.</p></li><li><p>Bob is wearing plaid pants.</p></li><li><p>Tom isn&#8217;t in position one or four, and he isn&#8217;t wearing the
          hideous orange pants.</p></li></ol></div><p>The immediate thing about this riddle, is that a solution is not
      obvious (of course ! it wouldn't be a riddle otherwise !). It also isn't
      obvious how to write an algorithm to solve it (if it is for you - then
      you can take a break now, go have a coffee or someting to reward your
      uber intellect).</p><p>Instead of thinking about how to solve it, we can be lazy and use
      rules instead. So we don't attempt to solve it, we just state the
      problem in rules, and let the engine derive the solution.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6686"></a>10.1.5.2.&nbsp;Launching the example</h4></div></div></div><p>The supporting code is in the GolfingExample.java class. There is
      an inner class "Golfer" which represents a golf player, it has their
      name, position (1 to 4 meaning left to right), and their pants color, as
      simple properties.</p><pre class="programlisting">String[] names = new String[] { "Fred", "Joe", "Bob", "Tom" };
String[] colors = new String[] { "red", "blue", "plaid", "orange" };
int[] positions = new int[] { 1, 2, 3, 4 };
        
for ( int n = 0; n &lt; names.length; n++ ) {
    for ( int c = 0; c &lt; colors.length; c++ ) {
        for ( int p = 0; p &lt; positions.length; p++ ) {
            session.insert( new Golfer( names[n], colors[c], positions[p]) );
        }                
    }            
}      </pre><p>The above listing shows the interesting part of the supporting
      code. Note that we have arrays representing each name, color, and
      position. We then go through a nested loop inserting instances of Golfer
      - so in the working memory we will have all combinations of name, color
      and position. It is then the job of the rules to find the appropriate
      one.</p><p>Launching the code as a java application should yield the
      following output:</p><pre class="programlisting">Fred 1 orange
Joe 2 blue
Bob 4 plaid
Tom 3 red     </pre><p>This shows that the rule(s) have found a suitable solution.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6701"></a>10.1.5.3.&nbsp;The matching rule</h4></div></div></div><p>The solution in rules is quite simple, it is a single rule which
      expresses the constraints as stated in the riddle. Effectively, we can
      interpret the riddle as a series of constraints on our object model.
      Given that we have enough "combinations" in the working memory, all we
      have to do is express the constraints in a rule and the engine will
      match it with a solution (we don't really care how it does it, as long
      as it works !).</p><p>There is one rule in the solution, in golf.drl, called "find
      solution". The rule is made up of 5 patterns, with constraints that map
      to items in the riddle.</p><pre class="programlisting">$fred : Golfer( name == "Fred" )      </pre><p>In the above pattern, we are simply matching a Golfer who is
      called fred, and binding it to a variable called $fred. All that we know
      is that there is a golfer called fred.</p><pre class="programlisting">$joe : Golfer( name == "Joe",
               position == 2,
               position != $fred.position,
               color != $fred.color )      </pre><p>The next pattern says that we have a golfer named Joe, in position
      2 ("second in line"). Now, we also know that he must NOT be in the same
      position as fred (of course !) and have different color pants. So far,
      nothing that amazing.</p><pre class="programlisting">$bob : Golfer( name == "Bob",
               position != $fred.position,
               position != $joe.position,
               color == "plaid",
               color != $fred.color,
               color != $joe.color )      </pre><p>Refering to the above, we also know there is a golfer called Bob,
      who wears plaid pants - once again that all we know about him. but of
      course, we add in the constraints that he must be in a different
      position to fred, joe, and also have different colored pants.</p><pre class="programlisting">$tom : Golfer( name == "Tom",
               position != 1,
               position != 4,
               position != $fred.position,
               position != $joe.position,
               position != $bob.position,
               color != "orange,               
               color != $fred.color,
               color != $joe.color,
               color != $bob.color )      </pre><p>(referring to the above) We also know that there is a guy called
      Tom, who doesn't wear the Orange pants, AND he is not in position 1, or
      4. Of course we also add in the other constraints (he must be in a
      different position to the others so far, and have a different
      color).</p><pre class="programlisting">Golfer( position == ( $fred.position + 1 ),
        color == "blue",
        this in ( $joe, $bob, $tom ) )      </pre><p>Finally, we know that the golfer on the right of Fred (position +
      1), is in blue pants. We also add in the constraint that he must be
      either Joe, Bob or Tom (as Fred can't be beside himself, well he can I
      guess, but not in the sense we mean here !) - note the use of "this" to
      refer to the current pattern, we don't really care who "this" is, just
      who they are not. Maybe if Fred was really really happy they this
      wouldn't work, but lets assume otherwise for now.</p><p>Thats it ! We have expressed the rule as constraints that map to
      the ones expressed in the riddle, yet we haven't had to solve the
      riddle, the engine does that for us.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6730"></a>10.1.5.4.&nbsp;Conclustion</h4></div></div></div><p>This simple example shows how you can express a problem
      declaratively, and let the engine solve the problem for you, by making
      use of combinations. This is an often useful technique, as it allows you
      to express rules as a statement of the problem you are trying to
      solve.</p><p>Of course, care must be taken. Using combinatorics like this can
      cause performance problems when there are large numbers of facts (eg in
      this case, if there were a larger number of golfers, or colors/positions
      etc - possibilities). When the fact count grows, the combinations the
      engine has to deal with can explode exponentially, making this not very
      efficient. However, in cases where the rules are perhaps complex, the
      problem is hard, but the fact numbers are relatively low, this approach
      can be very very useful and help you solve problems that would otherwise
      be very hard.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6737"></a>10.1.6.&nbsp;Trouble Ticket</h3></div></div></div><p>The trouble ticket example shows how to use the duration attribute
    for temporal rules, and also includes an alternative version using a
    dsl.</p><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> TroubleTicket
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.TroubleTicketExample, org.drools.examples.TroubleTicketExampleWithDSL
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> TroubleTicket.drl, TroubleTicketWithDSL.dslr
<span class="bold"><strong>Objective:</strong></span> Show temporal rules in action
</pre><p>The trouble ticket example is based around the idea of raising a
    "ticket" (ie an issue) with a vendor (these are the vendors rules). Each
    customer has a subscription class assigned to it (eg Gold, Silver etc) and
    their class determines how the ticket is treated with respect to time, and
    escalating the issue. The normal drl version will be discussed here, but
    logically the DSL version is the same (it just uses a DSL defined language
    instead of the normal DRL).</p><p>We have 2 types of facts, Customer and Ticket. A Ticket belongs to
    one and only one customer. A Customer has a name and a "subscription" type
    (Gold, Silver or Platinum). A ticket also has a "status" - which
    determines (obviously) what state it is in. The state may be set
    externally, or by the rules engine (eg it starts out "New", and then the
    system user determines that it is "Done" at some later point). The rules
    exist to ensure that the tickets are escalated appropriately based on the
    customer subscription class.</p><p>Customers can choose Silver, Gold, or Platinum (in order of
    increasing responsiveness). Platinum subscriptions also come with a set of
    steak knives, and a personal butler to lodge the ticket for you (but
    obviously it costs more).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6764"></a>10.1.6.1.&nbsp;Executing the Example</h4></div></div></div><p>The example creates 4 customers, with their name and subscription
      class, it then creates 4 tickets for each of the customers, note that
      the ticket takes the customer in the constructor (that sets up the
      object relationship. The tickets and the customers are then inserted.
      Notice that we keep a fact handle - which we will use to notify the
      engine that that specific ticket changed later on. The last line has the
      all important fireAllRules(), which tells the engine to take action on
      the data it has.</p><div class="example"><a name="d0e6769"></a><p class="title"><b>Example&nbsp;10.52.&nbsp;Trouble Ticket Example : Creating and Inserting Facts</b></p><div class="example-contents"><pre class="programlisting">Customer a = new Customer( "A",
                           "Gold" );
Customer b = new Customer( "B",
                           "Platinum" );
Customer c = new Customer( "C",
                           "Silver" );
Customer d = new Customer( "D",
                           "Silver" );

Ticket t1 = new Ticket( a );
Ticket t2 = new Ticket( b );
Ticket t3 = new Ticket( c );
Ticket t4 = new Ticket( d );

session.insert( a );
session.insert( b );
session.insert( c );
session.insert( d );

session.insert( t1 );
session.insert( t2 );
FactHandle ft3 = session.insert( t3 );
session.insert( t4 );

session.fireAllRules();</pre></div></div><br class="example-break"><p>We have the "New Ticket" rule which has the highest priority
      (salience of 10 - the default is zero), The purpose of this is simply to
      log the fact that a new ticket has arrived in the system:</p><pre class="programlisting">rule "New Ticket"
 salience 10
 when
  customer : Customer( )
  ticket : Ticket( customer == customer, status == "New" )
  then
 System.out.println( "New : " + ticket );
end    </pre><p>Note that we are "joining" the ticket fact with the customer fact.
      It's not really needed in this case, as we don't do anything (yet) with
      the customer fact. If you look in the TroubleTicketExample.java, you
      will also see that the facts are being inserted into the engine - note
      that we assert BOTH Customer and Ticket object (even though the ticket
      belongs to a customer - this allows the engine to join the objects
      together how it wants - this is what is meant by "relational"
      programming - we let the rule engine define what the relationships are.
      For instance, although the code is structured so that a ticket belongs
      to a customer, we may be interested in looking at tickets from different
      customers of the same type in the future).</p><p>If we run the rules, we should expect that the "New Ticket" rule
      will be activated for all tickets, so looking at the audit log view (by
      opening the file which was saved automatically when the rules were
      run):</p><div class="figure"><a name="d0e6782"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/tt_audit_view.png" alt="Audit view"></div></div><p class="title"><b>Figure&nbsp;10.10.&nbsp;Audit view</b></p></div><br class="figure-break"><p>Referring to the above audit log, we can see each customer
      asserted, but nothing happens. As soon as the first ticket gets
      asserted, it joins it with the customer, and creates some activations:
      one is the "new ticket" rule, the other is for the appropriate priority
      (which we will show below). Note that items in the above view do not
      mean the rule fired at that point.</p><p>Also, don't forget to use "fireAllRules()" - a common mistake !
      (In this case we are using a statefull session, so this is
      necessary).</p><p>If we run the rules, we should expect that the "New Ticket" rule
      will be activated for all tickets, so looking at the audit log view (by
      opening the file which was saved automatically when the rules were
      run):</p><div class="figure"><a name="d0e6794"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/tt_audit_view.png" alt="Audit view"></div></div><p class="title"><b>Figure&nbsp;10.11.&nbsp;Audit view</b></p></div><br class="figure-break"><p>Referring to the above audit log, we can see each customer
      asserted, but nothing happens. As soon as the first ticket gets
      asserted, it joins it with the customer, and creates some activations:
      one is the "new ticket" rule, the other is for the appropriate priority
      (which we will show below). Note that items in the above view do not
      mean the rule fired at that point.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6802"></a>10.1.6.2.&nbsp;Platinum gets the best service</h4></div></div></div><p>All the wonderful platinum customers have to get great service, so
      first thing to note is that as soon as a ticket arrives, we escalate if
      it is for a platinum customer:</p><pre class="programlisting">rule "Platinum Priority"
 when
  customer : Customer( subscription == "Platinum" )
  ticket : Ticket( customer == customer, status == "New" )
 then;
  ticket.setStatus( "Escalate" );
  update( ticket );
end      </pre><p>Here we are joining Ticket to customer again (customer ==
      customer), but we are also checking that the customer is "Platinum".
      When this is the case, we set the ticket status to "Escalate" and call
      update (which tells the engine that the ticket has changed).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6811"></a>10.1.6.3.&nbsp;Silver and Gold</h4></div></div></div><p>For silver and gold class, its a similar story to platinum:</p><pre class="programlisting">rule "Silver Priority"
 duration 3000
 when
  customer : Customer( subscription == "Silver" )
  ticket : Ticket( customer == customer, status == "New" )
 then
  ticket.setStatus( "Escalate" );
  update( ticket );
end

rule "Gold Priority"
 duration 1000
 when
  customer : Customer( subscription == "Gold" )
  ticket : Ticket( customer == customer, status == "New" )
 then
  ticket.setStatus( "Escalate" );
  update( ticket );
end   </pre><p>In this case, note the use of "duration XXX" - XXX is the number
      of milliseconds to wait to check that this rule holds true. Should it do
      so, after XXX milliseconds, then the action takes effect. So in the
      above case, after 3 seconds the "Silver" priority kicks in, but after 1
      second "Gold" does. In both cases the tickets are escalated (just like
      with platinum. This is what we mean by temporal rules (rules that take
      effect over time).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6820"></a>10.1.6.4.&nbsp;Escalating</h4></div></div></div><p>The actual escalation of a ticket happens in a rule:</p><pre class="programlisting">rule "Escalate"
 when
  customer : Customer( )
  ticket : Ticket( customer == customer, status == "Escalate" )
 then
  sendEscalationEmail( customer, ticket );
end     </pre><p>In this case, the action is to call a function which sends an
      email (the function is defined down the bottom of the drl file). This
      rule reacts to the rules which update the ticket and set its status to
      escalate.</p></div><p>In the code that launches the example, we have a "sleep" to make
    sure all this happens (and print out the results). Note also that after
    the rules are fired, we modify the status of the Customer "C" to "Done" -
    and then tell the engine. This causes it to evaluate and fire the rule
    that looks for "tickets" that are "Done" (in which is just logs a
    message).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6831"></a>10.1.6.5.&nbsp;Running it</h4></div></div></div><p>Running the example (by launching the TroubleTicket.java class as
      an application) should yield the output:</p><pre class="programlisting">New : [Ticket [Customer D : Silver] : New]
New : [Ticket [Customer C : Silver] : New]
New : [Ticket [Customer B : Platinum] : New]
New : [Ticket [Customer A : Gold] : New]
Email : [Ticket [Customer B : Platinum] : Escalate]
[[ Sleeping 5 seconds ]]
Email : [Ticket [Customer A : Gold] : Escalate]
Done : [Ticket [Customer C : Silver] : Done]
Email : [Ticket [Customer D : Silver] : Escalate]
[[ awake ]]    </pre><div class="figure"><a name="d0e6838"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/tt_audit_firing.png" alt="Audit log"></div></div><p class="title"><b>Figure&nbsp;10.12.&nbsp;Audit log</b></p></div><br class="figure-break"><p>Referring to the above audit log, we can see the events as they
      happen. Once the rules start firing, the first items are the "Activation
      Executed" for the new tickets, as expected (they do nothing, just log
      the fact). Note the "Activation executed" item for the platinum ticket -
      that is the next one to go (remember it has the default salience, so it
      happens after the "New ticket" rule, but otherwise it is immediate -
      there is no "duration" delay for it). The platinum activation results in
      a Object modification (which is the escalation) - this in turn creates
      an activation record for the "escalate ticket" rule - which is what we
      wanted. Straight after that it executes the action to escalate the
      ticket.</p><p>The next event to occur is due to the: </p><pre class="programlisting">t3.setStatus( "Done" );

session.update( ft3,
                t3 );
</pre><p> in the code (outside of rules) - this simulates a customer
      service officer maarking a ticket as done (and of course, uses the fact
      handle we kept from before). This results in a cancelled activation (as
      we no longer have a New Silvert customer ticket - it is done) and a new
      activation to log the fact it was done.</p><p>In all the excitement, in parallel the engine has been watching
      the time pass, and it happens that the Gold tickets start to escalate,
      and then silver (as expected).</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6854"></a>10.1.7.&nbsp;Pricing Rule Decision Table Example</h3></div></div></div><p>The Pricing Rule decision table demonstrates the use of a decision
    table in a spreadsheet (XLS format) in calculating the retail cost of an
    insurance policy. The purpose of the set of rules provided is to calculate
    a base price, and an additional discount for a car driver applying for a
    specific policy. The drivers age, history and the policy type all
    contribute to what the basic premium is, and an additional chunk of rules
    deals with refining this with a subtractive percentage discount.</p><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Example Policy Pricing
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.PricingRuleDTExample
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> ExamplePolicyPricing.xls
<span class="bold"><strong>Objective:</strong></span> demonstrate spreadsheet based decision tables.    </pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6875"></a>10.1.7.1.&nbsp;Executing the example</h4></div></div></div><p>Open the PricingRuleDTExample.java and execute it as a Java
      application. It should produce the following console output:</p><pre class="programlisting">Cheapest possible
BASE PRICE IS: 120
DISCOUNT IS: 20     </pre><p>The code to the execute the example is very similar to the other
      examples. The rules are loaded, the facts inserted and a stateless
      session is used. What is different is how the rules are obtained:</p><pre class="programlisting">SpreadsheetCompiler compiler = new SpreadsheetCompiler();
String drl = compiler.compile(getSpreadsheetStream(), InputType.XLS);
</pre><p>Note the use of the SpreadsheetCompiler class. It is what takes
      the XLS (as a binary InputStream to the XLS file), and outputs ordinary
      DRL (which is then dealt with in the usual way). You can (if you like)
      also print out the DRL. If you use the BRMS, all this is of course taken
      care of for you.</p><p>There are 2 facts used in this example, Driver, and Policy. Both
      are used with their default values. The Driver is 30 years old, has had
      no prior claims and currently has a risk profile of LOW. The Policy
      being applied for is COMPREHENSIVE, and the policy has not yet been
      approved.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6890"></a>10.1.7.2.&nbsp;The decision table</h4></div></div></div><p>In this decision table, each row is a rule, and each column is a
      condition or an action.</p><div class="figure"><a name="d0e6895"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/DT_Config.png" alt="Decision table configuration"></div></div><p class="title"><b>Figure&nbsp;10.13.&nbsp;Decision table configuration</b></p></div><br class="figure-break"><p>Referring to the above, we have the RuleSet declaration, which
      provides the package name. There are also other optional items you can
      have here, such as Variables for global variables, and Imports for
      importing classes. In this case, the namespace of the rules is the same
      as the fact classes we are using, so we can omit it.</p><p>Moving further down, we can see the RuleTable declaration. The
      name after this (Pricing bracket) is used as the prefix for all the
      generated rules. Below that, we have CONDITION or ACTION - this
      indicates the purpose of the column (ie does it form part of the
      condition, or an action of a rule that will be generated).</p><p>You can see there is a Driver which is spanned across 3 cells,
      this means the template expressions below it apply to that fact. So we
      look at the drivers age range (which uses $1 and $2 with comma separated
      values), locationRiskProfile, and priorClaims in the respective columns.
      In the action columns, we are setting the policy base price, and then
      logging a message.</p><div class="figure"><a name="d0e6907"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/DT_Table1.png" alt="Base price calculation"></div></div><p class="title"><b>Figure&nbsp;10.14.&nbsp;Base price calculation</b></p></div><br class="figure-break"><p>Referring to the above, we can see there are broad category
      brackets (indicated by the comment in the left most column). As we know
      the details of our driver and their policy, we can tell (with a bit of
      thought) that they should match row number 18, as they have no prior
      accidents, and are 30 years old. This gives us a base price of
      120.</p><div class="figure"><a name="d0e6915"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/DT_Table2.png" alt="Discount calculation"></div></div><p class="title"><b>Figure&nbsp;10.15.&nbsp;Discount calculation</b></p></div><br class="figure-break"><p>Referring to the above, we are seeing if there is any discount we
      can give our driver. Based on the Age bracket, number of priot claims,
      and the policy type, a discount is provided. In our case, the drive is
      3, with no priors, and they are applying for COMPREHENSIVE, this means
      we can give a discount of 20%. Note that this is actually a separate
      table, but in the same worksheet. This different templates apply.</p><p>It is important to note that decision tables generate rules, this
      means they aren't simply top down logic, but more a means to capture
      data that generate rules (this is a subtle difference that confuses some
      people). The evaluation of the rules is not "top down" necessarily, all
      the normal indexing and mechanics of the rule engine still apply.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6925"></a>10.1.8.&nbsp;Shopping Example</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span>Shopping Example
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.ShoppingExample
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> Shopping.drl
<span class="bold"><strong>Objective:</strong></span> demonstrate truth maintenance, accumulate
</pre><p>The shopping example simulates a very simple shopping cart type
    application, where the idea is to track a users purchases in a stateful
    session, and apply discounts as appropriate.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6946"></a>10.1.8.1.&nbsp;Running the example</h4></div></div></div><p>The following is a listing of the interesting parts that are used
      to launch the example:</p><pre class="programlisting">Customer mark = new Customer( "mark",
                              0 );
session.insert( mark );
Product shoes = new Product( "shoes",
                             60 );
session.insert( shoes );
Product hat = new Product( "hat",
                           60 );
session.insert( hat );
session.insert( new Purchase( mark,
                              shoes ) );
FactHandle hatPurchaseHandle = session.insert( new Purchase( mark,
                                                             hat ) );
session.fireAllRules();
session.retract( hatPurchaseHandle );
System.out.println( "Customer mark has returned the hat" );
session.fireAllRules();      </pre><p>Refering the the above listing, we can see there is a Customer
      ("mark"), and there are 2 Products ("shoes" and "hat") which are
      available for Purchase. In this case, a Purchase combines a customer
      with a product (and a product has a price attribute).</p><p>Note that after we fireAllRules(), we then retract the purchase of
      a hat (but leave the purchase of shoes in). Running the example as a
      java application should see the following output:</p><pre class="programlisting">Customer mark just purchased hat
Customer mark just purchased shoes
Customer mark now has a shopping total of 120.0
Customer mark now has a discount of 10
Customer mark has returned the hat
Customer mark now has a discount of 0      </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6959"></a>10.1.8.2.&nbsp;Discounts and purchases</h4></div></div></div><p>We want to give discounts to customers who purchase stuff of
      enough value. This discount could also be removed should the customer
      decide not to purchase enough to fall within the threshold.</p><pre class="programlisting">rule "Purchase notification"
    salience 10

 when
  $c : Customer()
  $p : Purchase( customer == $c)	    
 then
     System.out.println( "Customer " + $c.name + " just purchased " + $p.product.name );
end 

rule "Discount removed notification"
 when
     $c : Customer()
  not Discount( customer == $c )
 then
  $c.discount = 0 ;
  System.out.println( "Customer " + $c.name + " now has a discount of " + $c.discount );
end

rule "Discount awarded notification"
 when
     $c : Customer()
     $d : Discount( customer == $c )
 then
  System.out.println( "Customer " + $c.name + " now has a discount of " + $d.amount );
end      </pre><p>The "Purchase notification" rule simply makes note of the purchase
      event for a given customer. The "Discount removed notification" rule
      removes the customer discount (by checking for the non existence of a
      discount for that customer). The "Discount awarded notification" simply
      makes not of the fact that the discount was applied.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6968"></a>10.1.8.3.&nbsp;Calculating the discount</h4></div></div></div><p>Calculating the discount is done with a single rule, using the
      higher order logic of "accumulate".</p><pre class="programlisting">rule "Apply 10% discount if total purcahses is over 100"
 no-loop true
 dialect "java"
    when
      $c : Customer()
      $i : Double(doubleValue  &gt; 100) from accumulate ( Purchase( customer == $c, $price : product.price ), 
                                                            sum( $price ) )
    then
      $c.setDiscount( 10 );
      insertLogical( new Discount($c, 10) );
      System.out.println( "Customer " + $c.getName() + " now has a shopping total of " + $i );
end      </pre><p>An interesting part of this rule is the "accumulate": this is
      saying to accumulate a total (sum) of the $price of a product
      (product.price) for all Purchase facts that belong to the customer ($c).
      The result of this is a Double. The rule then checks to see if this
      total is greater then 100. If it is, it applies the discount (of 10),
      and then inserts a logical fact of the Discount object.</p><p>The purpose of the logical insertion of the Discount, is to
      automatically retract the Discount object should the total of the
      purchases not add up to &gt; 100 (when the LHS is no longer satisified,
      restract the resulting logical assertions - this is what is meant by
      "truth maintenance"). The act of inserting the Discount, causes the
      "Discount awarded notification" rule to activate. However, should the
      discount fact be retracted, the "Discount removed notification" will
      activate, resulting in the customers discount being wiped out. In the
      example you can see this happen, as after the first fireAllRules(), a
      purchase is retracted, causing the total to fall below 100, which means
      the conditions that satisfied the "Apply 10% discount..." rule no longer
      apply, hence the logical fact of "Discount" is automatically
      retracted.</p></div></div><div class="section" lang="en"><div class="titlepage"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6980"></a>10.1.9.1.&nbsp;Pet Store Example</h4></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Pet Store 
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.PetStore
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> PetStore.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrate use of Agenda Groups, Global Variables and integration with a GUI (including callbacks from within the Rules)
</pre><p>The Pet Store example shows how to integrate Rules with a GUI (in
      this case a Swing based Desktop application). Within the rules file, it
      shows how to use agenda groups and auto-focus to control which of a set
      of rules is allowed to fire at any given time. It also shows mixing of
      Java and MVEL dialects within the rules, the use of accumulate functions
      and calling of Java functions from within the ruleset.</p><p>Like the rest of the the samples, all the Java Code is contained
      in one file. The PetStore.java contains the following principal classes
      (in addition to several minor classes to handle Swing Events)</p><p>
        </p><div class="itemizedlist"><ul type="disc"><li><p><span class="italic"> Petstore</span> - containing
            the main() method that we will look at shortly.</p></li><li><p><span class="italic">PetStoreUI</span> - responsible
            for creating and displaying the Swing based GUI. It contains
            several smaller classes , mainly for responding to various GUI
            events such as mouse and button clicks.</p></li><li><p><span class="italic">TabelModel</span> - for holding
            the table data. Think of it as a JavaBean that extends the Swing
            AbstractTableModel class.</p></li><li><p><span class="italic">CheckoutCallback</span> - Allows
            the GUI to interact with the Rules.</p></li><li><p><span class="italic">Ordershow </span> - the items
            that we wish to buy.</p></li><li><p><span class="italic">Purchase</span> - Details of the
            order and the products we are buying.</p></li><li><p><span class="italic">Product</span> - JavaBean
            holding details of the product available for purchase, and it's
            price.</p></li></ul></div><p>
      </p><p>Much of the Java code is either JavaBeans (simple enough to
      understand) or Swing based. We will touch on some Swing related points
      in the this tutorial , but a good place to get more Swing component
      information is <a class="ulink" href="???" target="_top"><code class="uri">http://java.sun.com/docs/books/tutorial/uiswing/</code>available
      at the Sun Swing website.<font color="red">&lt;citebiblioid&gt;&lt;/citebiblioid&gt;</font></a></p><p>There are two important Rules related pieces of Java code in
      <span class="italic">Petstore.java</span>.</p><p>
        </p><div class="example"><a name="d0e7056"></a><p class="title"><b>Example&nbsp;10.53.&nbsp;Creating the PetStore RuleBase - extract from PetStore.java
          main() method</b></p><div class="example-contents"><pre class="programlisting">PackageBuilder builder = new PackageBuilder();
builder.addPackageFromDrl( new InputStreamReader( 
PetStore.class.getResourceAsStream( "PetStore.drl" ) ) );
RuleBase ruleBase = RuleBaseFactory.newRuleBase();
ruleBase.addPackage( builder.getPackage() );

//RuleB
Vector stock = new Vector();
stock.add( new Product( "Gold Fish",5 ) );
stock.add( new Product( "Fish Tank", 25 ) );
stock.add( new Product( "Fish Food", 2 ) );

//The callback is responsible for populating working memory and
// fireing all rules
PetStoreUI ui = new PetStoreUI( stock, new CheckoutCallback( ruleBase ) );
ui.createAndShowGUI();
</pre></div></div><p><br class="example-break">
      </p><p>This code above loads the rules (drl) file from the classpath.
      Unlike other examples where the facts are asserted and fired straight
      away, this example defers this step to later. The way it does this is
      via the second last line where the PetStoreUI is created using a
      constructor the passes in the Vector called stock containing products ,
      and an instance of the CheckoutCallback class containing the RuleBase
      that we have just loaded.</p><p>The actual Javacode that fires the rules is within the <span class="italic">CheckoutCallBack.checkout()</span> method. This is
      triggered (eventually) when the 'Checkout' button is pressed by the
      user.</p><div class="example"><a name="d0e7069"></a><p class="title"><b>Example&nbsp;10.54.&nbsp;Firing the Rules - extract from the CheckOutCallBack.checkout()
        method</b></p><div class="example-contents"><pre class="programlisting">public String checkout(JFrame frame, List items) throws FactException {           
    Order order = new Order();

    //Iterate through list and add to cart
    for ( int i = 0; i &lt; items.size(); i++ ) {
        order.addItem( new Purchase( order, (Product) items.get( i ) ) );
    }

    //add the JFrame to the ApplicationData to allow for user interaction
    WorkingMemory workingMemory = ruleBase.newStatefulSession();
    workingMemory.setGlobal( "frame", frame );
    workingMemory.setGlobal( "textArea",  this.output );

    workingMemory.insert( new Product( "Gold Fish", 5 ) );
    workingMemory.insert( new Product( "Fish Tank", 25 ) );
    workingMemory.insert( new Product( "Fish Food",  2 ) );
    workingMemory.insert( new Product( "Fish Food Sample", 0 ) );            
           
    workingMemory.insert( order );
    workingMemory.fireAllRules();

    //returns the state of the cart
    return order.toString();
}
</pre></div></div><br class="example-break"><p>Two items get passed into this method; A handle to the JFrame
      Swing Component surrounding the output text frame (bottom of the GUI if
      / when you run the component). The second item is a list of order items;
      this comes from the TableModel the stores the information from the
      'Table' area at the top right section of the GUI.</p><p>The <span class="italic">for()</span> loop transforms the
      list of order items coming from the GUI into the Order JavaBean (also
      contained in the PetStore.java file). Note that it would be possible to
      refer to the Swing dataset directly within the rules, but it is better
      coding practice to do it this way (using Simple Java Objects). It means
      that we are not tied to Swing if we wanted to transform the sample into
      a Web application.</p><p>It is important to note that <span class="bold"><strong>all state in
      this example is stored in the Swing components, and that the rules are
      effectively stateless. </strong></span>Each time the 'Checkout' button is
      pressed, this code copies the contents of the Swing
      <span class="emphasis"><em>TableModel</em></span> into the Session / Working
      Memory.</p><p>Within this code, there are nine calls to the working memory. The
      first of these creates a new workingMemory (statefulSession) from the
      Rulebase - remember that we passed in this Rulebase when we created the
      CheckoutCallBack class in the <span class="italic">main()</span>
      method. The next two calls pass in two objects that we will hold as Gl
      obal variables in the rules - the Swing text area and Swing frame that
      we will use for writing messages later.</p><p>More inserts put information on products into the working memory,
      as well as the order list. The final call is the standard e <span class="italic">fireAllRules()</span>. Next, we look at what this
      method causes to happen within the Rules file.</p><p>
        </p><div class="example"><a name="d0e7101"></a><p class="title"><b>Example&nbsp;10.55.&nbsp;Package, Imports , Globals and Dialect - extract (1) from
          PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">package org.drools.examples

import org.drools.WorkingMemory
import org.drools.examples.PetStore.Order
import org.drools.examples.PetStore.Purchase
import org.drools.examples.PetStore.Product
import java.util.ArrayList
import javax.swing.JOptionPane;

import javax.swing.JFrame 
        
global JFrame frame 
global javax.swing.JTextArea textArea
 
dialect "mvel"
</pre></div></div><p><br class="example-break">
      </p><p>The first part of the <span class="italic">PetStore.drl</span> file contains the standard package
      and import statement to make various Java classes available to the
      rules. We've seen the dialect been defaulted to "mvel" before in other
      examples. What is new are the two globals <span class="emphasis"><em>frame and textArea.
      </em></span>These hold references to the Swing JFrame and Textarea
      components that were previous passed by the Java code calling the
      <span class="emphasis"><em>setGlobal() </em></span>method. Unlike normal variables in
      Rules , which expire as soon as the rule has fired, Global variables
      retain their value for the lifetime of the (Stateful in this case)
      Session.</p><p>The next extract (below) is from the <span class="bold"><strong>end</strong></span> of the PetStore.drl file. It contains two
      functions that are referenced by the rules that we will look at
      shortly.</p><p>
        </p><div class="example"><a name="d0e7125"></a><p class="title"><b>Example&nbsp;10.56.&nbsp;Java Functions in the Rules - extract (2) from
          PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">function void doCheckout(JFrame frame, WorkingMemory workingMemory) {
    Object[] options = {"Yes",
                        "No"};
                            
    int n = JOptionPane.showOptionDialog(frame,
                                         "Would you like to checkout?",
                                         "",
                                         JOptionPane.YES_NO_OPTION,
                                         JOptionPane.QUESTION_MESSAGE,
                                         null,
                                         options,
                                         options[0]);

    if (n == 0) {
        workingMemory.setFocus( "checkout" );
    }   
}

function boolean requireTank(JFrame frame, WorkingMemory workingMemory, Order order, Product fishTank, int total) {
    Object[] options = {"Yes",
                        "No"};
                            
    int n = JOptionPane.showOptionDialog(frame,
                                         "Would you like to buy a tank for your " + total + " fish?",
                                         "Purchase Suggestion",
                                         JOptionPane.YES_NO_OPTION,
                                         JOptionPane.QUESTION_MESSAGE,
                                         null,
                                         options,
                                         options[0]);
                                             
    System.out.print( "SUGGESTION: Would you like to buy a tank for your "
                      + total + " fish? - " );

    if (n == 0) {
        Purchase purchase = new Purchase( order, fishTank );
        workingMemory.insert( purchase );
        order.addItem( purchase );
        System.out.println( "Yes" );
    } else {
        System.out.println( "No" );
    }      
    return true;
}
</pre></div></div><p><br class="example-break">
      </p><p>Having these functions in the rules file makes the PetStore sample
      more compact - in real life you probably have the functions in a file of
      their own (within the same rules package), or as a static method on a
      standard Java class (and import them using the <span class="bold"><strong>import function my.package.Foo.hello
      </strong></span>syntax).</p><p>The above functions are</p><div class="itemizedlist"><ul type="disc"><li><p><span class="italic">doCheckout()</span> - Displays a
            dialog asking the user if they wish to checkout. If they do, focus
            is set to the <span class="italic">checkOut</span>
            agenda-group, allowing rules in that group to (potentially)
            fire.</p></li><li><p><span class="italic">requireTank()</span> - Displays
            a dialog asking the user if they wish to buy a tank. If so, a new
            FishTank <span class="italic">Product</span> added to the
            orderlist in working memory.</p></li></ul></div><p>We'll see later the rules that call these functions.The
      next set of examples are from the PetStore rules themselves. The first
      extract is the one that happens to fire first (partly because it has the
      <span class="italic">auto-focus</span> attibute set to
      true).</p><div class="example"><a name="d0e7160"></a><p class="title"><b>Example&nbsp;10.57.&nbsp;Putting each (individual) item into working memory - extract
          (3) from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">// insert each item in the shopping cart into the Working Memory 
rule "Explode Cart"
    agenda-group "init"
    auto-focus true    
    salience 10
    dialect "java"
when
    $order : Order( grossTotal == -1 )
    $item : Purchase() from $order.items
then
   insert( $item );
   drools.setFocus( "show items" );
   drools.setFocus( "evaluate" );
end

</pre></div></div><p><br class="example-break"></p><p>This rule matches against all orders that do not yet have an
      Order.grossTotal calculated . It loops for each purchase item in that
      order. Some of the <span class="italic">Explode Cart</span> Rule
      should be familiar ; the rule name, the salience (suggesting of the
      order that the rules should be fired in) and the dialect set to
      <span class="italic">java</span>. There are three new
      items:</p><p>
        </p><div class="itemizedlist"><ul type="disc"><li><p class="bold"><span class="bold"><strong>agenda-group "init"
            </strong></span>- the name of the agenda group. In this case, there is
            only one rule in the group. However, nothing in Java code / nor a
            rule sets the focus to this group , so it relies on the next
            attibute for it's chance to fire.</p></li><li><p><span class="bold"><strong>auto-focus true - </strong></span>This is
            the only rule in the sample, so when <span class="italic">fireAllRules()</span> is called from within the
            Java code, this rule is the first to get a chance to fire.</p></li><li><p><span class="bold"><strong>drools.setFocus() </strong></span>This sets
            the focus to the <span class="italic">show items </span>and
            <span class="italic">evaluate</span> agenda groups in turn
            , giving their rules a chance to fire. In practice , we loop
            through all items on the order, inserting them into memory, then
            firing the other rules after each insert.</p></li></ul></div><p>
      </p><p>The next two listings shows the rules within the <span class="italic">show items </span>and <span class="italic">evaluate</span> agenda groups. We look at them in the
      order that they are called.</p><div class="example"><a name="d0e7209"></a><p class="title"><b>Example&nbsp;10.58.&nbsp;Show Items in the GUI extract (4) from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">rule "Show Items"
    agenda-group "show items"
    dialect "mvel"
when
    $order : Order( )
    $p : Purchase( order == $order )
then
   textArea.append( $p.product + "\n");
end
</pre></div></div><p><br class="example-break"></p><p>The <span class="italic">show items</span> agenda-group has
      only one rule, also called <span class="italic">Show Items</span>
      (note the difference in case). For each purchase on the order currently
      in the working memory (session) it logs details to the text area (at the
      bottom of the GUI). The <span class="italic">textArea</span>
      variable used to do this is one of the Global Variables we looked at
      earlier.</p><p>The <span class="italic">evaluate</span> Agenda group also
      gains focus from the <span class="italic">explode cart
      </span>rule above. This Agenda group has two rules (below) <span class="italic">Free Fish Food Sample </span> and <span class="italic">Suggest Tank</span>.</p><p>
        </p><div class="example"><a name="d0e7241"></a><p class="title"><b>Example&nbsp;10.59.&nbsp;Evaluate Agenda Group extract (5) from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">// Free Fish Food sample when we buy a Gold Fish if we haven't already  bought 
// Fish Food and dont already have a Fish Food Sample
rule "Free Fish Food Sample"
    agenda-group "evaluate"
    dialect "mvel"
when
    $order : Order()
    not ( $p : Product( name == "Fish Food") &amp;&amp; Purchase( product == $p ) )
    not ( $p : Product( name == "Fish Food Sample") &amp;&amp; Purchase( product == $p ) )
    exists ( $p : Product( name == "Gold Fish") &amp;&amp; Purchase( product == $p ) )
    $fishFoodSample : Product( name == "Fish Food Sample" );
then
    System.out.println( "Adding free Fish Food Sample to cart" );
    purchase = new Purchase($order, $fishFoodSample);
    insert( purchase );
    $order.addItem( purchase ); 
end

// Suggest a tank if we have bought more than 5 gold fish and dont already have one
rule "Suggest Tank"
    agenda-group "evaluate"
    dialect "java"
when
    $order : Order()
    not ( $p : Product( name == "Fish Tank") &amp;&amp; Purchase( product == $p ) )
    ArrayList( $total : size &gt; 5 ) from collect( Purchase( product.name == "Gold Fish" ) )
    $fishTank : Product( name == "Fish Tank" )
then
    requireTank(frame, drools.getWorkingMemory(), $order, $fishTank, $total); 
end
</pre></div></div><p><br class="example-break">
      </p><p>The <span class="italic">Free Fish Food Sample</span> rule
      will only fire if</p><p>
        </p><div class="itemizedlist"><ul type="disc"><li><p>We <span class="italic">don't </span>already have any
            fish food.</p></li><li><p>We <span class="italic">don't</span> already have a
            free fish food sample.</p></li><li><p>We <span class="italic">do</span> have a Gold Fish in
            our order.</p></li></ul></div><p>
      </p><p>If the rule does fire, it creates a new product (Fish Food
      Sample), and adds it to the Order in working memory.</p><p>The <span class="italic">Suggest Tank</span> rule will only
      fire if</p><p>
        </p><div class="itemizedlist"><ul type="disc"><li><p>We <span class="italic">don't </span>already have a
            Fish Tank in our order</p></li><li><p>If we <span class="italic">can</span> find more than
            5 Gold Fish Products in our order.</p></li></ul></div><p>
      </p><p>If the rule does fire, it calls the <span class="italic">requireTank</span>() function that we looked at
      earlier (showing a Dialog to the user, and adding a Tank to the order /
      working memory if confirmed). When calling the <span class="italic">requireTank</span>() function the rule passes the
      global <span class="italic">frame</span> variable so that the
      function has a handle to the Swing GUI.</p><p>The next rule we look at is <span class="italic">do
      checkout.</span></p><div class="example"><a name="d0e7312"></a><p class="title"><b>Example&nbsp;10.60.&nbsp;Doing the Checkout - extract (6) from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">rule "do checkout"
    dialect "java"
    when
    then
        doCheckout(frame, drools.getWorkingMemory());
end</pre></div></div><p><br class="example-break"></p><p>The <span class="italic">do checkout</span> rule has
      <span class="bold"><strong>no agenda-group set and no auto-focus
      attribute</strong></span>. As such, is is deemed part of the default (MAIN)
      agenda-group - the same as the other non PetStore examples where agenda
      groups are not used. This group gets focus by default when all the
      rules/agenda-groups that explicity had focus set to them have run their
      course.</p><p>There is no LHS to the rule, so the RHS will always call the
      <span class="italic">doCheckout</span>() function. When calling
      the <span class="italic">doCheckout</span>() function the rule
      passes the global <span class="italic">frame</span> variable so
      the function has a handle to the Swing GUI. As we saw earlier, the
      <span class="italic">doCheckout</span>() function shows a
      confirmation dialog to the user. If confirmed, the function sets the
      focus to the <span class="italic">checkout</span> agenda-group,
      allowing the next lot of rules to fire.</p><p>
        </p><div class="example"><a name="d0e7344"></a><p class="title"><b>Example&nbsp;10.61.&nbsp;Checkout Rules- extract (7) from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">rule "Gross Total"
    agenda-group "checkout"
    dialect "mvel"
when
   $order : Order( grossTotal == -1)
   Number( total : doubleValue ) from accumulate( Purchase( $price : product.price ),
                 sum( $price ) )
then
    modify( $order ) { grossTotal = total };
    textArea.append( "\ngross total=" + total + "\n" );
end

rule "Apply 5% Discount"
    agenda-group "checkout"
dialect "mvel"
when
   $order : Order( grossTotal &gt;= 10 &amp;&amp; &lt; 20 )
then
   $order.discountedTotal = $order.grossTotal * 0.95;
   textArea.append( "discountedTotal total=" + $order.discountedTotal + "\n" );
end


rule "Apply 10% Discount"
    agenda-group "checkout"
dialect "mvel"
when
   $order : Order( grossTotal &gt;= 20 )
then
   $order.discountedTotal = $order.grossTotal * 0.90;
   textArea.append( "discountedTotal total=" + $order.discountedTotal + "\n" );
end
</pre></div></div><p><br class="example-break">
      </p><p>There are three rules in the <span class="italic">checkout</span> agenda-group</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>Gross Total </strong></span> - if we
            haven't already calculated the gross total, accumulates the
            product prices into a total, puts this total into working memory,
            and displays it via the Swing TextArea (using the <span class="italic">textArea </span>global variable yet
            again).</p></li><li><p><span class="bold"><strong>Apply 5% Discount</strong></span> - if our
            gross total is between 10 and 20, then calculate the discounted
            total and add it to working memory / display in the text
            area.</p></li><li><p><span class="bold"><strong>Apply 10% Discount</strong></span> - if our
            gross total is equal to or greater than 20, calculate the
            discounted total and add it to working memory / display in the
            text area.</p></li></ul></div><p>Now we've run through what happens in the code, lets
      have a look at what happens when we run the code for real. The <span class="italic">PetStore.java </span>example contains a <span class="italic">main()</span> method, so it can be run as a standard
      Java application (either from the command line or via the IDE). This
      assumes you have your classpath set correctly (see the start of the
      examples section for more information).s.</p><p>The first screen that we see is the Pet Store Demo. It has a List
      of available products (top left) , an empty list of selected products
      (top right), checkout and reset buttons (middle) and an empty system
      messages area (bottom).</p><div class="figure"><a name="d0e7385"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/1-PetStore-Start-Screen.png" alt="Figure 1 - PetStore Demo just after Launch"></div></div><p class="title"><b>Figure&nbsp;10.16.&nbsp;Figure 1 - PetStore Demo just after Launch</b></p></div><p><br class="figure-break">To get to this point, the following things have
      happened:</p><div class="orderedlist"><ol type="1"><li><p>The <span class="italic">main()</span> method has run
            and loaded the RuleBase <span class="bold"><strong>but not yet fired
            the rules</strong></span>. This is the only rules related code to run
            so far.</p></li><li><p>A new <span class="italic">PetStoreUI</span> class is
            created and given a handle to the RuleBase (for later use).</p></li><li><p>Various Swing Components do their stuff, and the above
            screen is shown and <span class="bold"><strong>waits for user
            input</strong></span>.</p></li></ol></div><p>Clicking on various products from the list might give
      you a screen similar to the one below.</p><div class="figure"><a name="d0e7417"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/2-stock-added-to-order-list.png" alt="Figure 2 - PetStore Demo with Products Selected"></div></div><p class="title"><b>Figure&nbsp;10.17.&nbsp;Figure 2 - PetStore Demo with Products Selected</b></p></div><p><br class="figure-break">Note that <span class="bold"><strong>no rules code has been fired
      here</strong></span>. This is only swing code, listening for the mouse click
      event, and added the clicked product to the
      <span class="emphasis"><em>TableModel</em></span> object for display in the top right hand
      section (as an aside , this is a classic use of the Model View
      Controller - MVC - design pattern).</p><p>It is only when we press the <span class="bold"><strong>Checkout</strong></span> that we fire our business rules, in
      roughly the same order that we walked through the code earlier.</p><p>
        </p><div class="orderedlist"><ol type="1"><li><p>The <span class="italic">CheckOutCallBack.checkout()</span> method is
            called (eventually) by the Swing class waiting for the click on
            the checkout button. This inserts the data from the
            <span class="emphasis"><em>TableModel</em></span> object (top right hand side of the
            GUI), and handles from the GUI into the session / working memory.
            It then fires the rules.</p></li><li><p>The <span class="italic">Explode Cart</span> rule is
            the first to fire, given that has <span class="italic">auto-focus </span>set to true. It loops through
            all the products in the cart, makes sure the products are in the
            working memory, then gives the <span class="italic">Show
            Items</span> and <span class="italic">Evaluation</span>
            agenda groups a chance to fire. The rules in these groups, add the
            contents of the cart to the text area (bottom), decide whether or
            not to give us free fish food and whether to ask if we want to buy
            a fish tank (Figure 3 below).</p></li></ol></div><p>

        </p><div class="figure"><a name="d0e7463"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/3-purchase-suggestion.png" alt="Figure 3 - Do we want to buy a fish tank?"></div></div><p class="title"><b>Figure&nbsp;10.18.&nbsp;Figure 3 - Do we want to buy a fish tank?</b></p></div><p><br class="figure-break">

        </p><div class="orderedlist"><ol type="1"><li><p>The <span class="italic">Do Checkout</span> rule is
            the next to fire as it (a) No other agenda group currently has
            focus and (b) it is part of the default (MAIN) agenda group. It
            always calls the<span class="italic"> doCheckout() function
            </span>which displays a 'Would you like to Checkout?' Dialog
            Box.</p></li><li><p>The <span class="italic">doCheckout() function</span>
            sets the focus to the <span class="italic">checkout
            </span>agenda-group, giving the rules in that group the option
            to fire.</p></li><li><p>The rules in the the <span class="italic">checkout</span> agenda-group, display the
            contents of the cart and apply the appropriate discount.</p></li><li><p><span class="bold"><strong>Swing then waits for user
            input</strong></span> to either checkout more products (and to cause
            the rules to fire again) or to close the GUI - Figure 4
            below.</p></li></ol></div><p>
      </p><p>
        </p><div class="figure"><a name="d0e7503"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/4-Petstore-final-screen.png" alt="Figure 4 - Petstore Demo after all rules have fired."></div></div><p class="title"><b>Figure&nbsp;10.19.&nbsp;Figure 4 - Petstore Demo after all rules have fired.</b></p></div><p><br class="figure-break">
      </p><p>Should we choose, we could add more System.out calls to
      demonstrate this flow of events. The current output of the console fo
      the above sample is as per the listing below.</p><p>
        </p><div class="example"><a name="d0e7514"></a><p class="title"><b>Example&nbsp;10.62.&nbsp;Console (System.out) from running the PetStore GUI</b></p><div class="example-contents"><pre class="programlisting">Adding free Fish Food Sample to cart 
SUGGESTION: Would you like to buy a tank for your 6 fish? - Yes</pre></div></div><p><br class="example-break">
      </p><p>Todo : Add Audit and Agenda Views for this sample.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7522"></a>10.1.10.&nbsp;Honest Politician Example</h3></div></div></div><p>The honest politician example demonstrates truth maintenance with
    logical assertions, the basic premise is that an object can only exist
    while a statement is true. A rule's consequence can logical insert an
    object with the insertLogical method, this means the object will only
    remain in the working memory as long as the rule that logically inserted
    it remains true, when the rule is no longer true the object is
    automatically retracted.</p><p>In this example there is Politician class with a name and a boolean
    value for honest state, four politicians with honest state set to true are
    inserted.</p><div class="example"><a name="d0e7530"></a><p class="title"><b>Example&nbsp;10.63.&nbsp;Politician Class</b></p><div class="example-contents"><pre class="programlisting">public class Politician {
    private String name;
    private boolean honest;
    ...
}</pre></div></div><p><br class="example-break"></p><div class="example"><a name="d0e7535"></a><p class="title"><b>Example&nbsp;10.64.&nbsp;Honest Politician Example Execution</b></p><div class="example-contents"><pre class="programlisting">Politician blair  = new Politician("blair", true);
Politician bush  = new Politician("bush", true);
Politician chirac  = new Politician("chirac", true);
Politician schroder   = new Politician("schroder", true);
        
session.insert( blair );
session.insert( bush );
session.insert( chirac );
session.insert( schroder );

session.fireAllRules();</pre></div></div><p><br class="example-break">The console out shows that while there is atleast one honest
    polician democracy lives, however as each politician is in turn corrupted
    by an evil corporation, when all politicians are dishonest democracy is
    dead.</p><div class="example"><a name="d0e7541"></a><p class="title"><b>Example&nbsp;10.65.&nbsp;Honest Politician Example Console Output</b></p><div class="example-contents"><pre class="programlisting">Hurrah!!! Democracy Lives
I'm an evil corporation and I have corrupted schroder
I'm an evil corporation and I have corrupted chirac
I'm an evil corporation and I have corrupted bush
I'm an evil corporation and I have corrupted blair
We are all Doomed!!! Democracy is Dead
</pre></div></div><p><br class="example-break">As soon as there is one ore more honest politcians in the
    working memory a new Hope object is logically asserted, this object will
    only exist while there is atleast one or more honest politicians, the
    moment all politicians are dishonest then the Hope object will be
    automatically retracted. This rule is given a salience of 10 to make sure
    it fires before any other rules, as at this stage the "Hope is Dead" rule
    is actually true.</p><div class="example"><a name="d0e7547"></a><p class="title"><b>Example&nbsp;10.66.&nbsp;Honest Politician Example : Rule "We have an honest
      politician"</b></p><div class="example-contents"><pre class="programlisting">rule "We have an honest Politician"
    salience 10
    when
        exists( Politician( honest == true ) )
    then
        insertLogical( new Hope() );
end</pre></div></div><br class="example-break"><p>As soon as a Hope object exists the "Hope Lives" rule matches, and
    fires, it has a salience of 10 so that it takes priority over "Corrupt the
    Honest".</p><div class="example"><a name="d0e7554"></a><p class="title"><b>Example&nbsp;10.67.&nbsp;Honest Politician Example : Rule "Hope Lives"</b></p><div class="example-contents"><pre class="programlisting">rule "Hope Lives"
    salience 10
    when
        exists( Hope() )
    then
        System.out.println("Hurrah!!! Democracy Lives");
end</pre></div></div><br class="example-break"><p>Now that hope exists and we have, at the start, four honest
    politicians we have 4 activations for this rule all in conflict. This rule
    iterates over those rules firing each one in turn, corrupting each
    politician so that they are no longer honest. When all four politicians
    have been corrupted we have no politicians with the property "honest ==
    true" thus the rule "We hvae an honest Politician" is no longer true and
    the object it logical inserts "new Hope()" is automatically
    retracted.</p><div class="example"><a name="d0e7561"></a><p class="title"><b>Example&nbsp;10.68.&nbsp;Honest Politician Example : Rule "Corrupt the Honest"</b></p><div class="example-contents"><pre class="programlisting">rule "Corrupt the Honest"
    when
        politician : Politician( honest == true )   
        exists( Hope() )
    then
        System.out.println( "I'm an evil corporation and I have corrupted " + politician.getName() );
        modify ( politician ) { honest = false };
end</pre></div></div><br class="example-break"><p>With Hope being automatically retracted, via the truth maintenance
    system, then Hope no longer exists in the system and this rule will match
    and fire.</p><div class="example"><a name="d0e7568"></a><p class="title"><b>Example&nbsp;10.69.&nbsp;Honest Politician Example : Rule "Hope is Dead"</b></p><div class="example-contents"><pre class="programlisting">rule "Hope is Dead"
    when
        not( Hope() )
    then
        System.out.println( "We are all Doomed!!! Democracy is Dead" );
end</pre></div></div><br class="example-break"><p>lets take a look the audit trail for this application:</p><div class="figure"><a name="d0e7575"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/honest_politician_audit.png" alt="Honest Politician Example Audit View"></div></div><p class="title"><b>Figure&nbsp;10.20.&nbsp;Honest Politician Example Audit View</b></p></div><br class="figure-break"><p>The moment we insert the first politician we have two activations,
    the "We have an honest Politician" is activated only once for the first
    inserted politician because it uses an existential 'exists' conditional
    element which only matches. the rule "Hope is Dead" is also activated at
    this stage, because as of yet we have not inserted the Hope object. "We
    have an honest Politician" fires first, as it has a higher salience over
    "Hope is Dead" which inserts the Hope object, that action is highlighted
    green above. The insertion of the Hope object activates "Hope Lives" and
    de-activates "Hope is Dead", it also actives "Corrupt the Honest" for each
    inserted honested politician. "Rule Hope Lives" executes printing
    "Hurrah!!! Democracy Lives". Then for each politician the rule "Corrupt
    the Honest" fires printing "I'm an evil corporation and I have corrupted
    X", where X is the name of the politician, and modifies the politicians
    honest value to false. When the last honest polician is corrupted Hope is
    automatically retracted, by the truth maintenance system, as shown by the
    blue highlighted area. The green highlighted area shows the origin of the
    currently selected blue highlighted area. Once Hope is retracted "Hope is
    dead" activates and fires printing "We are all Doomed!!! Democracy is
    Dead".</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7583"></a>10.1.11.&nbsp;Sudoku Example</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Sudoku
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.sudoku.Main
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> sudokuSolver.drl, sudokuValidator.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates the solving of logic problems, and complex pattern matching.e
</pre><p>This example demonstrates how Drools can be used to find a solution
    in a large potential solution space based on a number of constraints. We
    use the popular puzzle of Sudoku. This example also shows how Drools can
    be integrated into a graphical interface and how callbacks can be used to
    interact with a running Drools rules engine in order to update the
    graphical interface based on changes in the working memory at
    runtime.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7604"></a>10.1.11.1.&nbsp;Sudoku Overview</h4></div></div></div><p>Sudoku is a logic-based number placement puzzle. The objective is
      to fill a 9x9 grid so that each column, each row, and each of the nine
      3x3 zones contains the digits from 1 to 9 once and only once.</p><p>The puzzle setter provides a partially completed grid and the
      puzzle solver's task is to complete the grid with these
      constraints.</p><p>The general strategy to solve the problem is to ensure that when
      you insert a new number it should be unique in that particular
      region(blocks) and also in that particular row and column.</p><p>See </p><pre class="programlisting">URL: http://en.wikipedia.org/wiki/Sudoku</pre><p>
      for a more detailed description.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7618"></a>10.1.11.2.&nbsp;Running the Example</h4></div></div></div><p>Download and install drools-examples as described above and then
      execute java org.drools.examples.sudoku.Main (this example requires Java
      5).</p><p>A window will be displayed with a relatively simple partially
      filled grid. </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/sudoku1.png"></div></div><p>Click on the Solve button and the Drools-based engine will fill
      out the remaining values. The console will display detailed information
      of the rules which are executing to solve the puzzle in a human readable
      form.</p><p><code class="computeroutput">Rule #3 determined the value at (4,1) could not be
      4 as this value already exists in the same column at (8,1) Rule #3
      determined the value at (5,5) could not be 2 as this value already
      exists in the same row at (5,6) Rule #7 determined (3,5) is 2 as this is
      the only possible cell in the column that can have this value Rule #1
      cleared the other PossibleCellValues for (3,5) as a ResolvedCellValue of
      2 exists for this cell. Rule #1 cleared the other PossibleCellValues for
      (3,5) as a ResolvedCellValue of 2 exists for this cell. ... Rule #3
      determined the value at (1,1) could not be 1 as this value already
      exists in the same zone at (2,1) Rule #6 determined (1,7) is 1 as this
      is the only possible cell in the row that can have this value Rule #1
      cleared the other PossibleCellValues for (1,7) as a ResolvedCellValue of
      1 exists for this cell. Rule #6 determined (1,1) is 8 as this is the
      only possible cell in the row that can have this value
      </code></p><p>Once all of the activated rules for the solving logic have
      executed, the engine executes a second rule base to check that the
      solution is complete and valid. In this case it is, and the "Solve"
      button is disabled and displays the text "Solved (1052ms)". </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/sudoku2.png"></div></div><p>The example comes with a number of grids which can be loaded and
      solved. Click on File-&gt;Samples-&gt;Medium to load a more challenging
      grid. Note that the solve button is enabled when the new grid is loaded.
      </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/sudoku3.png"></div></div><p>Click on the "Solve" button again to solve this new grid.
      </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/sudoku4.png"></div></div><p>Now, let us load a Sudoku grid that is deliberately invalid. Click
      on File-&gt;Samples-&gt;!DELIBERATELY BROKEN!. Note that this grid
      starts with some issues, for example the value 5 appears twice in the
      first row. </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/sudoku5.png"></div></div><p>Nevertheless, click on the "Solve" button to apply the solving
      rules to this invalid Grid. Note that the "Solve" button is relabelled
      to indicate that the resulting solution is invalid. </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/sudoku6.png"></div></div><p>In addition, the validation rule set outputs all of the issues
      which are discovered to the console. </p><pre class="programlisting">
There are two cells on the same column with the same value at (6,0) and (4,0)
There are two cells on the same column with the same value at (4,0) and (6,0)
There are two cells on the same row with the same value at (2,4) and (2,2)
There are two cells on the same row with the same value at (2,2) and (2,4)
There are two cells on the same row with the same value at (6,3) and (6,8)
There are two cells on the same row with the same value at (6,8) and (6,3)
There are two cells on the same column with the same value at (7,4) and (0,4)
There are two cells on the same column with the same value at (0,4) and (7,4)
There are two cells on the same row with the same value at (0,8) and (0,0)
There are two cells on the same row with the same value at (0,0) and (0,8)
There are two cells on the same column with the same value at (1,2) and (3,2)
There are two cells on the same column with the same value at (3,2) and (1,2)
There are two cells in the same zone with the same value at (6,3) and (7,3)
There are two cells in the same zone with the same value at (7,3) and (6,3)
There are two cells on the same column with the same value at (7,3) and (6,3)
There are two cells on the same column with the same value at (6,3) and (7,3)   
      </pre><p>We will look at the solving rule set later in this section, but
      for the moment we should note that some theoretically solvable solutions
      can not be solved by the engine as it stands. Click on
      File-&gt;Samples-&gt;Hard 3 to load a sparsely populated Grid.
      </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/sudoku7.png"></div></div><p>Now click on the "Solve" button and note that the current rules
      are unable to complete the grid, even though (if you are a Sudoku
      afficiando) you may be able to see a way forward with the solution.
      </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/sudoku8.png"></div></div><p>At the present time, the solving functionality has been achieved
      by the use of ten rules. This rule set could be extended to enable the
      engine to tackle more complex logic for filling grids such as
      this.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7698"></a>10.1.11.3.&nbsp;Java Source and Rules Overview</h4></div></div></div><p>The Java source code can be found in the
      /src/main/java/org/drools/examples/sudoku directory, with the two DRL
      files defining the rules located in the
      /src/main/rules/org/drools/examples/sudoku directory.</p><p>org.drools.examples.sudoku.swing contains a set of classes which
      implement a framework for Sudoku puzzles. Note that this package does
      not have any dependencies on the Drools libraries. SudokuGridModel
      defines an interface which can be implemented to store a Sudoku puzzle
      as a 9x9 grid of Integer values, some of which may be null, indicating
      that the value for the cell has not yet been resolved. SudokuGridView is
      a Swing component which can visualise any implementation of
      SudokuGridModel. SudokuGridEvent and SudokuGridListener are used to
      communicate state changes between the model and the view, events are
      fired when a cell's value is resolved or changed. If you are familiar
      with the model-view-controller patterns in other Swing components such
      as JTable then this pattern should be familiar. SudokuGridSamples
      provides a number of partially filled Sudoku puzzles for demo
      purposes.</p><p>org.drools.examples.sudoku.rules contains an implementation of
      SudokuGridModel which is based on Drools. Two POJOs are used, both of
      which extend AbstractCellValue and represent a value for a specific cell
      in the grid, including the row and column location of the cell, an index
      of the 3x3 zone the cell is contained in and the value of the cell.
      PossibleCellValue indicates that we do not currently know for sure what
      the value in a cell is. There can be 2-9 PossibleCellValues for a given
      cell. ResolvedCellValue indicates that we have determined what the value
      for a cell must be. There can only be 1 ResolvedCellValue for a given
      cell. DroolsSudokuGridModel implements SudokuGridModel and is
      responsible for converting an initial two dimensional array of partially
      specified cells into a set of CellValue POJOs, creating a working memory
      based on solverSudoku.drl and inserting the CellValue POJOs into the
      working memory. When the solve() method is called it calls
      fireAllRules() on this working memory to try to solve the puzzle.
      DroolsSudokuGridModel attaches a WorkingMemoryListener to the working
      memory, which allows it to be called back on insert() and retract()
      events as the puzzle is solved. When a new ResolvedCellValue is inserted
      into the working memory, this call back allows the implementation to
      fire a SudokuGridEvent to its SudokuGridListeners which can then update
      themselves in realtime. Once all the rules fired by the solver working
      memory have executed, DroolsSudokuGridModel runs a second set of rules,
      based on validatorSudoku.drl which works with the same set of POJOs to
      determine if the resulting grid is a valid and full solution.</p><p>org.drools.examples.sudoku.Main implements a Java application
      which hooks the components desribed above together.</p><p>org.drools.examples.sudoku contains two DRL files.
      solverSudoku.drl defines the rules which attempt to solve a Sudoku
      puzzle and validator.drl defines the rules which determin whether the
      current state of the working memory represents a valid solution. Both
      use PossibleCellValue and ResolvedCellValue POJOs as their facts and
      both output information to the console as their rules fire. In a
      real-world situation we would insert() logging information and use the
      WorkingMemoryListener to display this information to a user rather than
      use the console in this fashion.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7711"></a>10.1.11.4.&nbsp;Sudoku Validator Rules (validatorSudoku.drl)</h4></div></div></div><p>We start with the validator rules as this rule set is shorter and
      simpler than the solver rule set.</p><p>The first rule simply checks that no PossibleCellValue objects
      remain in the working memory. Once the puzzle is solved, only
      ResolvedCellValue objects should be present, one for each cell.</p><p>The other three rules each match all of the ResolvedCellValue
      objects and store them in thenew_remote_sitetes instance variable
      $resolved. They then look respectively for ResolvedCellValues that
      contain the same value and are located, respectively, in the same row,
      column or 3x3 zone. If these rules are fired they add a message to a
      global List of Strings describing the reason the solution is invalid.
      DroolsSudokoGridModel injects this List before it runs the rule set and
      checks whether it is empty or not having called fireAllRules(). If it is
      not empty then it prints all the Strings in the list and sets a flag to
      indicate that the Grid is not solved.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7720"></a>10.1.11.5.&nbsp;Sudoku Solving Rules (solverSudoku.drl)</h4></div></div></div><p>Now let us look at the more complex rule set used to solve Sudoku
      puzzles.</p><p>Rule #1 is basically a "book-keeping" rule. Several of the other
      rules insert() ResolvedCellValues into the working memory at specific
      rows and columns once they have determined that a given cell must have a
      certain value. At this point, it is important to clear the working
      memory of any inserted PossibleCellValues at the same row and column
      with invalid values. This rule is therefore given a higher salience than
      the remaining rules to ensure that as soon as the LHS is true,
      activations for the rule move to the top of the agenda and are fired. In
      turn this prevents the spurious firing of other rules due to the
      combination of a ResolvedCellValue and one or more PossibleCellValues
      being present in the same cell. This rule also calls update() on the
      ResolvedCellValue, even though its value has not in fact been modified
      to ensure that Drools fires an event to any WorkingMemoryListeners
      attached to the working memory so that they can update themselves - in
      this case so that the GUI can display the new state of the grid.</p><p>Rule #2 identifies cells in the grid which have only one possible
      value. The first line of the when caluse matches all of the
      PossibleCellValue objects in the working memory. The second line
      demonstrates a use of the not keyword. This rule will only fire if no
      other PossibleCellValue objects exist in the working memory at the same
      row and column but with a different value. When the rule fires, the
      single PossibleCellValue at the row and column is retracted from the
      working memory and is replaced by a new ResolvedCellValue at the same
      row and column with the same value.</p><p>Rule #3 removes PossibleCellValues with a given value from a row
      when they have the same value as a ResolvedCellValue. In other words,
      when a cell is filled out with a resolved value, we need to remove the
      possibility of any other cell on the same row having this value. The
      first line of the when clause matches all ResolvedCellValue objects in
      the working memory. The second line matches PossibleCellValues which
      have both the same row and the same value as these ResolvedCellValue
      objects. If any are found, the rule activates and, when fired retracts
      the PossibleCellValue which can no longer be a solution for that
      cell.</p><p>Rules #4 and #5 act in the same way as Rule #3 but check for
      redundant PossibleCellValues in a given column and a given zone of the
      grid as a ResolvedCellValue respectively.</p><p>Rule #6 checks for the scenario where a possible cell value only
      appears once in a given row. The first line of the LHS matches against
      all PossibleCellValues in the working memory, storing the result in a
      number of local variables. The second line checks that no other
      PossibleCellValues with the same value exist on this row. The third to
      fifth lines check that there is not a ResolvedCellValue with the same
      value in the same zone, row or column so that this rule does not fire
      prematurely. Interestingly we could remove lines 3-5 and give rules
      #3,#4 and #5 a higher salience to make sure they always fired before
      rules #6,#7 and #8. When the rule fires, we know that $possible must
      represent the value for the cell so, as in Rule #2 we retract $possible
      and replace it with the equivalent, new ResolvedCellValue.</p><p>Rules #7 and #8 act in the same way as Rule #2 but check for
      single PossibleCellValues in a given column and a given zone of the grid
      respectively.</p><p>Rule #9 represents the most complex currently implemented rule.
      This rule implements the logic that, if we know that a pair of given
      values can only occur in two cells on a specific row, (for example we
      have determined the values of 4 and 6 can only appear in the first row
      in cells 0,3 and 0,5) and this pair of cells can not hold other values
      then, although we do not know which of the pair contains a four and
      which contains a six we know that the 4 and the 6 must be in these two
      cells and hence can remove the possibility of them occuring anywhere
      else in the same row (phew!). TODO: more detail here and I think the
      rule can be cleaned up in the DRL file before fully documenting
      it.</p><p>Rules #10 and #11 act in the same way as Rule #9 but check for the
      existance of only two possible values in a given column and zone
      respectively.</p><p>To solve harder grids, the rule set would need to be extended
      further with more complex rules that encapsulated more complex
      reasoning.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7743"></a>10.1.11.6.&nbsp;Suggestions for Future Developments</h4></div></div></div><p>There are a number of ways in which this example could be
      developed. The reader is encouraged to consider these as
      excercises.</p><div class="itemizedlist"><ul type="disc"><li><p>Agenda-group: agenda groups are a great declarative tool for
          phased execution. In this example, it is easy to see we have 2
          phases: "resolution" and "validation". Right now, they are executed
          by creating two separate rule bases, each for one "job". I think it
          would be better for us to define agenda-groups for all the rules,
          spliting them in "resolution" rules and "validation" rules, all
          loaded in a single rule base. The engine executes resolution and
          right after that, executes validation.</p></li><li><p>Auto-focus: auto focus is a great way of handling exceptions
          to the regular rules execution. In our case, if we detect an
          inconsistency, either in the input data or in the resolution rules,
          why should we spend time continuing the execution if it will be
          invalid anyway? I think it is better to simply (and immediatly)
          report the inconsistency as soon as it is found. To do that, since
          we now have a single rulebase with all rules, we simply need to
          define auto-focus attribute for all rules validating puzzle
          consistency.</p></li><li><p>Logical insert: an inconsistency only exists while wrong data
          is in the working memory. As so, we could state that the the
          validation rules logically insert inconsistencies and as soon as the
          offending data is retracted, the inconsistency no longer
          exists.</p></li><li><p>session.iterateObjects(): although a valid use case having a
          global list to add the found problems, I think it would be more
          interesting to ask the stateful session by the desired list of
          problems, using session.iterateObjects( new ClassObjectFilter(
          Inconsistency.class ) ); Having the inconsistency class can also
          allow us to paint in RED the offending cells in the GUI.</p></li><li><p>drools.halt(): even reporting the error as soon as it is
          found, we need a way to tell the engine to stop evaluating rules. We
          can do that creating a rule that in the presence of Inconsistencies,
          calls drools.halt() to stop evaluation.</p></li><li><p>queries: looking at the method getPossibleCellValues(int row,
          int col) in DroolsSudokuGridModel, we see it iterating over all
          CellValues and looking for the few it wants. That, IMO, is a great
          opportunity to teach drools queries. We just define a query to
          return the objects we want and iterate over it. Clean and nice.
          Other queries may be defined as needed.</p></li><li><p>session.iterateObjects(): although a valid use case having a
          global list to add the found problems, I think it would be more
          interesting to ask the stateful session by the desired list of
          problems, using session.iterateObjects( new ClassObjectFilter(
          Inconsistency.class ) ); Having the inconsistency class can also
          allow us to paint in RED the offending cells in the GUI.</p></li><li><p>Globals as services: the main objective of this change is to
          attend the next change I will propose, but it is nice by its own I
          guess. :) In order to teach the use of "globals" as services, it
          would be nice to setup a call back, so that each rule that finds the
          ResolvedCellValue for a given cell can call, to notify and update
          the corresponding cell in the GUI, providing immediate feedback for
          the user. Also, the last found cell could have its number painted in
          a different color to facilitate the identification of the rules
          conclusions.</p></li><li><p>Step by step execution: now that we have immediate user
          feedback, we can make use of the restricted run feature in drools.
          I.e., we could add a button in the GUI, so that the user clicks and
          causes the execution of a single rule, by calling fireAllRules( 1 ).
          This way, the user can see, step by step, what the engine is
          doing.</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7777"></a>10.1.12.1.&nbsp;Number Guess</h4></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Number Guess 
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.NumberGuessExample
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> NumberGuess.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrate use of Rule Flow to organise Rules
</pre><p>The "Number Guess" example shows the use of RuleFlow, a way of
      controlling the order in which rules are fired. It uses widely
      understood workflow diagrams to make clear the order that groups of
      rules will be executed.</p><div class="example"><a name="d0e7798"></a><p class="title"><b>Example&nbsp;10.70.&nbsp;Creating the Number Guess RuleBase - extract 1 from
        NumberGuessExample.java main() method</b></p><div class="example-contents"><pre class="programlisting">final PackageBuilder builder = new PackageBuilder();

builder.addPackageFromDrl( new InputStreamReader( 
         ShoppingExample.class.getResourceAsStream( "NumberGuess.drl" ) ) );
builder.addRuleFlow( new InputStreamReader( 
         ShoppingExample.class.getResourceAsStream( "NumberGuess.rfm" ) ) );

final RuleBase ruleBase = RuleBaseFactory.newRuleBase();
ruleBase.addPackage( builder.getPackage() );

</pre></div></div><br class="example-break"><p>The creation of the package, and the loading of the rules (using
      the addPackageFromDrl() method ) is the same as the previous examples.
      There is a additional line to add the RuleFlow (NumberGuess.rfm) as you
      have the option of specifying different ruleflows for the same RuleBase.
      Otherwise the RuleBase is created in the same manner as before .</p><div class="example"><a name="d0e7805"></a><p class="title"><b>Example&nbsp;10.71.&nbsp;Starting the RuleFlow - extract 2 from NumberGuessExample.java
        main() method</b></p><div class="example-contents"><pre class="programlisting">final StatefulSession session = ruleBase.newStatefulSession();

session.insert( new GameRules( 100,  5 ) );
session.insert( new RandomNumber() );
session.insert( new Game() );

session.startProcess( "Number Guess" );
session.fireAllRules();

session.dispose();

</pre></div></div><br class="example-break"><p>Once we have a RuleBase we can use it to obtain a stateful
      session. Into our session we insert our facts (standard Java Objects).
      For simplicity in this sample, these classes are all contained within
      our NumberGuessExample.java file. The GameRules class provides the
      maximum range and the number of guesses allowed. The RandomNumber class
      automatically generates a number between 0 and 100 and makes it
      available to our rules after insertion (via the getValue() method). The
      Game class keeps track of the guesses we have made before, and the
      number of guesses we have made.</p><p>Note that before we call the standard fireAllRules() method, we
      also start the process that we loaded earlier (via the startProcess()
      method). We explain where to obtain the parameter we pass ("Number
      Guess" - the id of the ruleflow) when we talk about the RuleFlow file
      and the graphical RuleFlow editor below.</p><p>Before we finish we our Java code , we note that In 'real life' we
      would examine the final state of the objects (e.g. how many guesses it
      took, so that we could add it to a high score table). For this example
      we are content to ensure the working memory session is cleared by
      calling the dispose() method.</p><div class="figure"><a name="d0e7816"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/numberguess-ruleflow.png" alt="RuleFlow for the NumberGuess Example"></div></div><p class="title"><b>Figure&nbsp;10.21.&nbsp;RuleFlow for the NumberGuess Example</b></p></div><br class="figure-break"><p>If you open the NumberGuess.rf file open in the Drools IDE (and
      have the JBoss Rules extensions installed correctly in Eclipse) you
      should see the above diagram, similar to a standard flowchart. Its icons
      are similar (but not exactly the same) as the JBoss jBPM workflow
      product. Should you wish to edit the diagram, a menu of available
      components should be available to the left of the diagram in the IDE,
      which is call the pallete. This diagram is saved in a (almost human)
      readable xml format, using xstream.</p><p>If it is not already open, ensure the properties view is visible
      in the IDE. It can opened by selecting Window -&gt; Show View -&gt;
      Other and then select the Properties view. If you do this <span class="bold"><strong>before</strong></span> you select any item on the RuleFlow (or
      click on blank space in the RuleFlow) you should be presented with the
      following set of properties.</p><div class="figure"><a name="d0e7829"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/numberguess-ruleflow-properties.png" alt="Properties for the Number Guess RuleFlow"></div></div><p class="title"><b>Figure&nbsp;10.22.&nbsp;Properties for the Number Guess RuleFlow</b></p></div><br class="figure-break"><p>Keep an eye on the properties view as we progress through the
      example RuleFlow as it gives valuable information. In this case it
      provides us with the ID of the RuleFlow process that we used in our
      earlier code example when we called session.startprocess().</p><p>To give an overview of each of the node types (boxes) in the
      NumberGuess RuleFlow.</p><p>
        </p><div class="itemizedlist"><ul type="disc"><li><p>The Start and End nodes (green arrow and red box) are where
            the RuleFlow starts and ends.</p></li><li><p>RuleFlowGroup (simple yellow box). These map to the
            RuleFlowGroups in our rules (DRL) file that we will look at later.
            For example when the flow reaches the 'Too High' RuleFlowGroup,
            only those rules marked with an attribute of <span class="bold"><strong>ruleflow-group "Too High" </strong></span> can potentially
            fire.</p></li><li><p>Action Nodes (yellow box with cog like icon). These can
            perform standard Java method calls. Most action nodes in this
            example call System.out.println to give an indication to the user
            of what is going on.</p></li><li><p>Split and Join Nodes (Blue Ovals) such as "Guess Correct"
            and "More Guesses Join" where the flow of control can split
            (according to various conditions) and / or rejoin.</p></li><li><p>Arrows that indicate the flow between the various
            nodes.</p></li></ul></div><p>
      </p><p>These various nodes work together with the Rules to make the
      Number Guess game work. For example, the "Guess" RuleFlowGroup allows
      only the rule "Get user Guess" to fire (details below) as only that Rule
      has a matching attribute of <span class="bold"><strong>ruleflow-group
      "Guess"</strong></span></p><div class="example"><a name="d0e7865"></a><p class="title"><b>Example&nbsp;10.72.&nbsp;A Rule that will fire only a specific point in the RuleFlow -
        extract from NumberGuess.drl</b></p><div class="example-contents"><pre class="programlisting">rule "Get user Guess"
 ruleflow-group "Guess"
 no-loop
 when    
     $r : RandomNumber()
     rules : GameRules( allowed : allowedGuesses )
     game : Game( guessCount &lt; allowed )
     not ( Guess() )
 then
     System.out.println( "You have " + ( rules.allowedGuesses - game.guessCount ) 
     + " out of " + rules.allowedGuesses + " guesses left.\nPlease enter your guess 
     from 0 to " + rules.maxRange );
        br = new BufferedReader( new InputStreamReader( System.in ) );
        modify ( game ) { guessCount = game.guessCount + 1 }
        i = br.readLine();        
    insert( new Guess( i ) );
end</pre></div></div><br class="example-break"><p>The rest of this rule is fairly standard : The <span class="bold"><strong>LHS (when)</strong></span> section of the rule states that it
      will be activated for each <span class="emphasis"><em>RandomNumber</em></span> object
      inserted into the working memory where <span class="emphasis"><em>guessCount</em></span>
      is less than the <span class="emphasis"><em>allowedGuesses</em></span> ( read from the
      GameRules Class) and where the user has not guessed the correct
      number.</p><p>The <span class="bold"><strong>RHS (consequence, then)</strong></span>
      prints a message to the user, then awaits user input from
      <span class="emphasis"><em>System.in. </em></span> After getting this input (as System.in
      blocks until the &lt;return&gt; key is pressed) it updates/modifes the
      guess count, the actual guess and makes both available in the working
      memory.</p><p>The rest of the Rules file is fairly standard ; the package
      declares the dialect is set to MVEL, various Java classes are imported.
      In total, there are five rules in this file:</p><div class="orderedlist"><ol type="1"><li><p>Get User Guess, the Rule we examined above.</p></li><li><p>A Rule to record the highest guess.</p></li><li><p>A Rule to record the lowest guess.</p></li><li><p>A Rule to inspect the guess and retract it from memory if
            incorrect.</p></li><li><p>A Rule that notifies the user that all guesses have been
            used up.</p></li></ol></div><p>One point of integration between the standard Rules and
      the RuleFlow is via the 'ruleflow-group' attribute on the rules (as
      dicussed above). A <span class="bold"><strong>second point of integration
      between the Rules File (drl) and the Rules Flow .rf files </strong></span>is
      that the Split Nodes (the blue ovals) can use values in working memory
      (as updated by the Rules) to decide which flow of action to take. To see
      how this works click on the "Guess Correct Node" ; then within the
      properties view, open the constraints editor (the button at the right
      that appears once you click on the 'Constraints' property line). You
      should see something similar to the Diagram below.</p><div class="figure"><a name="d0e7915"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/numberguess-editconstraints.png" alt="Edit Constraints for the GuessCorrect Node"></div></div><p class="title"><b>Figure&nbsp;10.23.&nbsp;Edit Constraints for the GuessCorrect Node</b></p></div><br class="figure-break"><p>Click on 'Edit' beside 'To node Too High' and you see a dialog
      like the one below. The values in the 'Textual Editor' follow the
      standard Rule Format (LHS) and can refer to objects in working memory.
      The consequence (RHS) is that the flow of control follows this node
      (i.e. To node Too high') if the LHS expression evaluates to true.</p><div class="figure"><a name="d0e7923"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/numberguess-constraint-toohigh.png" alt="Constraints Editor for the GuessCorrect Node / value too high"></div></div><p class="title"><b>Figure&nbsp;10.24.&nbsp;Constraints Editor for the GuessCorrect Node / value too
        high</b></p></div><br class="figure-break"><p>Since the NumberGuess.java example contains a main() method, it
      can be run as a standard Java application (either from the command line
      or via the IDE). A typical game might result in the interaction below
      (the numbers in bold are typed in by the user).</p><div class="example"><a name="d0e7931"></a><p class="title"><b>Example&nbsp;10.73.&nbsp;Example Console output where the Number Guess Example beat the
        human!</b></p><div class="example-contents"><pre class="programlisting">You have 5 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>50</strong></span>
Your guess was too high
You have 4 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>25</strong></span>
Your guess was too low
You have 3 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>37</strong></span>
Your guess was too low
You have 2 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>44</strong></span>
Your guess was too low
You have 1 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>47</strong></span>
Your guess was too low
You have no more guesses
The correct guess was 48 

</pre></div></div><br class="example-break"><p>A summary of what is happening in this sample is:</p><p>
        </p><div class="orderedlist"><ol type="1"><li><p>Main() method of NumberGuessExample.java loads RuleBase,
            gets a StatefulSession and inserts Game, GameRules and
            RandomNumber (containing the target number) objects into it. This
            method sets the process flow we are going to use, and fires all
            rules. Control passes to the RuleFlow.</p></li><li><p>The NumberGuess.rf RuleFlow begins at the Start node.</p></li><li><p>Control passes (via the "more guesses" join node) to the
            Guess Node..</p></li><li><p>At the Guess node, the appropriate RuleFlowGroup ("Get user
            Guess") is enabled. In this case the Rule "Guess" (in the
            NumberGuess.drl file) is triggered. This rule displays a message
            to the user, takes the response, and puts it into memory. Flow
            passes to the next Rule Flow Node.</p></li><li><p>At the next node , "Guess Correct", constraints inspect the
            current session and decide which path we take next.</p><p>If the guess in step 4 was too high / too low flow procees
            along a path which has (i) An action node with normal Java code
            prints a too high / too low statement and (ii) a RuleFlowGroup
            causes a highest guess / lowest guess Rule to be triggered in the
            Rules file. Flow passes from these nodes to step 6.</p><p>If the guess in step 4 just right we proceed along the path
            towards the end of the Rule Flow. Before we get there, an action
            node with normal Java code prints a statement "you guessed
            correctly". There is a join node here (just before the Rule Flow
            End) so that our no-more-guesses path (step 7) can also terminate
            the RuleFlow.</p></li><li><p>Control passes as per the RuleFlow via a join node, a guess
            incorrect RuleFlowGroup (triggers a rule to retract a guess from
            working memory) onto the "more guesses" decision node.</p></li><li><p>The "more guesses" decision node (right hand side of
            ruleflow) uses constraints (again looking at values that the Rules
            have put into the working memory) to decide if we have more
            guesses and if so, goto step 3. If not we proceed to the end of
            the workflow, via a RuleFlowGroup that triggers a rule stating
            "you have no more guesses".</p></li><li><p>The Loop 3-7 continues until the number is guessed
            correctly, or we run out of guesses.</p></li></ol></div><p>
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7985"></a>10.1.13.&nbsp;Miss Manners and Benchmarking</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Miss Manners
<span class="bold"><strong>Main class:</strong></span> org.drools.benchmark.manners.MannersBenchmark
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> manners.drl
<span class="bold"><strong>Objective:</strong></span> Advanced walkthrough on the Manners benchmark, covers Depth conflict resolution in depth.</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8004"></a>10.1.13.1.&nbsp;Introduction</h4></div></div></div><p>Miss Manners is throwing a party and being the good host she wants
      to arrange good seating. Her initial design arranges everyone in male
      female pairs, but then she worries about people have things to talk
      about; what is a good host to do? So she decides to note the hobby of
      each guest so she can then arrange guests in not only male and female
      pairs but also ensure that a guest has someone to talk about a common
      hobby, from either their left or right side.</p><div class="figure"><a name="d0e8009"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Examples/guests_at_table.png" align="middle" alt="Miss Manners' Guests"></div></div><p class="title"><b>Figure&nbsp;10.25.&nbsp;Miss Manners' Guests</b></p></div><br class="figure-break"><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8017"></a>10.1.13.1.1.&nbsp;BenchMarking</h5></div></div></div><p>5 benchmarks were established in the 1991 paper "Effects of
        Database Size on Rule System Performance: Five Case Studies" by Brant,
        Timothy Grose, Bernie Lofaso, &amp; Daniel P. Miranker.</p><div class="itemizedlist"><ul type="disc"><li><p>Manners</p><div class="itemizedlist"><ul type="circle"><li><p>Uses a depth-first search approach to determine the
                seating arrangements of boy/girl and one common hobby for
                dinner guests</p></li></ul></div></li><li><p>Waltz</p><div class="itemizedlist"><ul type="circle"><li><p>line labeling for simple scenes by constraint
                propagation</p></li></ul></div></li><li><p>WaltzDB</p><div class="itemizedlist"><ul type="circle"><li><p>More general version of Walts to be able to adapt to a
                database of facts</p></li></ul></div></li><li><p>ARP</p><div class="itemizedlist"><ul type="circle"><li><p>Route planner for a robotic air vehicle using the A*
                search algorithm</p></li></ul></div></li><li><p>Weavera</p><div class="itemizedlist"><ul type="circle"><li><p>VLSI router for channels and boxes using a black-board
                technique</p></li></ul></div></li></ul></div><p>Manners has become the de facto rule engine benchmark; however
        it's behavior is now well known and many engines optimize for this
        thus negating its usefulness as a benchmark which is why Waltz is
        becoming more favorable. These 5 benchmarks are also published at the
        University of Texas <a class="ulink" href="http://www.cs.utexas.edu/ftp/pub/ops5-benchmark-suite/" target="_top">http://www.cs.utexas.edu/ftp/pub/ops5-benchmark-suite/</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8063"></a>10.1.13.1.2.&nbsp;Miss Manners Execution Flow</h5></div></div></div><p>After the first Seating arrangement has been assigned a
        depth-first recursion occurs which repeatedly assigns correct Seating
        arrangements until the last seat is assigned. Manners uses a Context
        instance to control execution flow; the activity diagram is
        partitioned to show the relation of the rule execution to the current
        Context state.</p><div class="figure"><a name="d0e8068"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Examples/manners_activity_diagram.png" align="middle" alt="Manners Activity Diagram"></div></div><p class="title"><b>Figure&nbsp;10.26.&nbsp;Manners Activity Diagram</b></p></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8076"></a>10.1.13.1.3.&nbsp;The Data and Results</h5></div></div></div><p>Before going deeper into the rules lets first take a look at the
        asserted data and the resulting Seating arrangement. The data is a
        simple set of 5 guests who should be arranged in male/female pairs
        with common hobbies.</p><p><span class="bold"><strong>The Data</strong></span></p><p>Each line of the results list is printed per execution of the
        &#8220;Assign Seat&#8221; rule. They key bit to notice is that each line has pid
        one greater than the last, the significance of this will be explained
        in t he &#8220;Assign Seating&#8221; rule description. The 'l' and the 'r' refer
        to the left and right, 's' is sean and 'n' is the guest name. In my
        actual implementation I used longer notation, 'leftGuestName', but
        this is not practice in a printed article. I found the notation of
        left and right preferable to the original OPS5 '1' and '2</p><div class="literallayout"><p>(guest&nbsp;(name&nbsp;n1)&nbsp;(sex&nbsp;m)&nbsp;(hobby&nbsp;&nbsp;h1)&nbsp;&nbsp;)<br>
(guest&nbsp;(name&nbsp;n2)&nbsp;(sex&nbsp;f)&nbsp;(hobby&nbsp;&nbsp;h1)&nbsp;&nbsp;)<br>
(guest&nbsp;(name&nbsp;n2)&nbsp;(sex&nbsp;f)&nbsp;(hobby&nbsp;&nbsp;h3)&nbsp;&nbsp;)<br>
(guest&nbsp;(name&nbsp;n3)&nbsp;(sex&nbsp;m)&nbsp;(hobby&nbsp;&nbsp;h3)&nbsp;&nbsp;)<br>
(guest&nbsp;(name&nbsp;n4)&nbsp;(sex&nbsp;m)&nbsp;(hobby&nbsp;&nbsp;h1)&nbsp;&nbsp;)<br>
(guest&nbsp;(name&nbsp;n4)&nbsp;(sex&nbsp;f)&nbsp;(hobby&nbsp;&nbsp;h2)&nbsp;&nbsp;)<br>
(guest&nbsp;(name&nbsp;n4)&nbsp;(sex&nbsp;f)&nbsp;(hobby&nbsp;&nbsp;h3)&nbsp;&nbsp;)<br>
(guest&nbsp;(name&nbsp;n5)&nbsp;(sex&nbsp;f)&nbsp;(hobby&nbsp;&nbsp;h2)&nbsp;&nbsp;)<br>
(guest&nbsp;(name&nbsp;n5)&nbsp;(sex&nbsp;f)&nbsp;(hobby&nbsp;&nbsp;h1)&nbsp;&nbsp;)<br>
(last_seat&nbsp;(seat&nbsp;5)&nbsp;&nbsp;)</p></div><p><span class="bold"><strong>The Results</strong></span></p><div class="literallayout"><p>[Seating&nbsp;id=1,&nbsp;pid=0,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=1,&nbsp;rn=n5]&nbsp;<br>
[Seating&nbsp;id=2,&nbsp;pid=1,&nbsp;done=false,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=2,&nbsp;rn=n4]&nbsp;<br>
[Seating&nbsp;id=3,&nbsp;pid=2,&nbsp;done=false,&nbsp;ls=2,&nbsp;ln=n4,&nbsp;rs=3,&nbsp;rn=n3]&nbsp;<br>
[Seating&nbsp;id=4,&nbsp;pid=3,&nbsp;done=false,&nbsp;ls=3,&nbsp;rn=n3,&nbsp;rs=4,&nbsp;rn=n2]&nbsp;<br>
[Seating&nbsp;id=5,&nbsp;pid=4,&nbsp;done=false,&nbsp;ls=4,&nbsp;ln=n2,&nbsp;rs=5,&nbsp;rn=n1]</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8093"></a>10.1.13.2.&nbsp;Indepth look</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8096"></a>10.1.13.2.1.&nbsp;Cheating</h5></div></div></div><p>Manners has been around a long time and is a contrived benchmark
        meant to exercise the cross product joins and agenda, many people not
        understanding this tweak the example to achieve better perfmance,
        making their use of the Manners benchmark pointless. Known cheats to
        Miss Manners are:</p><div class="itemizedlist"><ul type="disc"><li><p>Using arrays for a guests hobbies, instead of asserting each
            one as a single fact. This massively reduces the cross
            products.</p></li><li><p>The altering of the sequence of data can also reducing the
            amount of matching increase execution speed</p></li><li><p>Changing NOT CE (conditional element) such that the test
            algorithm only uses the "first-best-match". Basically, changing
            the test algorithm to backward chaining. the results are only
            comparable to other backward chaining rule engines or ports of
            Manners.</p></li><li><p>Removing the context so the rule engine matches the guests
            and seats pre-maturely. A proper port will prevent facts from
            matching using the context start.</p></li><li><p>Any change which prevents the rule engine from performing
            combinatorial pattern matching</p></li><li><p>If no facts are retracted in the reasoning cycle, as a
            result of NOT CE, the port is incorrect.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8120"></a>10.1.13.2.2.&nbsp;Conflict Resolution</h5></div></div></div><p>Manners benchmark was written for OPS5 which has two conflict
        resolution strategies, LEX and MEA; LEX is a chain of several
        strategies including Salience, Recency, Complexity. The Recency part
        of the strategy drives the depth first (LIFO) firing order. The Clips
        manual documents the recency strategy as:</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top">&nbsp;</td><td width="80%" valign="top"><p>Every fact and instance is marked internally with a &#8220;time tag&#8221;
          to indicate its relative recency with respect to every other fact
          and instance in the system. The pattern entities associated with
          each rule activation are sorted in descending order for determining
          placement. An activation with a more recent pattern entities is
          placed before activations with less recent pattern entities. To
          determine the placement order of two activations, compare the sorted
          time tags of the two activations one by one starting with the
          largest time tags. The comparison should continue until one
          activation&#8217;s time tag is greater than the other activation&#8217;s
          corresponding time tag. The activation with the greater time tag is
          placed before the other activation on the agenda. If one activation
          has more pattern entities than the other activation and the compared
          time tags are all identical, then the activation with more time tags
          is placed before the other activation on the agenda.</p></td><td width="10%" valign="top">&nbsp;</td></tr><tr><td width="10%" valign="top">&nbsp;</td><td colspan="2" align="right" valign="top">--<span class="attribution">Clips Reference Manual</span></td></tr></table></div><p>However Jess and Clips both use the Depth strategy, which is
        simpler and lighter, which Drools also adopted. The Clips manual
        documents the Depth strategy as:</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top">&nbsp;</td><td width="80%" valign="top"><p>Newly activated rules are placed above all rules of the same
          salience. For example, given that fact-a activates rule-1 and rule-2
          and fact-b activates rule-3 and rule-4, then if fact-a is asserted
          before fact-b, rule-3 and rule-4 will be above rule-1 and rule-2 on
          the agenda. However, the position of rule-1 relative to rule-2 and
          rule-3 relative to rule-4 will be arbitrary.</p></td><td width="10%" valign="top">&nbsp;</td></tr><tr><td width="10%" valign="top">&nbsp;</td><td colspan="2" align="right" valign="top">--<span class="attribution">Clips Reference Manual</span></td></tr></table></div><p>The initial Drools implementation for the Depth strategy would
        not work for manners without the use of salience on the "make_path"
        rule, the Clips support team had this to say:</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top">&nbsp;</td><td width="80%" valign="top"><p>The default conflict resolution strategy for CLIPS, depth, is
          different than the default conflict resolution strategy used by
          OPS5. Therefore if you directly translate an OPS5 program to CLIPS,
          but use the default depth conflict resolution strategy, you're only
          likely to get the correct behavior by coincidence. The lex and mea
          conflict resolution strategies are provided in CLIPS to allow you to
          quickly convert and correctly run an OPS5 program in CLIPS</p></td><td width="10%" valign="top">&nbsp;</td></tr><tr><td width="10%" valign="top">&nbsp;</td><td colspan="2" align="right" valign="top">--<span class="attribution">Clips Support Forum</span></td></tr></table></div><p>Investigation into the Clips code reveals there is undocumented
        functionality in the Depth strategy. There is an accumulated time tag
        used in this strategy; it's not an extensively fact by fact comparison
        as in the recency strategy, it simply adds the total of all the time
        tags for each activation and compares.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8146"></a>10.1.13.2.3.&nbsp;Assign First Seat</h5></div></div></div><p>Once the context is changed to START_UP Activations are created
        for all asserted Guests; because all Activations are created as the
        result of a single Working Memory action, they all have the same
        Activation time tag. The last asserted Guest would have a higher fact
        time tag and its Activation would fire, becuase it has the highest
        accumulated fact time tag. The execution order in this rule has little
        importance, but has a big impact in the rule "Assign Seat". The
        Activation fires and asserts the first Seating arrangement, a Path and
        then sets the Context's state to create Activation for "Assign
        Seat".</p><pre class="programlisting">rule assignFirstSeat
    when
        context : Context( state == Context.START_UP )
        guest : Guest()
        count : Count()
    then
        String guestName = guest.getName();        

        insert( new Seating( count.getValue(), 1, true, 1, guestName, 1, guestName) );        
        insert( new Path( count.getValue(), 1, guestName ) );        

        count.setValue(  count.getValue() + 1 );        
        update( count );
        context.setState( Context.ASSIGN_SEATS );       
        update( context );
end</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8153"></a>10.1.13.2.4.&nbsp;Assign Seat</h5></div></div></div><p>This rule determines each of the Seating arrangements. The Rule
        creates cross product solutions for ALL asserted Seating arrangements
        against ALL the asserted guests; accept against itself or any already
        assigned Chosen solutions.</p><pre class="programlisting">rule findSeating
   when 
       context : Context( state == Context.ASSIGN_SEATS )
       $s      : Seating( pathDone == true )
       $g1     : Guest( name == $s.rightGuestName )
       $g2     : Guest( sex != $g1.sex, hobby == $g1.hobby )
       count   : Count()
       not ( Path( id == $s.id, guestName == $g2.name) )
       not ( Chosen( id == $s.id, guestName == $g2.name, hobby == $g1.hobby) )
   then
       int rightSeat = $s.getRightSeat();
       int seatId = $s.getId();
       int countValue = count.getValue();
       
       insert( new Seating( countValue, seatId, false, rightSeat, $s.getRightGuestName(), rightSeat + 1, $g2.getName() ) );                                
       insert( new Path( countValue, rightSeat + 1, $g2.getName() ) );       
       insert( new Chosen( seatId, $g2.getName(), $g1.getHobby() ) );

       count.setValue(  countValue + 1 );
       update( count );       
       context.setState( Context.MAKE_PATH );
       update( context );
end</pre><p>However, as can be seen from the printed results shown earlier,
        it is essential that only the Seating with the highest pid cross
        product be chosen &#8211; yet how can this be possible if we have
        Activations, of the same time tag, for nearly all existing Seating and
        Guests. For example on the third iteration of "Assing Seat" these are
        the produced Activations, remember this is from a very small data set
        and with larger data sets there would be many more possible Activated
        Seating solutions, with multiple solutions per pid:</p><div class="literallayout"><p>=&gt;[ActivationCreated(35):&nbsp;rule=findSeating&nbsp;<br>
[fid:19:33]:[Seating&nbsp;id=3,&nbsp;pid=2,&nbsp;done=true,&nbsp;ls=2,&nbsp;ln=n4,&nbsp;rs=3,&nbsp;rn=n3]&nbsp;<br>
[fid:4:4]:[Guest&nbsp;name=n3,&nbsp;sex=m,&nbsp;hobbies=h3]&nbsp;<br>
[fid:3:3]:[Guest&nbsp;name=n2,&nbsp;sex=f,&nbsp;hobbies=h3]<br>
<br>
=&gt;[ActivationCreated(35):&nbsp;rule=findSeating&nbsp;<br>
[fid:15:23]:[Seating&nbsp;id=2,&nbsp;pid=1,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=2,&nbsp;rn=n4]&nbsp;<br>
[fid:5:5]:[Guest&nbsp;name=n4,&nbsp;sex=m,&nbsp;hobbies=h1]&nbsp;<br>
[fid:2:2]:[Guest&nbsp;name=n2,&nbsp;sex=f,&nbsp;hobbies=h1]&nbsp;<br>
<br>
=&gt;[ActivationCreated(35):&nbsp;rule=findSeating&nbsp;<br>
[fid:13:13]:[Seating&nbsp;id=1,&nbsp;pid=0,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=1,&nbsp;rn=n5]&nbsp;<br>
[fid:9:9]:[Guest&nbsp;name=n5,&nbsp;sex=f,&nbsp;hobbies=h1]&nbsp;<br>
[fid:1:1]:[Guest&nbsp;name=n1,&nbsp;sex=m,&nbsp;hobbies=h1]</p></div><p>The creation of all these redundant Activations might seem
        pointless, but it must be remembered that Manners is not about good
        rule design; it's purposefully designed as a bad ruleset to fully
        stress test the cross product matching process and the agenda, which
        this clearly does. Notice that each Activation has the same time tag
        of 35, as they were all activated by the change in Context to
        ASSIGN_SEATS. With OPS5 and LEX it would correctly fire the Activation
        with the last asserted Seating. With Depth the accumulated fact time
        tag ensures the Activation with the last asserted Seating
        fires.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8166"></a>10.1.13.2.5.&nbsp;Make Path and Path Done</h5></div></div></div><p>"Make Path" must always fires before "Path Done". A Path is
        asserted for each Seating arrangement up to the last asserted Seating.
        Notice that "Path Done" is a subset of "Make Path", so how do we
        ensure that "Make Path" fires first?</p><pre class="programlisting">rule makePath
    when 
        Context( state == Context.MAKE_PATH )
        Seating( seatingId:id, seatingPid:pid, pathDone == false )
        Path( id == seatingPid, pathGuestName:guestName, pathSeat:seat )
        not Path( id == seatingId, guestName == pathGuestName )
    then
        insert( new Path( seatingId, pathSeat, pathGuestName ) );
end</pre><pre class="programlisting">rule pathDone
    when
        context : Context( state == Context.MAKE_PATH ) 
        seating : Seating( pathDone == false ) 
    then
        seating.setPathDone( true ); 
        update( seating );
        
        context.setState( Context.CHECK_DONE ); 
        update( context );
end</pre><div class="figure"><a name="d0e8175"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Examples/make_path.png" align="middle" alt="Rete Diagram"></div></div><p class="title"><b>Figure&nbsp;10.27.&nbsp;Rete Diagram</b></p></div><br class="figure-break"><p>Both rules end up on the Agenda in conflict and with identical
        activation time tags, however the accumulate fact time tag is greater
        for "Make Path" so it gets priority.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8185"></a>10.1.13.2.6.&nbsp;Continue and Are We Done</h5></div></div></div><p>"Are We Done" only activates when the last seat is assigned, at
        which point both rules will be activated. For the same reason that
        "Make Path" always wins over "Path Done" "Are We Done" will take
        priority over "Continue".</p><pre class="programlisting">rule areWeDone
    when
        context : Context( state == Context.CHECK_DONE ) 
        LastSeat( lastSeat: seat )
        Seating( rightSeat == lastSeat ) 
    then
        context.setState(Context.PRINT_RESULTS ); 
        update( context );
end
</pre><pre class="programlisting">rule continue
    when
        context : Context( state == Context.CHECK_DONE ) 
    then
        context.setState( Context.ASSIGN_SEATS ); 
        update( context );
end
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8194"></a>10.1.13.3.&nbsp;Output Summary</h4></div></div></div><div class="literallayout"><p><span class="bold"><strong>Assign&nbsp;First&nbsp;seat</strong></span><br>
=&gt;[fid:13:13]:[Seating&nbsp;id=1,&nbsp;pid=0,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=1,&nbsp;rn=n5]<br>
=&gt;[fid:14:14]:[Path&nbsp;id=1,&nbsp;seat=1,&nbsp;guest=n5]<br>
<br>
==&gt;[ActivationCreated(16):&nbsp;rule=findSeating<br>
[fid:13:13]:[Seating&nbsp;id=1,&nbsp;pid=0,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=1,&nbsp;rn=n5]<br>
[fid:9:9]:[Guest&nbsp;name=n5,&nbsp;sex=f,&nbsp;hobbies=h1]<br>
[fid:1:1]:[Guest&nbsp;name=n1,&nbsp;sex=m,&nbsp;hobbies=h1]<br>
<br>
==&gt;[ActivationCreated(16):&nbsp;rule=findSeating<br>
[fid:13:13]:[Seating&nbsp;id=1&nbsp;,&nbsp;pid=0,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=1,&nbsp;rn=n5]<br>
[fid:9:9]:[Guest&nbsp;name=n5,&nbsp;sex=f,&nbsp;hobbies=h1]<br>
[fid:5:5]:[Guest&nbsp;name=n4,&nbsp;sex=m,&nbsp;hobbies=h1]*<br>
<br>
<span class="bold"><strong>Assign&nbsp;Seating</strong></span><br>
=&gt;[fid:15:17]&nbsp;:[Seating&nbsp;id=2&nbsp;,&nbsp;pid=1&nbsp;,&nbsp;done=false,&nbsp;ls=1,&nbsp;lg=n5,&nbsp;rs=2,&nbsp;rn=n4]<br>
=&gt;[fid:16:18]:[Path&nbsp;id=2,&nbsp;seat=2,&nbsp;guest=n4]<br>
=&gt;[fid:17:19]:[Chosen&nbsp;id=1,&nbsp;name=n4,&nbsp;hobbies=h1]<br>
<br>
=&gt;[ActivationCreated(21):&nbsp;rule=makePath&nbsp;<br>
[fid:15:17]&nbsp;:&nbsp;[Seating&nbsp;id=2,&nbsp;pid=1,&nbsp;done=false,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=2,&nbsp;rn=n4]<br>
[fid:14:14]&nbsp;:&nbsp;[Path&nbsp;id=1,&nbsp;seat=1,&nbsp;guest=n5]*<br>
<br>
==&gt;[ActivationCreated(21):&nbsp;rule=pathDone<br>
[Seating&nbsp;id=2,&nbsp;pid=1,&nbsp;done=false,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=2,&nbsp;rn=n4]*<br>
<br>
<span class="bold"><strong>Make&nbsp;Path</strong></span><br>
=&gt;[fid:18:22:[Path&nbsp;id=2,&nbsp;seat=1,&nbsp;guest=n5]]<br>
<br>
<span class="bold"><strong>Path&nbsp;Done</strong></span><br>
<br>
<span class="bold"><strong>Continue&nbsp;Process</strong></span><br>
=&gt;[ActivationCreated(25):&nbsp;rule=findSeating<br>
[fid:15:23]:[Seating&nbsp;id=2,&nbsp;pid=1,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=2,&nbsp;rn=n4]<br>
[fid:7:7]:[Guest&nbsp;name=n4,&nbsp;sex=f,&nbsp;hobbies=h3]<br>
[fid:4:4]&nbsp;:&nbsp;[Guest&nbsp;name=n3,&nbsp;sex=m,&nbsp;hobbies=h3]*<br>
<br>
=&gt;[ActivationCreated(25):&nbsp;rule=findSeating<br>
[fid:15:23]:[Seating&nbsp;id=2,&nbsp;pid=1,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=2,&nbsp;rn=n4]<br>
[fid:5:5]:[Guest&nbsp;name=n4,&nbsp;sex=m,&nbsp;hobbies=h1]<br>
[fid:2:2]:[Guest&nbsp;name=n2,&nbsp;sex=f,&nbsp;hobbies=h1],&nbsp;[fid:12:20]&nbsp;:&nbsp;[Count&nbsp;value=3]<br>
<br>
=&gt;[ActivationCreated(25):&nbsp;rule=findSeating<br>
[fid:13:13]:[Seating&nbsp;id=1,&nbsp;pid=0,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=1,&nbsp;rn=n5]<br>
[fid:9:9]:[Guest&nbsp;name=n5,&nbsp;sex=f,&nbsp;hobbies=h1]<br>
[fid:1:1]:[Guest&nbsp;name=n1,&nbsp;sex=m,&nbsp;hobbies=h1]<br>
<br>
<span class="bold"><strong>Assign&nbsp;Seating</strong></span><br>
=&gt;[fid:19:26]:[Seating&nbsp;id=3,&nbsp;pid=2,&nbsp;done=false,&nbsp;ls=2,&nbsp;lnn4,&nbsp;rs=3,&nbsp;rn=n3]]<br>
=&gt;[fid:20:27]:[Path&nbsp;id=3,&nbsp;seat=3,&nbsp;guest=n3]]<br>
=&gt;[fid:21:28]:[Chosen&nbsp;id=2,&nbsp;name=n3,&nbsp;hobbies=h3}]<br>
<br>
=&gt;[ActivationCreated(30):&nbsp;rule=makePath<br>
[fid:19:26]:[Seating&nbsp;id=3,&nbsp;pid=2,&nbsp;done=false,&nbsp;ls=2,&nbsp;ln=n4,&nbsp;rs=3,&nbsp;rn=n3]<br>
[fid:18:22]:[Path&nbsp;id=2,&nbsp;seat=1,&nbsp;guest=n5]*<br>
<br>
=&gt;[ActivationCreated(30):&nbsp;rule=makePath&nbsp;<br>
[fid:19:26]:[Seating&nbsp;id=3,&nbsp;pid=2,&nbsp;done=false,&nbsp;ls=2,&nbsp;ln=n4,&nbsp;rs=3,&nbsp;rn=n3]<br>
[fid:16:18]:[Path&nbsp;id=2,&nbsp;seat=2,&nbsp;guest=n4]*<br>
<br>
=&gt;[ActivationCreated(30):&nbsp;rule=done&nbsp;<br>
[fid:19:26]:[Seating&nbsp;id=3,&nbsp;pid=2,&nbsp;done=false,&nbsp;ls=2,&nbsp;ln=n4,&nbsp;rs=3,&nbsp;rn=n3]*<br>
<br>
<span class="bold"><strong>Make&nbsp;Path</strong></span><br>
=&gt;[fid:22:31]:[Path&nbsp;id=3,&nbsp;seat=1,&nbsp;guest=n5]<br>
<br>
<span class="bold"><strong>Make&nbsp;Path&nbsp;</strong></span><br>
=&gt;[fid:23:32]&nbsp;[Path&nbsp;id=3,&nbsp;seat=2,&nbsp;guest=n4]<br>
<br>
<span class="bold"><strong>Path&nbsp;Done</strong></span><br>
<br>
<span class="bold"><strong>Continue&nbsp;Processing</strong></span><br>
=&gt;[ActivationCreated(35):&nbsp;rule=findSeating<br>
[fid:19:33]:[Seating&nbsp;id=3,&nbsp;pid=2,&nbsp;done=true,&nbsp;ls=2,&nbsp;ln=n4,&nbsp;rs=3,&nbsp;rn=n3]<br>
[fid:4:4]:[Guest&nbsp;name=n3,&nbsp;sex=m,&nbsp;hobbies=h3]<br>
[fid:3:3]:[Guest&nbsp;name=n2,&nbsp;sex=f,&nbsp;hobbies=h3],&nbsp;[fid:12:29]*<br>
<br>
=&gt;[ActivationCreated(35):&nbsp;rule=findSeating&nbsp;<br>
[fid:15:23]:[Seating&nbsp;id=2,&nbsp;pid=1,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=2,&nbsp;rn=n4]&nbsp;<br>
[fid:5:5]:[Guest&nbsp;name=n4,&nbsp;sex=m,&nbsp;hobbies=h1]<br>
[fid:2:2]:[Guest&nbsp;name=n2,&nbsp;sex=f,&nbsp;hobbies=h1]<br>
<br>
=&gt;[ActivationCreated(35):&nbsp;rule=findSeating&nbsp;<br>
[fid:13:13]:[Seating&nbsp;id=1,&nbsp;pid=0,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=1,&nbsp;rn=n5]&nbsp;<br>
[fid:9:9]:[Guest&nbsp;name=n5,&nbsp;sex=f,&nbsp;hobbies=h1],&nbsp;[fid:1:1]&nbsp;:&nbsp;[Guest&nbsp;name=n1,&nbsp;sex=m,&nbsp;hobbies=h1]<br>
<br>
<span class="bold"><strong>Assign&nbsp;Seating</strong></span><br>
=&gt;[fid:24:36]:[Seating&nbsp;id=4,&nbsp;pid=3,&nbsp;done=false,&nbsp;ls=3,&nbsp;ln=n3,&nbsp;rs=4,&nbsp;rn=n2]]<br>
=&gt;[fid:25:37]:[Path&nbsp;id=4,&nbsp;seat=4,&nbsp;guest=n2]]<br>
=&gt;[fid:26:38]:[Chosen&nbsp;id=3,&nbsp;name=n2,&nbsp;hobbies=h3]<br>
<br>
==&gt;[ActivationCreated(40):&nbsp;rule=makePath&nbsp;<br>
[fid:24:36]:[Seating&nbsp;id=4,&nbsp;pid=3,&nbsp;done=false,&nbsp;ls=3,&nbsp;ln=n3,&nbsp;rs=4,&nbsp;rn=n2]<br>
[fid:23:32]:[Path&nbsp;id=3,&nbsp;seat=2,&nbsp;guest=n4]*<br>
<br>
==&gt;[ActivationCreated(40):&nbsp;rule=makePath&nbsp;<br>
[fid:24:36]:[Seating&nbsp;id=4,&nbsp;pid=3,&nbsp;done=false,&nbsp;ls=3,&nbsp;ln=n3,&nbsp;rs=4,&nbsp;rn=n2]&nbsp;<br>
[fid:20:27]:[Path&nbsp;id=3,&nbsp;seat=3,&nbsp;guest=n3]*<br>
<br>
=&gt;[ActivationCreated(40):&nbsp;rule=makePath&nbsp;<br>
[fid:24:36]:[Seating&nbsp;id=4,&nbsp;pid=3,&nbsp;done=false,&nbsp;ls=3,&nbsp;ln=n3,&nbsp;rs=4,&nbsp;rn=n2]<br>
[fid:22:31]:[Path&nbsp;id=3,&nbsp;seat=1,&nbsp;guest=n5]*<br>
<br>
=&gt;[ActivationCreated(40):&nbsp;rule=done&nbsp;<br>
[fid:24:36]:[Seating&nbsp;id=4,&nbsp;pid=3,&nbsp;done=false,&nbsp;ls=3,&nbsp;ln=n3,&nbsp;rs=4,&nbsp;rn=n2]*<br>
<br>
<span class="bold"><strong>Make&nbsp;Path&nbsp;</strong></span><br>
=&gt;fid:27:41:[Path&nbsp;id=4,&nbsp;seat=2,&nbsp;guest=n4]<br>
<br>
<span class="bold"><strong>Make&nbsp;Path</strong></span><br>
=&gt;fid:28:42]:[Path&nbsp;id=4,&nbsp;seat=1,&nbsp;guest=n5]]<br>
<br>
<span class="bold"><strong>Make&nbsp;Path</strong></span><br>
=&gt;fid:29:43]:[Path&nbsp;id=4,&nbsp;seat=3,&nbsp;guest=n3]]<br>
<br>
<span class="bold"><strong>Path&nbsp;Done</strong></span><br>
<br>
<span class="bold"><strong>Continue&nbsp;&nbsp;Processing</strong></span><br>
=&gt;[ActivationCreated(46):&nbsp;rule=findSeating&nbsp;<br>
[fid:15:23]:[Seating&nbsp;id=2,&nbsp;pid=1,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=2,&nbsp;rn=n4]&nbsp;<br>
[fid:5:5]:[Guest&nbsp;name=n4,&nbsp;sex=m,&nbsp;hobbies=h1],&nbsp;[fid:2:2]<br>
[Guest&nbsp;name=n2,&nbsp;sex=f,&nbsp;hobbies=h1]<br>
<br>
=&gt;[ActivationCreated(46):&nbsp;rule=findSeating&nbsp;<br>
[fid:24:44]:[Seating&nbsp;id=4,&nbsp;pid=3,&nbsp;done=true,&nbsp;ls=3,&nbsp;ln=n3,&nbsp;rs=4,&nbsp;rn=n2]<br>
[fid:2:2]:[Guest&nbsp;name=n2,&nbsp;sex=f,&nbsp;hobbies=h1]<br>
[fid:1:1]:[Guest&nbsp;name=n1,&nbsp;sex=m,&nbsp;hobbies=h1]*<br>
<br>
=&gt;[ActivationCreated(46):&nbsp;rule=findSeating&nbsp;<br>
[fid:13:13]:[Seating&nbsp;id=1,&nbsp;pid=0,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=1,&nbsp;rn=n5]<br>
[fid:9:9]:[Guest&nbsp;name=n5,&nbsp;sex=f,&nbsp;hobbies=h1]<br>
[fid:1:1]:[Guest&nbsp;name=n1,&nbsp;sex=m,&nbsp;hobbies=h1]<br>
<br>
<span class="bold"><strong>Assign&nbsp;Seating</strong></span><br>
=&gt;[fid:30:47]:[Seating&nbsp;id=5,&nbsp;pid=4,&nbsp;done=false,&nbsp;ls=4,&nbsp;ln=n2,&nbsp;rs=5,&nbsp;rn=n1]<br>
=&gt;[fid:31:48]:[Path&nbsp;id=5,&nbsp;seat=5,&nbsp;guest=n1]<br>
=&gt;[fid:32:49]:[Chosen&nbsp;id=4,&nbsp;name=n1,&nbsp;hobbies=h1]<br>
</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8249"></a>10.1.14.&nbsp;Conways Game Of Life Example</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Conways Game Of Life
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.conway.ConwayAgendaGroupRun org.drools.examples.conway.ConwayRuleFlowGroupRun
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> conway-ruleflow.drl conway-agendagroup.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates 'accumulate', 'collect' and 'from'</pre><p>Conway's Game Of Life, <a class="ulink" href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life" target="_top">http://en.wikipedia.org/wiki/Conway's_Game_of_Life</a>
    <a class="ulink" href="http://www.math.com/students/wonders/life/life.html" target="_top">http://www.math.com/students/wonders/life/life.html</a>,
    is a famous cellular automaton conceived in the early 1970's by
    mathematician John Conway. While the system is well known as "Conway's
    Game Of Life", it really isn't a game at all. Conway's system is more like
    a life simulation. Don't be intimidated. The system is terribly simple and
    terribly interesting. Math and Computer Science students alike have
    marvelled over Conway's system for more than 30 years now. The application
    represented here is a Swing based implementation of Conway's Game of Life.
    The rules that govern the system are implemented as business rules using
    Drools. This document will explain the rules that drive the simulation and
    discuss the Drools specific parts of the implementation.</p><p>We'll first introduce the grid view, shown below, to help
    visualisation of the problem; this is where the life simuation takes
    place. Initially the grid is empty, meaning that there are no live cells
    in the system; ech cell can be considered "LIVE" or "DEAD", live cells
    have a green ball in them. Pre-selected patterns of live cells can be
    selected from the "Pattern" drop down or cells can be doubled-clicked to
    toggle them between LIVE and DEAD. It's important to understand that each
    cell is related to it's neighbour cells, which is a core part of the
    game's rules and will be explained in a moment. Neighbors include not only
    cells to the left, right, top and bottom but also cells that are connected
    diagonally. Each cell has a total of 8 neighbors except the 4 corner cells
    and all of the other cells along the 4 edges. Corner cells have 3
    neighbors and other edge cells have 5 neighbors.</p><div class="figure"><a name="d0e8278"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/conway1.jpg" alt="Conways Example : Starting a new game"></div></div><p class="title"><b>Figure&nbsp;10.28.&nbsp;Conways Example : Starting a new game</b></p></div><br class="figure-break"><p>So what are the basic rules that govern this game? Each generation,
    i.e. completion iteration and evalution of all cells, the system evolves
    and cells may be born or killed, there are a very simple set of rules that
    govern what the next generation will look like.</p><div class="itemizedlist"><ul type="disc"><li><p>If a live cell has fewer than 2 live neighbors, it dies of
        loneliness</p></li><li><p>If a live cell has more than 3 live neighbors, it dies from
        overcrowding</p></li><li><p>If a dead cell has exactly 3 live neighbors, it comes to
        life</p></li></ul></div><p>That is all there is to it. Any cell that doesn't meet any of those
    criteria is left as is for the next generation. With those simple rules in
    mind, go back and play with the system a little bit more and step through
    some generations one at a time and notice these rules taking their
    effect.</p><p>The screnshot below shows an example generation, with a number of
    live cells. Don't worry about matching the exact patterns represented in
    the screen shot. Just get some groups of cells added to the grid. Once you
    have groups of live cells in the grid, or select a pre-designed pattern,
    click the "Next Generation" button and notice what happens. Some of the
    live cells are killed (the green ball disappears) and some dead cells come
    to life (a green ball appears). Cycle through several generations and see
    if you notice any patterns. If you click on the "Start" button, the system
    will evolve itself so you don't need to click the "Next Generation" button
    over and over. Play with the system a little and then come back here for
    more details of how the application works.</p><div class="figure"><a name="d0e8300"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/conway2.jpg" alt="Conways Example : A running game"></div></div><p class="title"><b>Figure&nbsp;10.29.&nbsp;Conways Example : A running game</b></p></div><br class="figure-break"><p>Now lets delve into the code, as this is an advanced example we'll
    assume that by now you know your way around the Drools framework and able
    to connect many of the dots, so we'll just focus at a hgh level
    overview.The example has two ways to execute, one way uses AgendaGroups to
    manage execution flow the other uses RuleFlowGroups to manage execution
    flow - so it's a great way to see the differences. - that's
    ConwayAgendaGroupRun and ConwayRuleFlowGroupRun respectively. For this
    example I'll cover the ruleflow version, as its what most people will
    use.</p><p>All the Cells are inserted into the session and the rules in the
    ruleflow-group "register neighbor" are allowed to execute by the ruleflow
    process. What this group of rules does is for each cell it registers the
    north east, north, north west and west cells using a Neighbor relation
    class, notice this relation is bi-drectional which is why we don't have to
    do any rules for southern facing cells. Note that the constraints make
    sure we stay one column back from the end and 1 row back from the top. By
    the time all activations have fired for these rules all cells are related
    to all their neighboring cells.</p><div class="example"><a name="d0e8310"></a><p class="title"><b>Example&nbsp;10.74.&nbsp;Conways Example : Register all Cell Neighbour relations</b></p><div class="example-contents"><pre class="programlisting">rule "register north east"
    ruleflow-group "register neighbor"
when
    CellGrid( $numberOfColumns : numberOfColumns )
    $cell: Cell( $row : row &gt; 0, $col : col &lt; ( $numberOfColumns - 1 ) )            
    $northEast : Cell( row  == ($row - 1), col == ( $col + 1 ) )    
then                    
    insert( new Neighbor( $cell, $northEast ) );
    insert( new Neighbor( $northEast, $cell ) );        
end

rule "register north"
    ruleflow-group "register neighbor"  
when
    $cell: Cell( $row : row &gt; 0, $col : col )   
    $north : Cell( row  == ($row - 1), col == $col )    
then        
    insert( new Neighbor( $cell, $north ) );
    insert( new Neighbor( $north, $cell ) );        
end

rule "register north west"
    ruleflow-group "register neighbor"
when
    $cell: Cell( $row : row &gt; 0, $col : col &gt; 0 )           
    $northWest : Cell( row  == ($row - 1), col == ( $col - 1 ) )                        
then        
    insert( new Neighbor( $cell, $northWest ) );
    insert( new Neighbor( $northWest, $cell ) );        
end

rule "register west"
    ruleflow-group "register neighbor"
when
    $cell: Cell( $row : row &gt;= 0, $col : col &gt; 0 )          
    $west : Cell( row  == $row, col == ( $col - 1 ) )                       
then        
    insert( new Neighbor( $cell, $west ) );
    insert( new Neighbor( $west, $cell ) );         
end</pre></div></div><br class="example-break"><p>Once all the cells are inserted some java code applies the pattern
    to the grid setting certain cells to Live. Then when the user clicks
    "start" or "next generation" it executes the "Generation" ruleflow. This
    ruleflow is responsible for the management of all changes of cells in each
    generation cycle.</p><div class="figure"><a name="d0e8317"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/conway_ruleflow_generation.png" alt="Conways Example : ruleflow &#34;Generation&#34;"></div></div><p class="title"><b>Figure&nbsp;10.30.&nbsp;Conways Example : ruleflow "Generation"</b></p></div><br class="figure-break"><p>The ruleflow process first enters the "evaluate" group, this means
    any active rule in that group can fire. The rules in this group apply the
    main game of life rules discussed in the beginning of the example, where
    it determines what cells will be killed and which ones given life. We use
    the "phase" attribute to drives the reasoning of the Cell by specific
    groups of rules; typical the phase is tied to a RuleFlowGroup. in the
    ruleflow process definition. Notice that it doesn't actually change the
    state of any Cells at this point; this is because it's evaluating the Grid
    in turn and it must complete the full evaluation until those changes can
    be applied. To achieve this it sets the cell to a "phase" which is either
    Phase.KILL or Phase.BIRTH, which is used later to control actions applied
    to the Cell and when.</p><div class="example"><a name="d0e8325"></a><p class="title"><b>Example&nbsp;10.75.&nbsp;Conways Example : Evaluate Cells with state changes</b></p><div class="example-contents"><pre class="programlisting">rule "Kill The Lonely"
    ruleflow-group "evaluate"
    no-loop
when
#   A live cell has fewer than 2 live neighbors
    theCell: Cell(liveNeighbors &lt; 2, cellState == CellState.LIVE, phase == Phase.EVALUATE)
then
    theCell.setPhase(Phase.KILL);
    update( theCell );
end

rule "Kill The Overcrowded"
    ruleflow-group "evaluate"
    no-loop
when
#   A live cell has more than 3 live neighbors
    theCell: Cell(liveNeighbors &gt; 3, cellState == CellState.LIVE, phase == Phase.EVALUATE)
then
    theCell.setPhase(Phase.KILL);
    update( theCell );
end

rule "Give Birth"
    ruleflow-group "evaluate"
    no-loop
when
#   A dead cell has 3 live neighbors
    theCell: Cell(liveNeighbors == 3, cellState == CellState.DEAD, phase == Phase.EVALUATE)
then
    theCell.setPhase(Phase.BIRTH);
    update( theCell );
end
</pre></div></div><br class="example-break"><p>Once all Cells in the grid have been evaluated we first clear any
    calculation activations, that occured from any previous data changes, via
    the "reset calculate" rule, which clears any activations in the
    "calculate" group. We then enter a split which allows any activations in
    the "kill" groups and "birth" groups to fire, these rules are responsible
    for applying the state change.</p><div class="example"><a name="d0e8332"></a><p class="title"><b>Example&nbsp;10.76.&nbsp;Conways Example : Apply the state changes</b></p><div class="example-contents"><pre class="programlisting">rule "reset calculate"
    ruleflow-group "reset calculate"
when
then
    WorkingMemory wm = drools.getWorkingMemory();
    wm.clearRuleFlowGroup( "calculate" );
end

rule "kill"
    ruleflow-group "kill"
    no-loop
when
    theCell: Cell(phase == Phase.KILL)
then
    theCell.setCellState(CellState.DEAD);
    theCell.setPhase(Phase.DONE);   
    update( theCell );
end 
 
rule "birth"
    ruleflow-group "birth"
    no-loop
when
    theCell: Cell(phase == Phase.BIRTH)
then
    theCell.setCellState(CellState.LIVE);
    theCell.setPhase(Phase.DONE);
    update( theCell );  
end </pre></div></div><br class="example-break"><p>At this stage a number of Cells have been modified with the state
    changed to either LIVE or DEAD, this is where we get to see the power of
    the Neighbour cell and relational programming. When a cell becomes LIVE or
    DEAD we use the Neigbor relation drive the iteration over all surrounding
    Cells increasing or decreasing the LIVE neighbour count, any cell who has
    their count changed is also set to to the EVALUATE phase, to make sure
    they are reasoned over duing the evaluate stage of the ruleflow process.
    Notice that we don't have to do any iteration ourselves, by simpy applying
    the relations in the rules we can get the rule engine to do all the hard
    work for us in a minimal amount of code - very nice :) Once the live count
    for all Cells has been determiend and set the ruleflow process comes to
    and end; the user can either tell it to evaluate another generation, of if
    "start" was clicked the engine will start the ruleflow process
    again.</p><div class="example"><a name="d0e8339"></a><p class="title"><b>Example&nbsp;10.77.&nbsp;Conways Example : Evaluate Cells with state changes</b></p><div class="example-contents"><pre class="programlisting">rule "Calculate Live"
    ruleflow-group "calculate"
    lock-on-active  
when
    theCell: Cell(cellState == CellState.LIVE)
    Neighbor(cell == theCell, $neighbor : neighbor) 
then
    $neighbor.setLiveNeighbors( $neighbor.getLiveNeighbors() + 1 );
    $neighbor.setPhase( Phase.EVALUATE );   
    update( $neighbor );
end 

rule "Calculate Dead"
    ruleflow-group "calculate"
    lock-on-active  
when
    theCell: Cell(cellState == CellState.DEAD)
    Neighbor(cell == theCell, $neighbor : neighbor )
then
    $neighbor.setLiveNeighbors( $neighbor.getLiveNeighbors() - 1 );
    $neighbor.setPhase( Phase.EVALUATE );
    update( $neighbor );    
end </pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8344"></a>10.1.15.&nbsp;Insurance Company Risk Factor and Policy price (using BRMS)</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> drools-insurance 
<span class="bold"><strong>Type:</strong></span> java web application
<span class="bold"><strong>Rules file:</strong></span> exported repository from brms, repository_export.xml
<span class="bold"><strong>Objective:</strong></span> Demonstrates how to use, organize, deploy and execute a rulebase from BRMS</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8360"></a>10.1.15.1.&nbsp;BRMS editors</h4></div></div></div><p>The BRMS has many GUI editors, and textual editors. This discusses
      a few example rules using some of the GUI features:</p><div class="figure"><a name="d0e8365"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Examples/BRMS_Guided.png" align="middle" alt="Guided editor"></div></div><p class="title"><b>Figure&nbsp;10.31.&nbsp;Guided editor</b></p></div><br class="figure-break"><p>The above example shows the guided editor in action. This is a
      slightly more complex example, as a few bound variables are used. We are
      binding "$driver" to the Driver fact, and also binding driverId to the
      id field of the driver (which is then used in the SupplementalInfo fact
      - to join the driverId with the actual driver id). Note the use of the
      ruleflow-group to specify what step of the processing this rule applies
      to.</p><div class="figure"><a name="d0e8373"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Examples/BRMS_DSL.png" align="middle" alt="DSL Editor"></div></div><p class="title"><b>Figure&nbsp;10.32.&nbsp;DSL Editor</b></p></div><br class="figure-break"><p>The above shows the editor using a DSL. In this case the "guided
      editor" was used - this is not a text area, but only provides text boxes
      to "fill in the blanks" as specified in the DSL configuration. Note you
      can also use text based DSLs where there is not this restriction.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8381"></a>10.1.15.2.&nbsp;Introduction</h4></div></div></div><p>Insurance, in law and economics, is a form of risk management
      primarily used to hedge against the risk of a contingent loss. Insurance
      is defined as the equitable transfer of the risk of a loss, from one
      entity to another, in exchange for a premium. Insurer, in economics, is
      the company that sells the insurance. Insurance rate is a factor used to
      determine the amount, called the premium, to be charged for a certain
      amount of insurance coverage. Risk management, the practice of
      appraising and controlling risk, has evolved as a discrete field of
      study and practice.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8386"></a>10.1.15.3.&nbsp;The insurance logic</h4></div></div></div><p>If you have a poor driving record, you may need to look into high
      risk auto insurance. Accidents increase these rates as well. If you have
      a low experience for example less than 3 years as a licensed driver,
      insurance companies believe that the chances that you will be involved
      in a traffic accident are higher than someone more expert.</p><p>Who you are also plays a factor. Men are considered more of a risk
      than women. Teens are considered more of a risk than adults as well if
      you have some younger driver in family like your 20 years old son.
      </p><pre class="programlisting">
rule "Young male single driver"
ruleflow-group "risk assessment"
when
 $driver : Driver( genre == Driver.MALE, age &lt; 25, maritalState == Driver.SINGLE )
then 
 $driver.updateInsuranceFactor(1.6);
end

rule "no expert driver"
ruleflow-group "risk assessment"
when
 $driver : Driver ( licenceYears &lt; 3 )
then
 $driver.updateInsuranceFactor(1.2);
end
</pre><p>Extra coverage over glasses, additional car and accessories, like
      your expansive "pimped" sound system will increase your insurance final
      price, not the risk factor. </p><pre class="programlisting">
ruleflow-group "insurancecalcule"
salience 20
when
 not Rejection()
 $driver : Driver ( driverID : id )
 $access : AccessoriesCoverage ( driverId == driverID)
 $policy : Policy( approved == true )
then
 $policy.setInsurancePrice( $policy.getInsurancePrice() + 
  ($access.getAlarmSystemValue() * 0.10) + 
  ($access.getArmorValue() * 0.20) +
  ($access.getSoundSystemValue() * 0.30 ));
</pre><p>This example uses the previously explained <span class="bold"><strong>RuleFlow</strong></span> feature, the following diagram gives you
      an overview of the insurance factor and calculate logic: As you can see,
      we first calculate the insurance factor, if the driver matches with some
      rejection condition we don't execute the group that contains the Policy
      price calculus, just returning and not approved policy </p><p>
          </p><pre class="programlisting">
ruleflow-group "insurancecalcule"
salience 10
when
 not Rejection()
 $driver : Driver(ifactor : insuranceFactor)
 $policy : Policy( approved == true, bp : basePrice, ip : insurancePrice )
then
 $policy.setInsurancePrice((bp * ifactor) + ip);
</pre><p>
        </p><div class="figure"><a name="d0e8410"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Examples/insurance-ruleflow.png" align="middle" alt="The insurance rule flow"></div></div><p class="title"><b>Figure&nbsp;10.33.&nbsp;The insurance rule flow</b></p></div><p><br class="figure-break"></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8416"></a>10.1.15.4.&nbsp;Downloading and installing the BRMS</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Download the latest version of BRMS from
          http://cruisecontrol.jboss.com/cc/artifacts/jboss-rules</p></li><li><p>Deploy BRMS WAR file into JBoss4.2 AS or JBossWeb, other
          containers can be used as well possibly with some tweaking of
          dependencies (check this url if you using a different application
          server
          http://wiki.jboss.org/wiki/Wiki.jsp?page=JBRMSjsfdependencies).</p></li><li><p>Check you can access and run the BRMS.</p></li><li><p>Check out the demo project from the Drools subversion
          repository
          http://anonsvn.labs.jboss.com/labs/jbossrules/trunk/drools-examples/drools-insurance/</p></li><li><p>Import the demo business rules insurance repository file into
          BRMS, the compressed can be found at "files" folder in the demo
          project. To do this, open the "files" directory, unzip the file
          there locally, and then go to the "Admin" section and "Manage
          import/export" of the BRMS, select the file, and press "Import" -
          follow instructions.</p></li><li><p>Navigate through the BRMS web application to see how things
          are placed and organized and try to create some rules.</p></li><li><p>Go to the "Packages" feature and build the package (you should
          see no errors).</p></li><li><p>Now go to the "Deployment" feature, when you click on the
          package, it will show you one snapshot (which was part of the
          import, you can create more if you like from the previous
          step).</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8444"></a>10.1.15.5.&nbsp;Deploying the insurance example in your application
      server</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Go into your downloaded project and execute </p><pre class="programlisting">mvn clean package</pre></li><li><p>You should see the RuleAgent downloadomg the pre-compiled
          package from brms, if something goes wrong and all tests fails,
          check if the BRMS is up and running and try rebuild the package
          snapshot. </p><pre class="programlisting">Running org.acme.insurance.test.DriverTest
RuleAgent(insuranceconfig) INFO (Wed Sep 18 14:11:44 BRT 2007): Configuring with newInstance=true, secondsToRefresh=30
RuleAgent(insuranceconfig) INFO (Wed Sep 18 14:11:44 BRT 2007): Configuring package provider : URLScanner monitoring URLs:  
                          http://localhost:8080/drools-jbrms/org.drools.brms.JBRMS/package/org.acme.insurance.base/InsuranceDemo

RuleAgent(insuranceconfig) INFO (Wed Sep 18 14:11:45 BRT 2007): Applying changes to the rulebase.
RuleAgent(insuranceconfig) INFO (Wed Sep 18 14:11:45 BRT 2007): Creating a new rulebase as per settings.
RuleAgent(insuranceconfig) INFO (Wed Sep 18 14:11:45 BRT 2007): Adding package called org.acme.insurance.base

... snip ...

Insurance calculate
Insurance Calcule: 0.0
Driver wants non related expenses coverage: 1.05
Driver wants glass coverage: 1.1025
Driver wants extra assistence: 1.1576250000000001
Driver wants an extra Car: 1.2155062500000002
Driver Single Young Male Driver factor: 1.9448100000000004
New Licenced driver 2.333772
approve: 0.0
Policy aproved focusing insurance calcule agenda-group
Insurance calculate
Insurance Calcule: 0.0
Night Vehicle Place: 1.44
Day Vehicle Place: 1.656
approve: 0.0
Policy aproved focusing insurance calcule agenda-group
Insurance calculate
Insurance extra itens percent: 545.0
Insurance Calcule: 545.0
Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.028 sec

Results :
Tests run: 16, Failures: 0, Errors: 0, Skipped: 0
</pre></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8458"></a>10.1.15.6.&nbsp;Running the example from the web page</h4></div></div></div><p>After running and packing you are able to deploy the war into your
      application server, just following the previous instructions for BRMS,
      then point your browser to the example url, that should be something
      like this http://localhost:8080/drools-insurance. Just play around the
      example and change some values and press the execute button, after the
      rules fired the result will be displayed in the bottom of the
      page.</p><div class="figure"><a name="d0e8464"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Examples/insurance-website.png" align="middle" alt="The insurance web page"></div></div><p class="title"><b>Figure&nbsp;10.34.&nbsp;The insurance web page</b></p></div><p><br class="figure-break"></p></div></div></div></div><div xmlns="" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch09s04.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="pt01.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ix01.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">9.4.&nbsp;Quick start guide&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="title.html">Home</a>&nbsp;|&nbsp;<a accesskey="t" href="bk01-toc.html">ToC</a></td><td width="40%" align="right" valign="top">&nbsp;Index</td></tr></table></div></body></html>