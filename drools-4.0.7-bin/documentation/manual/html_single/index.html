<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Drools</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot_6797"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>Drools</h1></div><div><h2 class="subtitle">Drools Documentation</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Mark</span> <span class="surname">Proctor</span></h3></div></div><div><div class="author"><h3 class="author"><span class="firstname">Michael</span> <span class="surname">Neale</span></h3></div></div><div><div class="author"><h3 class="author"><span class="firstname">Michael</span> <span class="surname">Frandsen</span></h3></div></div><div><div class="author"><h3 class="author"><span class="firstname">Sam</span> <span class="surname">Griffith Jr.</span></h3></div></div><div><div class="author"><h3 class="author"><span class="firstname">Edson</span> <span class="surname">Tirelli</span></h3></div></div><div><div class="author"><h3 class="author"><span class="firstname">Fernando</span> <span class="surname">Meyer</span></h3></div></div><div><div class="author"><h3 class="author"><span class="firstname">Kris</span> <span class="surname">Verlaenen</span></h3></div></div><div><p class="releaseinfo">4.0.7</p></div></div><hr></div><div class="toc"><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="part"><a href="#d0e54">I. Reference Manual</a></span></dt><dd><dl><dt><span class="chapter"><a href="#d0e57">1. Drools 4.0 Release Notes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e60">1.1. What is new in Drools 4.0</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e65">1.1.1. Language Expressiveness Enhancements</a></span></dt><dt><span class="section"><a href="#d0e102">1.1.2. Core Engine Enhancements</a></span></dt><dt><span class="section"><a href="#d0e142">1.1.3. IDE Enhancements</a></span></dt><dt><span class="section"><a href="#d0e158">1.1.4. Business Rules Management System - BRMS</a></span></dt><dt><span class="section"><a href="#d0e189">1.1.5. Miscellaneous Enhancements</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e196">1.2. Upgrade tips from Drools 3.0.x to Drools 4.0.x</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e203">1.2.1. API changes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e208">1.2.1.1. Working Memory creation</a></span></dt><dt><span class="section"><a href="#d0e227">1.2.1.2. Working Memory Actions</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e260">1.2.2. Rule Language Changes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e265">1.2.2.1. Working Memory Actions</a></span></dt><dt><span class="section"><a href="#d0e297">1.2.2.2. Primitive support and unboxing</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e319">1.2.3. Drools Update Tool</a></span></dt><dt><span class="section"><a href="#d0e345">1.2.4. DSL Grammars in Drools 4.0</a></span></dt><dt><span class="section"><a href="#d0e362">1.2.5. Rule flow Update for 4.0.2</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e373">2. The Rule Engine</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e376">2.1. What is a Rule Engine?</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e379">2.1.1. Introduction and Background</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e476">2.2. Why use a Rule Engine?</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e497">2.2.1. Advantages of a Rule Engine</a></span></dt><dt><span class="section"><a href="#d0e540">2.2.2. When should you use a Rule Engine?</a></span></dt><dt><span class="section"><a href="#d0e574">2.2.3. When not to use a Rule Engine</a></span></dt><dt><span class="section"><a href="#d0e581">2.2.4. Scripting or Process Engines</a></span></dt><dt><span class="section"><a href="#d0e594">2.2.5. Strong and Loose Coupling</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e599">2.3. Knowledge Representation</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e603">2.3.1. First Order Logic</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e665">2.4. Rete Algorithm</a></span></dt><dt><span class="section"><a href="#d0e738">2.5. The Drools Rule Engine</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e741">2.5.1. Overview</a></span></dt><dt><span class="section"><a href="#d0e766">2.5.2. Authoring</a></span></dt><dt><span class="section"><a href="#d0e848">2.5.3. RuleBase</a></span></dt><dt><span class="section"><a href="#d0e900">2.5.4. WorkingMemory and Stateful/Stateless Sessions</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e913">2.5.4.1. Facts</a></span></dt><dt><span class="section"><a href="#d0e918">2.5.4.2. Insertion</a></span></dt><dt><span class="section"><a href="#d0e934">2.5.4.3. Retraction</a></span></dt><dt><span class="section"><a href="#d0e941">2.5.4.4. Update</a></span></dt><dt><span class="section"><a href="#d0e948">2.5.4.5. Globals</a></span></dt><dt><span class="section"><a href="#d0e961">2.5.4.6. Shadow Facts</a></span></dt><dt><span class="section"><a href="#d0e1032">2.5.4.7. Property Change Listener</a></span></dt><dt><span class="section"><a href="#d0e1043">2.5.4.8. Initial Fact</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1050">2.5.5. StatefulSession</a></span></dt><dt><span class="section"><a href="#d0e1068">2.5.6. Stateless Session</a></span></dt><dt><span class="section"><a href="#d0e1111">2.5.7. Agenda</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1143">2.5.7.1. Conflict Resolution</a></span></dt><dt><span class="section"><a href="#d0e1156">2.5.7.2. Agenda Groups</a></span></dt><dt><span class="section"><a href="#d0e1165">2.5.7.3. Agenda Filters</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1195">2.5.8. Truth Maintenance with  Logical Objects</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1226">2.5.8.1. Example Scenario</a></span></dt><dt><span class="section"><a href="#d0e1237">2.5.8.2. Important note: Equality for Java objects</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1244">2.5.9. Event Model</a></span></dt><dt><span class="section"><a href="#d0e1295">2.5.10. Sequential Mode</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e1334">3. Installation and Setup (Core and IDE)</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1337">3.1. Installing and using</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1349">3.1.1. Dependencies and jars</a></span></dt><dt><span class="section"><a href="#d0e1375">3.1.2. Runtime</a></span></dt><dt><span class="section"><a href="#d0e1380">3.1.3. Installing IDE (Rule Workbench)</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1387">3.1.3.1. Installing GEF (a required dependency)</a></span></dt><dt><span class="section"><a href="#d0e1412">3.1.3.2. Installing from zip file</a></span></dt><dt><span class="section"><a href="#d0e1417">3.1.3.3. Installing from the update site</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#d0e1509">3.2. Setup from source</a></span></dt><dt><span class="section"><a href="#d0e1568">3.3. Source Checkout</a></span></dt><dt><span class="section"><a href="#d0e1619">3.4. Build</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1622">3.4.1. Building the Source</a></span></dt><dt><span class="section"><a href="#d0e1654">3.4.2. Building the Manual</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1726">3.5. Eclipse</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1729">3.5.1. Generating Eclipse Projects</a></span></dt><dt><span class="section"><a href="#d0e1758">3.5.2. Importing Eclipse Projects</a></span></dt><dt><span class="section"><a href="#d0e1820">3.5.3. Exporting the IDE Plugin</a></span></dt><dt><span class="section"><a href="#d0e1877">3.5.4. Building the update site</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e1896">4. Decision Tables</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1899">4.1. Decision tables in spreadsheets</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1908">4.1.1. When to use Decision tables</a></span></dt><dt><span class="section"><a href="#d0e1917">4.1.2. Overview</a></span></dt><dt><span class="section"><a href="#d0e1952">4.1.3. How decision tables work</a></span></dt><dt><span class="section"><a href="#d0e1988">4.1.4. Keywords and syntax</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1991">4.1.4.1. Syntax of templates</a></span></dt><dt><span class="section"><a href="#d0e2031">4.1.4.2. Keywords</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2166">4.1.5. Creating and integrating Spreadsheet based Decision Tables</a></span></dt><dt><span class="section"><a href="#d0e2179">4.1.6. Managing business rules in decision tables.</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2182">4.1.6.1. Workflow and collaboration.</a></span></dt><dt><span class="section"><a href="#d0e2211">4.1.6.2. Using spreadsheet features</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e2224">5. The (Eclipse based) Rule IDE</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2227">5.1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2244">5.1.1. Features outline</a></span></dt><dt><span class="section"><a href="#d0e2297">5.1.2. Creating a Rule project</a></span></dt><dt><span class="section"><a href="#d0e2320">5.1.3. Creating a new rule and wizards</a></span></dt><dt><span class="section"><a href="#d0e2341">5.1.4. Textual rule editor</a></span></dt><dt><span class="section"><a href="#d0e2364">5.1.5. Guided editor (rule GUI)</a></span></dt><dt><span class="section"><a href="#d0e2381">5.1.6. Views</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2398">5.1.6.1. The Working Memory View</a></span></dt><dt><span class="section"><a href="#d0e2412">5.1.6.2. The Agenda View</a></span></dt><dt><span class="section"><a href="#d0e2426">5.1.6.3. The Global Data View</a></span></dt><dt><span class="section"><a href="#d0e2440">5.1.6.4. The Audit View</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2494">5.1.7. Domain Specific Languages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2501">5.1.7.1. Editing languages</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2522">5.1.8. The Rete View</a></span></dt><dt><span class="section"><a href="#d0e2543">5.1.9. Large drl files</a></span></dt><dt><span class="section"><a href="#d0e2558">5.1.10. Debugging rules</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2569">5.1.10.1. Creating breakpoints</a></span></dt><dt><span class="section"><a href="#d0e2583">5.1.10.2. Debugging rules</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e2622">6. The Rule Language</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2625">6.1. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2634">6.1.1. A rule file</a></span></dt><dt><span class="section"><a href="#d0e2667">6.1.2. What makes a rule</a></span></dt><dt><span class="section"><a href="#d0e2700">6.1.3. Reserved words</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2842">6.2. Comments</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2851">6.2.1. Single line comment</a></span></dt><dt><span class="section"><a href="#d0e2866">6.2.2. Multi line comment</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2881">6.3. Package</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2902">6.3.1. import</a></span></dt><dt><span class="section"><a href="#d0e2915">6.3.2. expander</a></span></dt><dt><span class="section"><a href="#d0e2928">6.3.3. global</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2964">6.4. Function</a></span></dt><dt><span class="section"><a href="#d0e2995">6.5. Rule</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3024">6.5.1. Rule Attributes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3037">6.5.1.1. no-loop</a></span></dt><dt><span class="section"><a href="#d0e3046">6.5.1.2. lock-on-active</a></span></dt><dt><span class="section"><a href="#d0e3055">6.5.1.3. salience</a></span></dt><dt><span class="section"><a href="#d0e3064">6.5.1.4. agenda-group</a></span></dt><dt><span class="section"><a href="#d0e3073">6.5.1.5. auto-focus</a></span></dt><dt><span class="section"><a href="#d0e3088">6.5.1.6. activation-group</a></span></dt><dt><span class="section"><a href="#d0e3099">6.5.1.7. dialect</a></span></dt><dt><span class="section"><a href="#d0e3110">6.5.1.8. date-effective</a></span></dt><dt><span class="section"><a href="#d0e3119">6.5.1.9. date-exptires</a></span></dt><dt><span class="section"><a href="#d0e3128">6.5.1.10. duration</a></span></dt></dl></dd><dt><span class="section"><a href="#RuleLanguage-ConditionalElements">6.5.2. Left Hand Side (when) Conditional Elements</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3166">6.5.2.1. Pattern</a></span></dt><dt><span class="section"><a href="#d0e3700">6.5.2.2. 'and'</a></span></dt><dt><span class="section"><a href="#d0e3739">6.5.2.3. 'or'</a></span></dt><dt><span class="section"><a href="#d0e3787">6.5.2.4. 'eval'</a></span></dt><dt><span class="section"><a href="#d0e3809">6.5.2.5. 'not'</a></span></dt><dt><span class="section"><a href="#d0e3834">6.5.2.6. 'exists'</a></span></dt><dt><span class="section"><a href="#d0e3859">6.5.2.7. 'forall'</a></span></dt><dt><span class="section"><a href="#d0e3926">6.5.2.8. From</a></span></dt><dt><span class="section"><a href="#d0e3968">6.5.2.9. 'collect'</a></span></dt><dt><span class="section"><a href="#d0e4013">6.5.2.10. 'accumulate'</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4182">6.5.3. The Right Hand Side (then)</a></span></dt><dt><span class="section"><a href="#d0e4199">6.5.4. A note on auto boxing/unboxing and primitive types</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4204">6.6. Query</a></span></dt><dt><span class="section"><a href="#d0e4238">6.7. Domain Specific Languages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4249">6.7.1. When to use a DSL</a></span></dt><dt><span class="section"><a href="#d0e4258">6.7.2. Editing and managing a DSL</a></span></dt><dt><span class="section"><a href="#d0e4310">6.7.3. Using a DSL in your rules</a></span></dt><dt><span class="section"><a href="#d0e4334">6.7.4. Adding constraints to facts</a></span></dt><dt><span class="section"><a href="#d0e4367">6.7.5. How it works</a></span></dt><dt><span class="section"><a href="#d0e4376">6.7.6. Creating a DSL from scratch</a></span></dt><dt><span class="section"><a href="#d0e4404">6.7.7. Scope and keywords</a></span></dt><dt><span class="section"><a href="#d0e4409">6.7.8. DSLs in the BRMS and IDE</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4418">6.8. Rule Flow</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4433">6.8.1. Assigning rules to a ruleflow group</a></span></dt><dt><span class="section"><a href="#d0e4440">6.8.2. A simple ruleflow</a></span></dt><dt><span class="section"><a href="#d0e4451">6.8.3. How to build a rule flow</a></span></dt><dt><span class="section"><a href="#d0e4522">6.8.4. Using a rule flow in your application</a></span></dt><dt><span class="section"><a href="#d0e4542">6.8.5. Different types of nodes in a ruleflow</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4611">6.9. XML Rule Language</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4620">6.9.1. When to use XML</a></span></dt><dt><span class="section"><a href="#d0e4631">6.9.2. The XML format</a></span></dt><dt><span class="section"><a href="#d0e4670">6.9.3. Legacy Drools 2.x XML rule format</a></span></dt><dt><span class="section"><a href="#d0e4675">6.9.4. Automatic transforming between formats (XML and DRL)</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e4688">7. Deployment and Testing</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4691">7.1. Deployment options</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4700">7.1.1. Deployment using the RuleAgent</a></span></dt><dt><span class="section"><a href="#d0e4719">7.1.2. Deployment using drl source</a></span></dt><dt><span class="section"><a href="#d0e4724">7.1.3. Deploying rules in your classpath</a></span></dt><dt><span class="section"><a href="#d0e4731">7.1.4. Deployable objects, RuleBase, Package etc.</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4738">7.1.4.1. DRL and PackageDescr</a></span></dt><dt><span class="section"><a href="#d0e4745">7.1.4.2. Package</a></span></dt><dt><span class="section"><a href="#d0e4754">7.1.4.3. RuleBase</a></span></dt><dt><span class="section"><a href="#d0e4761">7.1.4.4. Serializing</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4768">7.1.5. Deployment patterns</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4771">7.1.5.1. In process rule building</a></span></dt><dt><span class="section"><a href="#d0e4776">7.1.5.2. Out of process rule building</a></span></dt><dt><span class="section"><a href="#d0e4783">7.1.5.3. Some deployment scenarios</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4808">7.1.6. Web Services</a></span></dt><dt><span class="section"><a href="#d0e4813">7.1.7. Future considerations</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4818">7.2. Testing</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4825">7.2.1. Testing frameworks</a></span></dt><dt><span class="section"><a href="#d0e4832">7.2.2. FIT for Rules - a rule testing framework</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e4866">8. The Java Rule Engine API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4869">8.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e4884">8.2. How To Use</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4889">8.2.1. Building and Registering RuleExecutionSets</a></span></dt><dt><span class="section"><a href="#d0e4922">8.2.2. Using Stateful and Stateless RuleSessions</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4946">8.2.2.1. Globals</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#d0e4957">8.3. References</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e5003">9. The BRMS (Business Rule Management System)</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5006">9.1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5017">9.1.1. What is a BRMS?</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5026">9.1.1.1. When to use a BRMS</a></span></dt><dt><span class="section"><a href="#d0e5044">9.1.1.2. Who uses a BRMS</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5051">9.1.2. Features outline</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5070">9.2. Administration guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5077">9.2.1. Installation</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5088">9.2.1.1. Supported and recommended platforms</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5112">9.2.2. Database configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5117">9.2.2.1. Changing the location of the data store</a></span></dt><dt><span class="section"><a href="#d0e5136">9.2.2.2. Configuring the BRMS to use an external RDBMS</a></span></dt><dt><span class="section"><a href="#d0e5147">9.2.2.3. Searching and indexing, Version storage</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5154">9.2.3. Security</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5171">9.2.3.1. Using your containers security and LDAP</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5190">9.2.4. Data management</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5193">9.2.4.1. Backups</a></span></dt><dt><span class="section"><a href="#d0e5202">9.2.4.2. Asset list customization</a></span></dt><dt><span class="section"><a href="#d0e5207">9.2.4.3. Customised selectors for package building</a></span></dt><dt><span class="section"><a href="#d0e5214">9.2.4.4. Adding your own logos or styles to the BRMS web GUI</a></span></dt><dt><span class="section"><a href="#d0e5227">9.2.4.5. Import and Export</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#d0e5238">9.3. Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5255">9.3.1. Building from source</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5260">9.3.1.1. Modules</a></span></dt><dt><span class="section"><a href="#d0e5265">9.3.1.2. Working with Maven 2</a></span></dt><dt><span class="section"><a href="#d0e5274">9.3.1.3. Working with GWT</a></span></dt><dt><span class="section"><a href="#d0e5279">9.3.1.4. Debugging, Editing and running with Eclipse</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5292">9.3.2. Re-usable components</a></span></dt><dt><span class="section"><a href="#d0e5307">9.3.3. Versioning and Storage</a></span></dt><dt><span class="section"><a href="#d0e5318">9.3.4. Contributing</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5323">9.4. Quick start guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5326">9.4.1. Quick start guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5355">9.4.1.1. Supported browser platforms</a></span></dt><dt><span class="section"><a href="#d0e5362">9.4.1.2. Initial configuration</a></span></dt><dt><span class="section"><a href="#d0e5390">9.4.1.3. Writing some rules</a></span></dt><dt><span class="section"><a href="#d0e5418">9.4.1.4. Finding stuff</a></span></dt><dt><span class="section"><a href="#d0e5423">9.4.1.5. Deployment</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5436">9.4.2. BRMS concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5439">9.4.2.1. Rules are assets</a></span></dt><dt><span class="section"><a href="#d0e5444">9.4.2.2. Categorisation</a></span></dt><dt><span class="section"><a href="#d0e5479">9.4.2.3. The asset editor</a></span></dt><dt><span class="section"><a href="#d0e5545">9.4.2.4. Rule authoring</a></span></dt><dt><span class="section"><a href="#d0e5718">9.4.2.5. Templates of assets/rules</a></span></dt><dt><span class="section"><a href="#d0e5723">9.4.2.6. Status management</a></span></dt><dt><span class="section"><a href="#d0e5746">9.4.2.7. Package management</a></span></dt><dt><span class="section"><a href="#d0e5814">9.4.2.8. Version management</a></span></dt><dt><span class="section"><a href="#d0e5827">9.4.2.9. Deployment management</a></span></dt><dt><span class="section"><a href="#d0e5846">9.4.2.10. Navigating and finding rules</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5871">9.4.3. The business user perspective</a></span></dt><dt><span class="section"><a href="#d0e5884">9.4.4. Deployment: Integrating rules with your applications</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5889">9.4.4.1. The Rule Agent</a></span></dt><dt><span class="section"><a href="#d0e5968">9.4.4.2. Manual deployment</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e5978">10. Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5981">10.1. Getting the examples</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5986">10.1.1. Hello World</a></span></dt><dt><span class="section"><a href="#d0e6150">10.1.2. State Example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6155">10.1.2.1. Understanding the State Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6323">10.1.3. Banking Tutorial</a></span></dt><dt><span class="section"><a href="#d0e6524">10.1.4. Fibonacci Example</a></span></dt><dt><span class="section"><a href="#d0e6637">10.1.5. Golfing Example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6658">10.1.5.1. The riddle</a></span></dt><dt><span class="section"><a href="#d0e6686">10.1.5.2. Launching the example</a></span></dt><dt><span class="section"><a href="#d0e6701">10.1.5.3. The matching rule</a></span></dt><dt><span class="section"><a href="#d0e6730">10.1.5.4. Conclustion</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6737">10.1.6. Trouble Ticket</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6764">10.1.6.1. Executing the Example</a></span></dt><dt><span class="section"><a href="#d0e6802">10.1.6.2. Platinum gets the best service</a></span></dt><dt><span class="section"><a href="#d0e6811">10.1.6.3. Silver and Gold</a></span></dt><dt><span class="section"><a href="#d0e6820">10.1.6.4. Escalating</a></span></dt><dt><span class="section"><a href="#d0e6831">10.1.6.5. Running it</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6854">10.1.7. Pricing Rule Decision Table Example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6875">10.1.7.1. Executing the example</a></span></dt><dt><span class="section"><a href="#d0e6890">10.1.7.2. The decision table</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6925">10.1.8. Shopping Example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6946">10.1.8.1. Running the example</a></span></dt><dt><span class="section"><a href="#d0e6959">10.1.8.2. Discounts and purchases</a></span></dt><dt><span class="section"><a href="#d0e6968">10.1.8.3. Calculating the discount</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6979">10.1.9. </a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6980">10.1.9.1. Pet Store Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7522">10.1.10. Honest Politician Example</a></span></dt><dt><span class="section"><a href="#d0e7583">10.1.11. Sudoku Example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7604">10.1.11.1. Sudoku Overview</a></span></dt><dt><span class="section"><a href="#d0e7618">10.1.11.2. Running the Example</a></span></dt><dt><span class="section"><a href="#d0e7698">10.1.11.3. Java Source and Rules Overview</a></span></dt><dt><span class="section"><a href="#d0e7711">10.1.11.4. Sudoku Validator Rules (validatorSudoku.drl)</a></span></dt><dt><span class="section"><a href="#d0e7720">10.1.11.5. Sudoku Solving Rules (solverSudoku.drl)</a></span></dt><dt><span class="section"><a href="#d0e7743">10.1.11.6. Suggestions for Future Developments</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7776">10.1.12. </a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7777">10.1.12.1. Number Guess</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7985">10.1.13. Miss Manners and Benchmarking</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8004">10.1.13.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e8093">10.1.13.2. Indepth look</a></span></dt><dt><span class="section"><a href="#d0e8194">10.1.13.3. Output Summary</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8249">10.1.14. Conways Game Of Life Example</a></span></dt><dt><span class="section"><a href="#d0e8344">10.1.15. Insurance Company Risk Factor and Policy price (using BRMS)</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8360">10.1.15.1. BRMS editors</a></span></dt><dt><span class="section"><a href="#d0e8381">10.1.15.2. Introduction</a></span></dt><dt><span class="section"><a href="#d0e8386">10.1.15.3. The insurance logic</a></span></dt><dt><span class="section"><a href="#d0e8416">10.1.15.4. Downloading and installing the BRMS</a></span></dt><dt><span class="section"><a href="#d0e8444">10.1.15.5. Deploying the insurance example in your application
      server</a></span></dt><dt><span class="section"><a href="#d0e8458">10.1.15.6. Running the example from the web page</a></span></dt></dl></dd></dl></dd></dl></dd></dl></dd><dt><span class="index"><a href="#d0e8471">Index</a></span></dt></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div></div><div class="mediaobject"><img src="../shared/images/drools_logo.png"></div><p></p></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e54"></a>Part&nbsp;I.&nbsp;Reference Manual</h1></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e57"></a>Chapter&nbsp;1.&nbsp;Drools 4.0 Release Notes</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e60"></a>1.1.&nbsp;What is new in Drools 4.0</h2></div></div></div><p>Drools 4.0 is a major update over the previous Drools 3.0.x series. A
  whole new set of features were developed which special focus on language
  expressiveness, engine performance and tools availability. The following is
  a list of the most interesting changes.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e65"></a>1.1.1.&nbsp;Language Expressiveness Enhancements</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>New Conditional Elements: from, collect, accumulate and
        forall</p></li><li><p>New Field Constraint operators: not matches, not contains, in,
        not in, memberOf, not memberOf</p></li><li><p>New Implicit Self Reference field: this</p></li><li><p>Full support for Conditional Elements nesting, for First Order
        Logic completeness.</p></li><li><p>Support for multi-restrictions and constraint connectives
        &amp;&amp; and ||</p></li><li><p>Parser improvements to remove previous language limitations,
        like character escaping and keyword conflicts</p></li><li><p>Support for pluggable dialects and full support for MVEL
        scripting language</p></li><li><p>Complete rewrite of DSL engine, allowing for full l10n</p></li><li><p>Fact attributes auto-vivification for return value restrictions
        and inline-eval constraints</p></li><li><p>Support for nested accessors, property navigation and simplified
        collection, arrays and maps syntax</p></li><li><p>Improved support for XML rules</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e102"></a>1.1.2.&nbsp;Core Engine Enhancements</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Native support for primitive types, avoiding constant
        autoboxing</p></li><li><p>Support for transparent optional Shadow Facts</p></li><li><p>Rete Network performance improvements for complex rules</p></li><li><p>Support for Rule-Flows</p></li><li><p>Support for Stateful and Stateless working memories (rule engine
        sessions)</p></li><li><p>Support for Asynchronous Working Memory actions</p></li><li><p>Rules Engine Agent for hot deployment and BRMS
        integration</p></li><li><p>Dynamic salience for rules conflict resolution</p></li><li><p>Support for Parameterized Queries</p></li><li><p>Support for halt command</p></li><li><p>Support for sequential execution mode</p></li><li><p>Support for pluggable global variable resolver</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e142"></a>1.1.3.&nbsp;IDE Enhancements</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Support for rule break-points on debugging</p></li><li><p>WYSIWYG support for rule-flows</p></li><li><p>New guided editor for rules authoring</p></li><li><p>Upgrade to support all new engine features</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e158"></a>1.1.4.&nbsp;Business Rules Management System - BRMS</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>New BRMS tool</p></li><li><p>User friendly web interface with nice WEB 2.0 ajax
        features</p></li><li><p>Package configuration</p></li><li><p>Rule Authoring easy to edit rules both with guided editor (
        drop-down menus ) and text editor</p></li><li><p>Package compilation and deployment</p></li><li><p>Easy deployment with Rule Agent</p></li><li><p>Easy to organize with categories and search assets</p></li><li><p>Versioning enabled, you can easily replace yours assets with
        previously saved</p></li><li><p>JCR compliant rule assets repository</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e189"></a>1.1.5.&nbsp;Miscellaneous Enhancements</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Slimmed down dependencies and smaller memory footprint</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e196"></a>1.2.&nbsp;Upgrade tips from Drools 3.0.x to Drools 4.0.x</h2></div></div></div><p>As mentioned before Drools 4.0 is a major update over the previous
  Drools 3.0.x series. Unfortunately, in order to achieve the goals set for
  this release, some backward compatibility issues were introduced, as
  discussed in the mail list and blogs.</p><p>This section of the manual is a work in progress and will document a
  simple how-to on upgrading from Drools 3.0.x to Drools 4.0.x.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e203"></a>1.2.1.&nbsp;API changes</h3></div></div></div><p>There are a few API changes that are visible to regular users and
    need to be fixed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e208"></a>1.2.1.1.&nbsp;Working Memory creation</h4></div></div></div><p>Drools 3.0.x had only one working memory type that worked like a
      stateful working memory. Drools 4.0.x introduces separate APIs for
      Stateful and Stateless working memories that are called now Rule
      Sessions. In Drools 3.0.x, the code to create a working memory
      was:</p><div class="example"><a name="d0e214"></a><p class="title"><b>Example&nbsp;1.1.&nbsp;Drools 3.0.x: Working Memory Creation</b></p><div class="example-contents"><pre class="programlisting">WorkingMemory wm = rulebase.newWorkingMemory();</pre></div></div><p><br class="example-break">In Drools 4.0.x it must be changed to:</p><div class="example"><a name="d0e221"></a><p class="title"><b>Example&nbsp;1.2.&nbsp;Drools 4.0.x: Stateful Rule Session Creation</b></p><div class="example-contents"><pre class="programlisting">StatefulSession wm = rulebase.newStatefulSession();</pre></div></div><p><br class="example-break">The StatefulSession object has the same behavior as the
      Drools 3.0.x WorkingMemory (it even extends the WorkingMemory
      interface), so there should be no other problems with this fix.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e227"></a>1.2.1.2.&nbsp;Working Memory Actions</h4></div></div></div><p>Drools 4.0.x now supports pluggable dialects and has built-in
      support for Java and MVEL scripting language. In order to avoid keyword
      conflicts, the working memory actions were renamed as showed
      bellow:</p><p></p><div class="table"><a name="d0e233"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;Working Memory Actions equivalent API methods</b></p><div class="table-contents"><table summary="Working Memory Actions equivalent API methods" border="1"><colgroup><col><col></colgroup><tbody><tr><td><span class="bold"><strong>Drools 3.0.x</strong></span></td><td><span class="bold"><strong>Drools 4.0.x</strong></span></td></tr><tr><td>WorkingMemory.assertObject()</td><td>WorkingMemory.insert()</td></tr><tr><td>WorkingMemory.assertLogicalObject()</td><td>WorkingMemory.insertLogical()</td></tr><tr><td>WorkingMemory.modifyObject()</td><td>WorkingMemory.update()</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e260"></a>1.2.2.&nbsp;Rule Language Changes</h3></div></div></div><p>The DRL Rule Language also has some backward incompatible changes as
    detailed bellow.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e265"></a>1.2.2.1.&nbsp;Working Memory Actions</h4></div></div></div><p>The Working Memory actions in rule consequences were also changed
      in a similar way to the change made in the API. The following table
      summarizes the change:</p><div class="table"><a name="d0e270"></a><p class="title"><b>Table&nbsp;1.2.&nbsp;Working Memory Actions equivalent DRL commands</b></p><div class="table-contents"><table summary="Working Memory Actions equivalent DRL commands" border="1"><colgroup><col><col></colgroup><tbody><tr><td><span class="bold"><strong>Drools 3.0.x</strong></span></td><td><span class="bold"><strong>Drools 4.0.x</strong></span></td></tr><tr><td>assert()</td><td>insert()</td></tr><tr><td>assertLogical()</td><td>insertLogical()</td></tr><tr><td>modify()</td><td>update()</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e297"></a>1.2.2.2.&nbsp;Primitive support and unboxing</h4></div></div></div><p>Drools 3.0.x did not had native support for primitive types and
      consequently, it auto-boxed all primitives in it's respective wrapper
      classes. That way, any use of a boxed variable binding required a manual
      unbox.</p><p>Drools 4.0.x has full support for primitive types and does not
      wrap values anymore. So, all previous unwrap method calls must be
      removed from the DRL.</p><div class="example"><a name="d0e304"></a><p class="title"><b>Example&nbsp;1.3.&nbsp;Drools 3.0.x manual unwrap</b></p><div class="example-contents"><pre class="programlisting">rule "Primitive int manual unbox"
when
    $c : Cheese( $price : price )
then
    $c.setPrice( $price<span class="bold"><strong>.intValue()</strong></span> * 2 )
end
</pre></div></div><br class="example-break"><p>The above rule in 4.0.x would be:</p><div class="example"><a name="d0e314"></a><p class="title"><b>Example&nbsp;1.4.&nbsp;Drools 4.0.x primitive support</b></p><div class="example-contents"><pre class="programlisting">rule "Primitive support"
when
    $c : Cheese( $price : price )
then
    $c.setPrice( $price * 2 )
end
</pre></div></div><br class="example-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e319"></a>1.2.3.&nbsp;Drools Update Tool</h3></div></div></div><p>The Drools Update tools is a simple program to help with the upgrade
    of DRL files from Drools 3.0.x to Drools 4.0.x.</p><p>At this point, its main objective is to upgrade the memory action
    calls from 3.0.x to 4.0.x, but expect it to grow over the next few weeks
    covering additional scenarios. It is important to note that it does not
    make a dumb text search and replace in rules file, but it actually parses
    the rules file and try to make sure it is not doing anything unexpected,
    and as so, it is a safe tool to use for upgrade large sets of rule
    files.</p><p>The drools update tool can be found as a maven project in the
    following source repository
    http://anonsvn.labs.jboss.com/labs/jbossrules/trunk/experimental/drools-update/
    you just need to check it out, and execute the maven clean install action
    with the project's pom.xml file. After resolve all the class path
    dependencies you are able to run the toll with the following
    command:</p><pre class="programlisting">java -cp $CLASSPATH org.drools.tools.update.UpdateTool -f &lt;filemask&gt; [-d &lt;basedir&gt;] [-s &lt;sufix&gt;]</pre><p>The program parameters are very easy to understand as following.
    </p><div class="itemizedlist"><ul type="disc"><li><p>-h,--help, Shows a very simple list the usage help</p></li><li><p>-d your source base directory</p></li><li><p>-f pattern for the files to be updated. The format is the same
          as used by ANT: * = single file, directory ** = any level of
          subdirectories EXAMPLE: src/main/resources/**/*.drl = matches all
          DRL files inside any subdirectory of /src/main/resources</p></li><li><p>-s,--sufix the sufix to be added to all updated files</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e345"></a>1.2.4.&nbsp;DSL Grammars in Drools 4.0</h3></div></div></div><p>It is important to note that the DSL template engine was rewritten
    from scratch to improve flexibility. One of the new features of DSL
    grammars is the support to Regular Expressions. This way, now you can
    write your mappings using regexp to have additional flexibility, as
    explained in the DSL chapter. Although, now you have to escape characters
    with regexp meaning. Example: if previously you had a matching
    like:</p><div class="example"><a name="d0e350"></a><p class="title"><b>Example&nbsp;1.5.&nbsp;Drools 3.0.x mapping</b></p><div class="example-contents"><pre class="programlisting">[when][]- the {attr} is in [ {values} ]={attr} in ( {values} )</pre></div></div><br class="example-break"><p>Now, you need to escape '[' and ']' characters, as they have special
    meaning in regexps. So, the same mapping in Drools 4.0 would be:</p><div class="example"><a name="d0e357"></a><p class="title"><b>Example&nbsp;1.6.&nbsp;Drools 4.0.x mapping with escaped characters</b></p><div class="example-contents"><pre class="programlisting">[when][]- the {attr} is in \[ {values} \]={attr} in ( {values} )</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e362"></a>1.2.5.&nbsp;Rule flow Update for 4.0.2</h3></div></div></div><p>
    	The Rule flow feature was updated for 4.0.2, and now all your ruleflows must decalre a package name.
    </p><div class="figure"><a name="d0e367"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Release_Notes/ruleflowproperties.png" align="middle" alt="Rule Flow properties"></div></div><p class="title"><b>Figure&nbsp;1.1.&nbsp;Rule Flow properties</b></p></div><br class="figure-break"></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e373"></a>Chapter&nbsp;2.&nbsp;The Rule Engine</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e376"></a>2.1.&nbsp;What is a Rule Engine?</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e379"></a>2.1.1.&nbsp;Introduction and Background</h3></div></div></div><p>Artificial Intelligence (A.I.) is a very broad research area that
    focuses on "Making computers think like people" and includes disciplines
    such as Neural Networks, Genetic Algorithms, Decision Trees, Frame Systems
    and Expert Systems. Knowledge representation is the area of A.I. concerned
    with how knowledge is represented and manipulated. Expert Systems use
    Knowledge representation to facilitate the codification of knowledge into
    a knowledge base which can be used for reasoning - i.e. we can process
    data with this knowledge base to infer conclusions. Expert Systems are
    also known as Knowledge-based Systems and Knowledge-based Expert Systems
    and are considered 'applied artificial intelligence'. The process of
    developing with an Expert System is Knowledge Engineering. EMYCIN was one
    of the first "shells" for an Expert System, which was created from the
    MYCIN medical diagnosis Expert System. Where-as early Expert Systems had
    their logic hard coded, "shells" separated the logic from the system,
    providing an easy to use environment for user input. Drools is a Rule
    Engine that uses the Rule Based approached to implement an Expert System
    and is more correctly classified as a Production Rule System.</p><p>The term "Production Rule" originates from formal grammar - where it
    is described as "an abstract structure that describes a formal language
    precisely, i.e., a set of rules that mathematically delineates a (usually
    infinite) set of finite-length strings over a (usually finite) alphabet"
    (<a class="ulink" href="http://en.wikipedia.org/wiki/Formal_grammar" target="_top">wikipedia</a>).</p><p>Business Rule Management Systems build additional value on top of a
    general purpose Rule Engines by providing, business user focused, systems
    for rule creation, management, deployment, collaboration, analysis and end
    user tools. Further adding to this value is the fast evolving and popular
    methodology "Business Rules Approach", which is a helping to formalize the
    role of Rule Engines in the enterprise.</p><p>The term Rule Engine is quite ambiguous in that it can be any system
    that uses rules, in any form, that can be applied to data to produce
    outcomes; which includes simple systems like form validation and dynamic
    expression engines. The book "How to Build a Business Rules Engine (2004)"
    by Malcolm Chisholm exemplifies this ambiguity. The book is actually about
    how to build and alter a database schema to hold validation rules. The
    book then shows how to generate VB code from those validation rules to
    validate data entry - while a very valid and useful topic for some, it
    caused quite a surprise to this author, unaware at the time in the
    subtleties of Rules Engines differences, who was hoping to find some
    hidden secrets to help improve the Drools engine. JBoss jBPM uses
    expressions and delegates in its Decision nodes; which control the
    transitions in a Workflow. At each node it evaluates has a rule set that
    dictates the transition to undertake - this is also a Rule Engine. While a
    Production Rule System is a kind of Rule Engine and also an Expert System,
    the validation and expression evaluation Rule Engines mention previously
    are not Expert Systems.</p><p>A Production Rule System is turing complete with a focus on
    knowledge representation to express propositional and first order logic in
    a concise, non ambiguous and declarative manner. The brain of a Production
    Rules System is an Inference Engine that is able to scale to a large
    number of rules and facts. The Inference Engine matches facts and data,
    against Production Rules, also called Productions or just Rules, to infer
    conclusions which result in actions. A Production Rule is a two-part
    structure using First Order Logic for knowledge representation.</p><pre class="programlisting">when
    &lt;conditions&gt;
then
    &lt;actions&gt;</pre><p>The process of matching the new or existing facts against Production
    Rules is called <a class="indexterm" name="d0e399"></a> Pattern Matching, which is performed by the <a class="indexterm" name="d0e403"></a> Inference Engine. There are a number of algorithms used for
    Pattern Matching by Inference Engines including:</p><div class="itemizedlist"><ul type="disc"><li><p>Linear</p></li><li><p>Rete</p></li><li><p>Treat</p></li><li><p>Leaps</p></li></ul></div><p>Drools implements and extends the <a class="indexterm" name="d0e422"></a> Rete algorith, <a class="indexterm" name="d0e426"></a> Leaps use to be supported but was removed due to poor
    maintenance. The Drools <a class="indexterm" name="d0e430"></a> Rete implementation is called ReteOO, signifying that
    Drools has an enhanced and optimized implementation of the Rete algorithm
    for Object Oriented systems. Other Rete based engines also have marketing
    terms for their proprietary enhancements to Rete, like RetePlus and Rete
    III. It is important to understand that names like Rete III are purely
    marketing where, unlike the original published Rete Algorithm, no details
    of the implementation are published. This makes questions such as "Does
    Drools implement Rete III?" nonsensical. The most common enhancements are
    covered in "Production Matching for Large Learning Systems (Rete/UL)"
    (1995) by Robert B. Doorenbos.</p><p>The Rules are stored in the <a class="indexterm" name="d0e436"></a> Production Memory and the facts that the Inference Engine
    matches against the <a class="indexterm" name="d0e440"></a> Working Memory. Facts are asserted into the Working Memory
    where they may then be modified or retracted. A system with a large number
    of rules and facts may result in many rules being true for the same fact
    assertion, these rules are said to be in conflict. The Agenda manages the
    execution order of these conflicuting rules using a Conflict Resolution
    strategy.</p><div class="figure"><a name="d0e444"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/Rule_Engine.png" align="middle" alt="A Basic Rete network"></div></div><p class="title"><b>Figure&nbsp;2.1.&nbsp;A Basic Rete network</b></p></div><br class="figure-break"><p>A Production Rule System's Inference Engine is stateful and able to
    enforce truthfulness - called Truth Maintence. A logical relationship can
    be declared by actions which means the action's state depends on the
    inference remaining true; when it is no longer true the logical dependent
    action is undone. The "Honest Politician" is an example of Truth
    Maintenance, which always ensures that hope can only exist for a
    democracy while we have honest politicians.</p><pre class="programlisting">
when
    an honest Politician exists
then
    logically assert Hope

when
   Hope exists
then
   print "Hurrah!!! Democracy Lives" 

when
   Hope does not exist
then
   print "Democracy is Doomed" 
</pre><p>There are two methods of execution for a Production Rule Systems -
    Forward Chaining and Backward Chaining; systems that implement both are
    called Hybrid Production Rule Systems. Understanding these two modes of
    operation are key to understanding why a Production Rule System is
    different and how to get the best from them. Forward chaing is
    'data-driven' and thus reactionary - facts are asserted into the working
    memory which results in one or more rules being concurrently true and
    scheduled for execution by the Agenda - we start with a fact, it
    propagates and we end in a conclusion. Drools is a forward chaining
    engine.</p><div class="figure"><a name="d0e458"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/Forward_Chaining.png" align="middle" alt="Forward Chaining"></div></div><p class="title"><b>Figure&nbsp;2.2.&nbsp;Forward Chaining</b></p></div><br class="figure-break"><p>Backward chaining is 'goal-driven', meaning that we start with a
    conclusion which the engine tries to satisfy. If it can't it then searches
    for conclusions that it can, known as 'sub goals', that will help satisfy
    some unknown part of the current goal - it continues this process until
    either the initial conclusion is proven or there are no more sub goals.
    Prolog is an example of a Backward Chaining engine; Drools will be adding
    support for Backward Chaining in its next major release.</p><div class="figure"><a name="d0e468"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/Backward_Chaining.png" align="middle" alt="Backward Chaining"></div></div><p class="title"><b>Figure&nbsp;2.3.&nbsp;Backward Chaining</b></p></div><br class="figure-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e476"></a>2.2.&nbsp;Why use a Rule Engine?</h2></div></div></div><p>Some frequently asked questions:</p><div class="orderedlist"><ol type="1"><li><p>When should you use a rule engine?</p></li><li><p>What advantage does a rules engine have over hand coded
      "if...then" approaches?</p></li><li><p>Why should you use a rule engine instead of a scripting framework,
      like <a class="indexterm" name="d0e491"></a> BeanShell?</p></li></ol></div><p>We will attempt to address these questions below.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e497"></a>2.2.1.&nbsp;Advantages of a Rule Engine</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Declarative Programming</p><p>Rule engines allow you to say "What to do" not "How to do
        it".</p><p>The key advantage of this point is that using rules can make it
        easy to express solutions to difficult problems and consequently have
        those solutions verified (rules are much easier to read then
        code).</p><p>Rule systems are capable of solving very, very hard problems,
        providing an explanation of how the solution was arrived at and why
        each "decision" along the way was made (not so easy with other of AI
        systems like neural networks or the human brain - I have no idea why I
        scratched the side of the car).</p></li><li><p>Logic and Data Separation</p><p>Your data is in your domain objects, the logic is in the rules.
        This is fundamentally breaking the OO coupling of data and logic,
        which can be an advantage or a disadvantage depending on your point of
        view. The upshot is that the logic can be much easier to maintain as
        there are changes in the future, as the logic is all laid out in
        rules. This can be especially true if the logic is cross-domain or
        multi-domain logic. Instead of the logic being spread across many
        domain objects or controllers, it can all be organized in one or more
        very distinct rules files.</p></li><li><p>Speed and Scalability</p><p>The Rete algorithm, Leaps algorithm, and its descendants such as
        Drools' Reteoo (and Leaps), provide very efficient ways of matching
        rule patterns to your domain object data. These are especially
        efficient when you have datasets that do not change entirely (as the
        rule engine can remember past matches). These algorithms are battle
        proven.</p></li><li><p>Centralization of Knowledge</p><p>By using rules, you create a repository of knowledge (a
        knowledgebase) which is executable. This means it's a single point of
        truth, for business policy (for instance) - ideally rules are so
        readable that they can also serve as documentation.</p></li><li><p>Tool Integration</p><p>Tools such as Eclipse (and in future, Web based UIs) provide
        ways to edit and manage rules and get immediate feedback, validation
        and content assistance. Auditing and debugging tools are also
        available.</p></li><li><p>Explanation Facility</p><p>Rule systems effectively provide an "explanation facility" by
        being able to log the decisions made by the rule engine along with why
        the decisions were made.</p></li><li><p>Understandable Rules</p><p>By creating object models and optionally Domain Specific
        Languages that model your problem domain you can set yourself up to
        write rules that look very close to natural language. They lend
        themselves to logic that is understandable to, possibly nontechnical,
        domain experts as they are expressed in their language. (as all the
        program plumbing, the "How", is in the usual code, hidden
        away).</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e540"></a>2.2.2.&nbsp;When should you use a Rule Engine?</h3></div></div></div><p>The shortest answer to this is "when there is no satisfactory
    traditional programming approach to solve the problem.". Given that short
    answer, some more explanation is required. The reason why there is no
    "traditional" approach is possibly one of the following: </p><div class="itemizedlist"><ul type="disc"><li><p>The problem is just too fiddle for traditional code.</p><p>The problem may not be complex, but you can't see a
          non-fragile way of building it.</p></li><li><p>The problem is beyond any obvious algorithm based
          solution.</p><p>It is a complex problem to solve, there are no obvious
          traditional solutions or basically the problem isn't fully
          understood.</p></li><li><p>The logic changes often</p><p>The logic itself may be simple (but doesn't have to be) but
          the rules change quite often. In many organizations software
          releases are few and far between and rules can help provide the
          "agility" that is needed and expected in a reasonably safe
          way.</p></li><li><p>Domain experts (or business analysts) are readily available,
          but are nontechnical.</p><p>Domain experts are often a wealth of knowledge about business
          rules and processes. They typically are nontechnical, but can be
          very logical. Rules can allow them to express the logic in their own
          terms. Of course, they still have to think critically and be capable
          of logical thinking (many people in "soft" nontechnical positions do
          not have training in formal logic, so be careful and work with them,
          as by codifying business knowledge in rules, you will often expose
          holes in the way the business rules and processes are currently
          understood).</p></li></ul></div><p>If rules are a new technology for your project teams, the overhead
    in getting going must be factored in. Its not a trivial technology, but
    this document tries to make it easier to understand.</p><p>Typically in a modern OO application you would use a rule engine to
    contain key parts of your business logic (what that means of course
    depends on the application) - ESPECIALLY the REALLY MESSY parts!. This is
    an inversion of the OO concept of encapsulating all the logic inside your
    objects. This is not to say that you throw out OO practices, on the
    contrary in any real world application, business logic is just one part of
    the application. If you ever notice lots of "if", "else", "switch", an
    over abundance of strategy patterns and/or other messy logic in your code
    that just doesn't feel right (and you keep coming back to fix it - either
    because you got it wrong, or the logic/your understanding changes) - think
    about using rules. If you are faced with tough problems of which there are
    no algorithms or patterns for, consider using rules.</p><p>Rules could be used embedded in your application or perhaps as a
    service. Often rules work best as "stateful" component - hence they are
    often an integral part of an application. However, there have been
    successful cases of creating reusable rule services which are
    stateless.</p><p>In your organization it is important to think about the process you
    will use for updating rules in systems that are in production (the options
    are many, but different organizations have different requirements - often
    they are out of the control of the application vendors/project
    teams).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e574"></a>2.2.3.&nbsp;When not to use a Rule Engine</h3></div></div></div><p>To quote a Drools mailing list regular (Dave Hamu): "It seems to me
    that in the excitement of working with rules engines, that people forget
    that a rules engine is only one piece of a complex application or
    solution. Rules engines are not really intended to handle workflow or
    process executions nor are workflow engines or process management tools
    designed to do rules. Use the right tool for the job. Sure, a pair of
    pliers can be used as a hammering tool in a pinch, but that's not what
    it's designed for."</p><p>As rule engines are dynamic (dynamic in the sense that the rules can
    be stored and managed and updated as data), they are often looked at as a
    solution to the problem of deploying software (most IT departments seem to
    exist for the purpose of preventing software being rolled out). If this is
    the reason you wish to use a rule engine, be aware that rule engines work
    best when you are able to write declarative rules. As an alternative, you
    can consider data-driven designs (lookup tables), or script/process
    engines where the scripts are managed in a database and are able to be
    updated on the fly.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e581"></a>2.2.4.&nbsp;Scripting or Process Engines</h3></div></div></div><p>Hopefully the preceding sections have explained when you may want to
    use a rule engine.</p><p>Alternatives are script-based engines that provide the dynamicness
    for "changes on the fly" (there are many solutions here).</p><p>Alternatively Process Engines (also capable of workflow) such as
    jBPM allow you to graphically (or programmatically) describe steps in a
    process - those steps can also involve decision point which are in
    themselves a simple rule. Process engines and rules often can work nicely
    together, so it is not an either-or proposition.</p><p>One key point to note with rule engines, is that some rule-engines
    are really scripting engines. The downside of scripting engines is that
    you are tightly coupling your application to the scripts (if they are
    rules, you are effectively calling rules directly) and this may cause more
    difficulty in future maintenance, as they tend to grow in complexity over
    time. The upside of scripting engines is they can be easier to implement
    at first, and you can get quick results (and conceptually simpler for
    imperative programmers!).</p><p>Many people have also implemented data-driven systems successfully
    in the past (where there are control tables that store meta-data that
    changes your applications behavior) - these can work well when the
    control can remain very limited. However, they can quickly grow out of
    control if extended to much (such that only the original creators can
    change the applications behavior) or they cause the application to
    stagnate as they are too inflexible.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e594"></a>2.2.5.&nbsp;Strong and Loose Coupling</h3></div></div></div><p>No doubt you have heard terms like "tight coupling" and "loose
    coupling" in systems design. Generally people assert that "loose" or
    "weak" coupling is preferable in design terms, due to the added
    flexibility it affords. Similarly, you can have "strongly coupled" and
    "weakly coupled" rules. Strongly coupled in this sense means that one rule
    "firing" will clearly result in another rule firing etc.; in other words
    there is a clear (probably obvious) chain of logic. If your rules are all
    strongly coupled, the chances are that the rules will have future
    inflexibility, and more significantly, that perhaps a rule engine is
    overkill (as the logic is a clear chain of rules - and can be hard coded.
    [A Decision Tree may be in order]). This is not to say that strong or weak
    coupling is inherently bad, but it is a point to keep in mind when
    considering a rule engine and in how you capture the rules. "Loosely"
    coupled rules should result in a system that allows rules to be changed,
    removed and added without requiring changes to other rules that are
    unrelated.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e599"></a>2.3.&nbsp;Knowledge Representation</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e603"></a>2.3.1.&nbsp;First Order Logic</h3></div></div></div><p>Rules are written using First Order Logic, or predicate logic, which
    extends Propositional Logic. <a class="ulink" href="http://en.wikipedia.org/wiki/Emil_Leon_Post" target="_top">Emil Leon Post</a>
    was the first to develop an inference based system using symbols to
    express logic - as a consequence of this he was able to prove that any
    logical system (including mathematics) could be expressed with such a
    system.</p><p>A proposition is a statement that can be classified as true or
    false. If the truth can be determined from statement alone it is said to
    be a "closed statement". In programming terms this is an expression that
    does not reference any variables:</p><p>10 == 2 * 5</p><p>Expressions that evaluate against one or more variables, the facts,
    are "open statements", in that we cannot determine whether the statement
    is true until we have a variable instance to evaluate against:</p><p>Person.sex == "male"</p><p>With SQL if we look at the conclusion's action as simply returning
    the matched fact to the user:</p><p>select * from People where People.sex == "male"</p><p>For any rows, which represent our facts, that are returned we have
    inferred that those facts are male people. The following diagram shows how
    the above SQL statement and People table can be represented in terms of an
    Inference Engine.</p><div class="figure"><a name="d0e625"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/Male_People.png" align="middle" alt="SQL as a simplistic Inference Engine"></div></div><p class="title"><b>Figure&nbsp;2.4.&nbsp;SQL as a simplistic Inference Engine</b></p></div><br class="figure-break"><p>So in Java we can say that a simple proposition is of the form
    'variable' 'operator' 'value' - where we often refer to 'value' as being a
    literal value - a proposition can be thought as a field constraint.
    Further to this propositions can be combined with conjunctive and
    disjunctive connectives, which is the logic theorists way of saying
    '&amp;&amp;' and '||'. The following shows two open propositional
    statements connected together with a single disjunctive connective.</p><pre class="programlisting">
      
      person.getEyeColor().equals("blue") || person.getEyeColor().equals("green") 
      
    </pre><p>This can be expressed using a disjunctive Conditional Element
    connective - which actually results in the generation of two rules, to
    represent the two possible logic outcomes.</p><pre class="programlisting">
      
      Person( eyeColour == "blue" ) || Person( eyeColor == "green" )
      
    </pre><p>Disjunctive field constraints connectives could also be used and
    would not result in multiple rule generation.</p><pre class="programlisting">
      
      Person( eyeColour == "blue"|| == "green" )
      
    </pre><p>Propositional Logic is not Turing complete, limiting the problems
    you can define, because it cannot express criteria for the structure of
    data. First Order Logic (FOL), or Predicate Logic, extends Propositional
    Logic with two new quantifier concepts to allow expressions defining
    structure - specifically universal and existential quantifiers. Universal
    quantifiers allow you to check that something is true for everything;
    normally supported by the 'forall' conditional element. Existential
    quantifiers check for the existence of something, in that it occurs at
    least once - this is supported with 'not' and 'exists' conditional
    elements.</p><p>Imagine we have two classes - Student and Module. Module represents
    each of the courses the Student attended for that semester, referenced by
    the List collection. At the end of the semester each Module has a score.
    If the Student has a Module score below 40 then they will fail that
    semester - the existential quantifier can be used used with the "less than
    40" open proposition to check for the existence of a Module that is true
    for the specified criteria.</p><pre class="programlisting">
    
    public class Student {
    private String name;
    private List modules;

    ...
    }
       
    </pre><pre class="programlisting">
    
    public class Module {
    private String name;
    private String studentName;
    private int score;
    
    </pre><p>Java is Turing complete in that you can write code, among other
    things, to iterate data structures to check for existence. The following
    should return a List of students who have failed the semester.</p><pre class="programlisting">
    
    List failedStudents = new ArrayList();
    
    for ( Iterator studentIter = students.iterator(); studentIter.hasNext() {
        Student student = ( Student ) studentIter.next();
        for ( Iterator it = student.getModules.iterator(); it.hasNext(); ) {
            Module module = ( Module ) it.next();
            if ( module.getScore() &lt; 40  ) {
                failedStudents.add( student ) ;
                break;
            }
        }
    }
    
    </pre><p>Early SQL implementations were not Turing complete as they did not
    provide quantifiers to access the structure of data. Modern SQL engines do
    allow nesting of SQL, which can be combined with keywords like 'exists'
    and 'in'. The following show SQL and a Rule to return a set of Students
    who have failed the semester.</p><pre class="programlisting">

      select 
    * 
from 
    Students s 
where exists (  
    select 
        * 
    from 
        Modules m 
    where 
        m.student_name = s.name and 
        m.score &lt; 40 
)

    </pre><p></p><pre class="programlisting">

    rule "Failed_Students"
    when
        exists( $student : Student() &amp;&amp; Module( student == $student, score &lt; 40 ) )
    
    </pre><p></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e665"></a>2.4.&nbsp;Rete Algorithm</h2></div></div></div><p>The RETE algorithm was invented by Dr. Charles Forgy and documented in
  his PhD thesis in 1978-79. A simplified version of the paper was published
  in 1982 (<a class="ulink" href="http://citeseer.ist.psu.edu/context/505087/0" target="_top">http://citeseer.ist.psu.edu/context/505087/0</a>).
  The word RETE is latin for "net" meaning network. The RETE algorithm can be broken
  into 2 parts: rule compilation and runtime execution.</p><p>The compilation algorithm describes how the Rules in the Production
  Memory to generate an efficient discrimination network. In non-technical
  terms, a discrimination network is used to filter data. The idea is to
  filter data as it propagates through the network. At the top of the network
  the nodes would have many matches and as we go down the network, there would be 
  fewer matches. At the very bottom of the network are the terminal nodes. In Dr.
  Forgy's 1982 paper, he described 4 basic nodes: root, 1-input, 2-input and
  terminal.</p><div class="figure"><a name="d0e675"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/Rete_Nodes.png" align="middle" alt="Rete Nodes"></div></div><p class="title"><b>Figure&nbsp;2.5.&nbsp;Rete Nodes</b></p></div><br class="figure-break"><p>The root node is where all objects enter the network. From there, it
  immediately goes to the ObjectTypeNode. The purpose of the ObjectTypeNode is
  to make sure the engine doesn't do more work than it needs to. For example,
  say we have 2 objects: Account and Order. If the rule engine tried to
  evaluate every single node against every object, it would waste a lot of
  cycles. To make things efficient, the engine should only pass the object to
  the nodes that match the object type. The easiest way to do this is to
  create an ObjectTypeNode and have all 1-input and 2-input nodes descend from
  it. This way, if an application asserts a new account, it won't propagate to
  the nodes for the Order object. In Drools when an object is asserted it
  retrieves a list of valid ObjectTypesNodes via a lookup in a HashMap from
  the object's Class; if this list doesn't exist it scans all the ObjectTypde
  nodes finding valid matches which it caches in the list. This enables Drools
  to match against any Class type that matches with an
  <code class="literal">instanceof</code> check.</p><div class="figure"><a name="d0e688"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/Object_Type_Nodes.png" align="middle" alt="ObjectTypeNodes"></div></div><p class="title"><b>Figure&nbsp;2.6.&nbsp;ObjectTypeNodes</b></p></div><br class="figure-break"><p>ObjectTypdeNodes can propagate to AlphaNodes, LeftInputAdapterNodes
  and BetaNodes. AlphaNodes are used to evaluate literal conditions. Although
  the 1982 paper only covers equality conditions, many RETE implementations
  support other operations. For example, Account.name == "Mr Trout" is a
  literal condition. When a rule has multiple literal conditions for a single
  object type, they are linked together. This means that if an application
  asserts an account object, it must first satisfy the first literal condition
  before it can proceed to the next AlphaNode. In Dr. Forgy's paper, he refers
  to these as IntraElement conditions. The following shows the AlphaNode
  combinations for Cheese( name == "cheddar, strength == "strong" ):</p><div class="figure"><a name="d0e698"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/Alpha_Nodes.png" align="middle" alt="AlphaNodes"></div></div><p class="title"><b>Figure&nbsp;2.7.&nbsp;AlphaNodes</b></p></div><br class="figure-break"><p>Drools extends Rete by optimizing the propagation from ObjectTypdeNode
  to AlphaNode using hashing. Each time an AlphaNode is added to an
  ObjectTypdeNode it adds the literal value as a key to the HashMap with the
  AlphaNode as the value. When a new instance enters the ObjectTypde node,
  rather than propagating to each AlphaNode, it can instead retrieve the
  correct AlphaNode from the HashMap - avoiding unnecessary literal
  checks.</p><p>There are two two-input nodes; JoinNode and NotNode - both are
  types of BetaNodes. BetaNodes are use to compare 2 objects, and their
  fields, to each other. The objects may be the same or different types. By
  convention we refer to the two inputs as left and right. The left input for
  a BetaNode is generally a list of objects; in Drools this is a Tuple. The
  right input is a single object. Two Nots can be used to implement 'exists'
  checks. BetaNodes also have memory. The left input is called the Beta Memory
  and remembers all incoming tuples. The right input is called the Alpha
  Memory and remembers all incoming objects. Drools extends Rete by
  performing indexing on the BetaNodes. For instance, if we know that a
  BetaNode is performing a check on a String field, as each object enters we
  can do a hash lookup on that String value. This means when facts enter from
  the opposite side, instead of iterating over all the facts to find valid
  joins, we do a lookup returning potentially valid candidates. At any
  point a valid join is found the Tuple is joined with the Object; which is
  referred to as a partial match; and then propagated to the next node.</p><div class="figure"><a name="d0e710"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/Join_Node.png" align="middle" alt="JoinNode"></div></div><p class="title"><b>Figure&nbsp;2.8.&nbsp;JoinNode</b></p></div><br class="figure-break"><p>To enable the first Object, in the above case Cheese, to enter the
  network we use a LeftInputNodeAdapter - this takes an Object as an input and
  propagates a single Object Tuple.</p><p>Terminal nodes are used to indicate a single rule has matched all its
  conditions - at this point we say the rule has a full match. A rule with an
  'or' conditional disjunctive connective results in subrule generation for
  each possible logically branch; thus one rule can have multiple terminal
  nodes.</p><p>Drools also performs node sharing. Many rules repeat the same
  patterns, node sharing allows us to collapse those patterns so that they
  don't have to be re-evaluated for every single instance. The following two
  rules share the first same pattern, but not the last:</p><pre class="programlisting">
    
    rule
    when
        Cheese( $chedddar : name == "cheddar" )
        $person : Person( favouriteCheese == $cheddar )
    then
        System.out.println( $person.getName() + " likes cheddar" );
    end
    
   </pre><pre class="programlisting">
    
    rule
    when
        Cheese( $chedddar : name == "cheddar" )
        $person : Person( favouriteCheese != $cheddar )
    then
        System.out.println( $person.getName() + " does not like cheddar" );
    end
    
  </pre><p>As you can see below, the compiled Rete network shows the alpha node is
  shared, but the beta nodes are not. Each beta node has its own TerminalNode. Had
  the second pattern been the same it would have also been shared.</p><div class="figure"><a name="d0e730"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/Node_Sharing.png" align="middle" alt="Node Sharing"></div></div><p class="title"><b>Figure&nbsp;2.9.&nbsp;Node Sharing</b></p></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e738"></a>2.5.&nbsp;The Drools Rule Engine</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e741"></a>2.5.1.&nbsp;Overview</h3></div></div></div><p>Drools is split into two main parts: Authoring and Runtime.</p><p>The authoring process involves the creation of DRL or XML files for
    rules which are fed into a parser - defined by an Antlr 3 grammar. The
    parser checks for correctly formed grammar and produces an intermediate
    structure for the "descr"; where the "descr" indicates the AST that
    "describes" the rules. The AST is then passed to the Package Builder which
    produces Packages. Package Builder also undertakes any code generation and
    compilation that is necessary for the creation of the Package. A Package
    object is self contained and deployable, in that it's a serialized object
    consisting of one or more rules.</p><div class="figure"><a name="d0e748"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/Authoring.png" align="middle" alt="Authoring Components"></div></div><p class="title"><b>Figure&nbsp;2.10.&nbsp;Authoring Components</b></p></div><br class="figure-break"><p>A RuleBase is a runtime component which consists of one or more
    Packages. Packages can be added and removed from the RuleBase at any time.
    A RuleBase can instantiate one or more WorkingMemories at any time; a weak
    reference is maintained, unless configured otherwise. The Working Memory
    consists of a number of sub components, including Working Memory Event
    Support, Truth Maintenance System, Agenda and Agenda Event Support. Object
    insertion may result in the creation of one or more Activations. The
    Agenda is responsible for scheduling the execution of these
    Activations.</p><div class="figure"><a name="d0e758"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/Runtime.png" align="middle" alt="Runtime Components"></div></div><p class="title"><b>Figure&nbsp;2.11.&nbsp;Runtime Components</b></p></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e766"></a>2.5.2.&nbsp;Authoring</h3></div></div></div><div class="figure"><a name="d0e769"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/PackageBuilder.png" align="middle" alt="PackageBuilder"></div></div><p class="title"><b>Figure&nbsp;2.12.&nbsp;PackageBuilder</b></p></div><br class="figure-break"><p>Four classes are used for authoring: DrlParser, XmlParser,
    ProcessBuilder and PackageBuilder. The two parser classes produce "descr"
    (description) AST models from a provided Reader instance. ProcessBuilder
    reads in an xstream serialisation representation of the Rule Flow.
    PackageBuilder provides convienience APIs so that you can mostly forget
    about those classes. The three convenience methods are
    "addPackageFromDrl", "addPackageFromXml" and addRuleFlow - all take an
    instance of Reader as an argument. The example below shows how to build a
    package that includes both XML, DRL and rule files and a ruleflow file,
    which are in the classpath. Note that all added package sources must be of
    the same package namespace for the current PackageBuilder instance!</p><div class="example"><a name="d0e779"></a><p class="title"><b>Example&nbsp;2.1.&nbsp;Building a Package from Multiple Sources</b></p><div class="example-contents"><pre class="programlisting">PackageBuilder builder = new PackageBuilder();
builder.addPackageFromDrl( new InputStreamReader( getClass().getResourceAsStream( "package1.drl" ) ) );
builder.addPackageFromXml( new InputStreamReader( getClass().getResourceAsStream( "package2.xml" ) ) );
builder.addRuleFlow( new InputStreamReader( getClass().getResourceAsStream( "ruleflow.rfm" ) ) );
Package pkg = builder.getPackage();      </pre></div></div><br class="example-break"><p>It is essential that you always check your PackageBuilder for errors
    before attempting to use it. While the ruleBase does throw an
    InvalidRulePackage when a broken Package is added, the detailed error
    information is stripped and only a toString() equivalent is available. If
    you interrogate the PackageBuilder itself much more information is
    available.</p><div class="example"><a name="d0e786"></a><p class="title"><b>Example&nbsp;2.2.&nbsp;Checking the PackageBuilder for errors</b></p><div class="example-contents"><pre class="programlisting">PackageBuilder builder = new PackageBuilder();
builder.addPackageFromDrl( new InputStreamReader( getClass().getResourceAsStream( "package1.drl" ) ) );
PackageBuilderErrors errors = builder.getErrors();</pre></div></div><br class="example-break"><p>PackageBuilder is configurable using PackageBuilderConfiguration
    class.</p><div class="figure"><a name="d0e793"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/PackageBuilderConfiguration.png" align="middle" alt="PackageBuilderConfiguration"></div></div><p class="title"><b>Figure&nbsp;2.13.&nbsp;PackageBuilderConfiguration</b></p></div><br class="figure-break"><p>It has default values that can be overridden programmatically via
    setters or on first use via property settings. At the heart of the
    settings is the ChainedProperties class which searches a number of
    locations looking for drools.packagebuilder.conf files; as it finds them
    it adds the properties to the master propperties list; this provides a
    level precedence. In order of precedence those locations are: System
    Properties, user defined file in System Properties, user home directory,
    working directory, various META-INF locations. Further to this the
    droosl-compiler jar has the default settings in its META-INF
    directory.</p><p>Currently the PackageBulderConfiguration handles the registry of
    Accumulate functions, registry of Dialects and the main
    ClassLoader.</p><p>Drools has a pluggeable Dialect system, which allows other languages
    to compile and execution expressions and blocks, the two currently
    supported dialects are Java and MVEL. Each has its own
    DialectConfiguration Implementation; the javadocs provide details for each
    setter/getter and the property names used to configure them.</p><div class="figure"><a name="d0e807"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/JavaDialectConfiguration.png" align="middle" alt="JavaDialectConfiguration"></div></div><p class="title"><b>Figure&nbsp;2.14.&nbsp;JavaDialectConfiguration</b></p></div><br class="figure-break"><p>The JavaDialectConfiguration allows the compiler and language levels
    to be supported. You can override by setting the
    "drools.dialect.java.compiler" property in a packagebuilder.conf file that
    the ChainedProperties instance will find, or you can do it at runtime as
    shown below.</p><div class="example"><a name="d0e817"></a><p class="title"><b>Example&nbsp;2.3.&nbsp;Configuring the JavaDialectConfiguration to use JANINO via a
      setter</b></p><div class="example-contents"><pre class="programlisting">PackageBuilderConfiguration cfg = new PackageBuilderConfiguration( );
JavaDialectConfiguration javaConf = (JavaDialectConfiguration) cfg.getDialectConfiguration( "java" );
javaConf.setCompiler( JavaDialectConfiguration.JANINO );            </pre></div></div><br class="example-break"><p>if you do not have Eclipse JDT Core in your classpath you must
    override the compiler setting before you instantiate this PackageBuilder,
    you can either do that with a packagebuilder properties file the
    ChainedProperties class will find, or you can do it programmatically as
    shown below; note this time I use properties to inject the value for
    startup.</p><div class="example"><a name="d0e824"></a><p class="title"><b>Example&nbsp;2.4.&nbsp;Configuring the JavaDialectConfiguration to use JANINO</b></p><div class="example-contents"><pre class="programlisting">Properties properties = new Properties();
properties.setProperty( "drools.dialect.java.compiler",
                        "JANINO" );
PackageBuilderConfiguration cfg = new PackageBuilderConfiguration( properties );
JavaDialectConfiguration javaConf = (JavaDialectConfiguration) cfg.getDialectConfiguration( "java" );
assertEquals( JavaDialectConfiguration.JANINO,
              javaConf.getCompiler() ); // demonstrate that the compiler is correctly configured            </pre></div></div><br class="example-break"><p>Currently it allows alternative compilers (Janino, Eclipse JDT) to
    be specified, different JDK source levels ("1.4" and "1.5") and a parent
    class loader. The default compiler is Eclipse JDT Core at source level
    "1.4" with the parent class loader set to
    "Thread.currentThread().getContextClassLoader()".</p><p>The following show how to specify the JANINO compiler
    programmatically:</p><div class="example"><a name="d0e833"></a><p class="title"><b>Example&nbsp;2.5.&nbsp;Configuring the PackageBuilder to use JANINO via a
      property</b></p><div class="example-contents"><pre class="programlisting">PackageBuilderConfiguration conf = new PackageBuilderConfiguration();
conf.setCompiler( PackageBuilderConfiguration.JANINO );
PackageBuilder builder = new PackageBuilder( conf );</pre></div></div><br class="example-break"><p>The MVELDialectConfiguration is much simpler and only allows strict
    mode to be turned on and off, by default strict is true; this means all
    method calls must be type safe either by inference or by explicit
    typing.</p><div class="figure"><a name="d0e840"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/MVELDialectConfiguration.png" align="middle" alt="MvelDialectConfiguration"></div></div><p class="title"><b>Figure&nbsp;2.15.&nbsp;MvelDialectConfiguration</b></p></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e848"></a>2.5.3.&nbsp;RuleBase</h3></div></div></div><div class="figure"><a name="d0e851"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/RuleBaseFactory.png" align="middle" alt="RuleBaseFactory"></div></div><p class="title"><b>Figure&nbsp;2.16.&nbsp;RuleBaseFactory</b></p></div><br class="figure-break"><p>A RuleBase is instantiated using the RuleBaseFactory, by default
    this returns a ReteOO RuleBase. Packages are added, in turn, using the
    addPackage method. You may specify packages of any namespace and multiple
    packages of the same namespace may be added.</p><div class="example"><a name="d0e861"></a><p class="title"><b>Example&nbsp;2.6.&nbsp;Adding a Package to a new RuleBase</b></p><div class="example-contents"><pre class="programlisting">RuleBase ruleBase  = RuleBaseFactory.newRuleBase();
ruleBase.addPackage( pkg  );        </pre></div></div><br class="example-break"><div class="figure"><a name="d0e866"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/RuleBase.png" align="middle" alt="RuleBase"></div></div><p class="title"><b>Figure&nbsp;2.17.&nbsp;RuleBase</b></p></div><br class="figure-break"><p>A RuleBase contains one or more more packages of rules, ready to be
    used, i.e., they have been validated/compiled etc. A Rule Base is
    serializable so it can be deployed to JNDI or other such services.
    Typically, a rulebase would be generated and cached on first use; to save
    on the continually re-generation of the Rule Base; which is
    expensive.</p><p>A Rule Base instance is thread safe, in the sense that you can have
    the one instance shared across threads in your application, which may be a
    web application, for instance. The most common operation on a rulebase is
    to create a new rule session; either stateful or stateless.</p><p>The Rule Base also holds references to any stateful session that it
    has spawned, so that if rules are changing (or being added/removed etc.
    for long running sessions), they can be updated with the latest rules
    (without necessarily having to restart the session). You can specify not
    to maintain a reference, but only do so if you know the Rule Base will not
    be updated. References are not stored for stateless sessions.</p><pre class="programlisting">ruleBase.newStatefulSession();  // maintains a reference.
ruleBase.newStatefulSession( false ); // do not maintain a reference    </pre><p>Packages can be added and removed at any time - all changes will be
    propagated to the existing stateful sessions; don't forget to call
    fireAllRules() for resulting Activations to fire.</p><pre class="programlisting">ruleBase.addPackage( pkg );  // Add a package instance
ruleBase.removePackage( "org.com.sample" );  // remove a package, and all its parts, by it's namespace
ruleBase.removeRule( "org.com.sample", "my rule" ); // remove a specific rule from a namespace         </pre><p>While there is a method to remove an indivual rule, there is no
    method to add an individual rule - to achieve this just add a new package
    with a single rule in it.</p><p>RuleBaseConfigurator can be used to specify additional behavior of
    the RuleBase. RuleBaseConfiguration is set to immutable after it has been
    added to a Rule Base. Nearly all the engine optimizations can be turned on
    and off from here, and also the execution behavior can be set. Users will
    generally be concerned with insertion behavior (identity or equality) and
    cross product behavior(remove or keep identity equals cross
    products).</p><pre class="programlisting">RuleBaseConfiguration conf = new RuleBaseConfiguration();
conf.setAssertBehaviour( AssertBehaviour.IDENTITY );
conf.setRemoveIdentities( true );
RuleBase ruleBase = RuleBaseFactory.newRuleBase( conf );</pre><div class="figure"><a name="d0e892"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/RuleBaseConfiguration.png" align="middle" alt="RuleBaseConfiguration"></div></div><p class="title"><b>Figure&nbsp;2.18.&nbsp;RuleBaseConfiguration</b></p></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e900"></a>2.5.4.&nbsp;WorkingMemory and Stateful/Stateless Sessions</h3></div></div></div><div class="figure"><a name="d0e903"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/WorkingMemory.png" align="middle" alt="WorkingMemory"></div></div><p class="title"><b>Figure&nbsp;2.19.&nbsp;WorkingMemory</b></p></div><br class="figure-break"><p>It holds references to all data that has been "inserted" into it
    (until retracted) and it is the place where the interaction with your
    application occurs. Working memories are stateful objects. They may be
    shortlived or longlived.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e913"></a>2.5.4.1.&nbsp;Facts</h4></div></div></div><p>Facts are objects (beans) from your application that you insert
      into the working memory. Facts are any Java objects which the rules can
      access. The rule engine does not "clone" facts at all, it is all
      references/pointers at the end of the day. Facts are your applications
      data. Strings and other classes without getters and setters are not
      valid Facts and can't be used with Field Constraints which rely on the
      JavaBean standard of getters and setters to interact with the
      object.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e918"></a>2.5.4.2.&nbsp;Insertion</h4></div></div></div><p>"Insert" is the act of telling the WorkingMemory about the facts.
      WorkingMemory.insert(yourObject) for example. When you insert a fact, it
      is examined for matches against the rules etc. This means ALL of the
      work is done during insertion; however, no rules are executed until you
      call "fireAllRules()". You don't call "fireAllRules()" until after you
      have finished inserting your facts. This is a common misunderstanding by
      people who think the work happens when you call "fireAllRules()". Expert
      systems typically use the term "assert" or "assertion" to refer to facts
      made available to the system, however due to the assert become a keyword
      in most languages we have moved to use the "Insert" keyword; so expect
      to hear the two used interchangeably.</p><p>When an Object is insert it returns a FactHandle. This FactHandle
      is the token used to represent your insert Object inside the
      WorkingMemory, it is also how you will interact with the Working Memory
      when you wish to retract or modify an object.</p><pre class="programlisting">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = session.insert( stilton );      </pre><p>As mentioned in the Rule Base section a Working Memory may operate
      in two assertions modes equality and identity - identity is
      default.</p><p>Identity means the Working Memory uses an IdentityHashMap to store
      all asserted Objects. New instance assertions always result in the
      return of a new FactHandle, if an instance is asserted twice then it
      returns the previous fact handle &#8211; i.e. it ignores the second insertion
      for the same fact.</p><p>Equality means the Working Memory uses a HashMap to store all
      asserted Objects. New instance assertions will only return a new
      FactHandle if a no equal classes have been asserted.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e934"></a>2.5.4.3.&nbsp;Retraction</h4></div></div></div><p>"Retraction" is when you retract a fact from the Working Memory,
      which means it will no longer track and match that fact, and any rules
      that are activated and dependent on that fact will be cancelled. Note
      that it is possible to have rules that depend on the "non existence" of
      a fact, in which case retracting a fact may cause a rule to activate
      (see the 'not' and 'exist' keywords). Retraction is done using the
      FactHandle that was returned during the assert.</p><pre class="programlisting">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = session.insert( stilton );
....
session.retract( stiltonHandle );            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e941"></a>2.5.4.4.&nbsp;Update</h4></div></div></div><p>The Rule Engine must be notified of modified Facts, so that it can
      be re-process. Modification internally is actually a retract and then an
      insert; so it clears the WorkingMemory and then starts again. Use the
      modifyObject method to notify the Working Memory of changed objects, for
      objects that are not able to notify the Working Memory themselves.
      Notice modifyObject always takes the modified object as a second
      parameter - this allows you to specify new instances for immutable
      objects. The update() method can only be used with objects that have
      shadow proxies turned on. If you do not use shadow proxies then you must
      call session.modifyRestract() before making your changes and
      session.modifyInsert() after the changes.</p><pre class="programlisting">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = workingMemory.insert( stilton );
....
stilton.setPrice( 100 );
workingMemory.update( stiltonHandle, stilton );              </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e948"></a>2.5.4.5.&nbsp;Globals</h4></div></div></div><p>Globals are named objects that can be passed in to the rule
      engine; without needing to insert them. Most often these are used for
      static information, or services that are used in the RHS of a rule, or
      perhaps a means to return objects from the rule engine. If you use a
      global on the LHS of a rule, make sure it is immutable. A global must
      first be declared in the drl before it can be set on the session.</p><pre class="programlisting">global java.util.List list        </pre><p>With the Rule Base now aware of the global identifier and its type
      any sessions are now able to call session.setGlobal; failure to declare
      the global type and identifier first will result in an exception being
      thrown. to set the global on the session use
      session.setGlobal(identifier, value);</p><pre class="programlisting">List list = new ArrayList();
session.setGlobal("list", list);           </pre><p>If a rule evaluates on a global before you set it you will get a
      NullPointerException.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e961"></a>2.5.4.6.&nbsp;Shadow Facts</h4></div></div></div><p>A shadow fact is a shallow copy of an asserted object. Shadow
      facts are cached copies of object asserted to the working memory. The
      term shadow facts is commonly known as a feature of JESS (Java Expert
      System Shell).</p><p>The origins of shadow facts traces back to the concept of truth
      maintenance. The basic idea is that an expert system should guarantee
      the derived conclusions are accurate. A running system may alter a fact
      during evaluation. When this occurs, the rule engine must know a
      modification occurred and handle the change appropriately. There's
      generally two ways to guarantee truthfulness. The first is to lock all
      the facts during the inference process. The second is to make a cache
      copy of an object and force all modifications to go through the rule
      engine. This way, the changes are processed in an orderly fashion.
      Shadow facts are particularly important in multi-threaded environments,
      where an engine is shared by multiple sessions. Without truth
      maintenance, a system has a difficult time proving the results are
      accurate. The primary benefit of shadow facts is it makes development
      easier. When developers are forced to keep track of fact modifications,
      it can lead to errors, which are difficult to debug. Building a
      moderately complex system using a rule engine is hard enough without
      adding the burden of tracking changes to facts and when they should
      notify the rule engine.</p><p>Drools 4.0 has full support for Shadow Facts implemented as
      transparent lazy proxies. Shadow facts are enable by default and are not
      visible from external code, not even inside code blocks on rules.</p><p class="remark"><i><span class="remark">I<span class="bold"><strong>MPORTANT: </strong></span>since Drools
      implements Shadow Facts as Proxies, the fact classes must <span class="bold"><strong>either be immutable</strong></span> or <span class="bold"><strong>should not be final</strong></span>, nor have final methods. If a
      fact class is final or have final methods and is still a mutable class,
      the engine is not able to create a proper shadow fact for it and results
      in unpredictable behavior. </span></i></p><p>Although shadow facts are a great way of ensuring the engine
      integrity, they add some overhead to the the reasoning process. As so,
      Drools 4.0 supports fine grained control over them with the ability to
      enable/disable them for each individual class. </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e983"></a>2.5.4.6.1.&nbsp;When is it possible to disable Shadow Facts?</h5></div></div></div><p>It is possible to disable shadow facts for your classes if you
        meet the following requirements:</p><p><span class="bold"><strong>1. Immutable classes are safe:</strong></span>
        if a class is immutable it does not require shadow facts. Just to
        clarify, a class is immutable from the engine perspective if once an
        instance is asserted into the working memory, no attribute will change
        until it is retracted.</p><p><span class="bold"><strong>2. Inside your rules, attributes are only
        changed using modify() blocks:</strong></span> both Drools dialects (MVEL
        and Java) have the modify block construct. If all attribute value
        changes for a given class happen inside modify() blocks, you can
        disable shadow facts for that class.</p><div class="example"><a name="d0e996"></a><p class="title"><b>Example&nbsp;2.7.&nbsp;Example: modify() block using Java dialect</b></p><div class="example-contents"><pre class="programlisting">rule "Eat Cheese"
when
  $p: Person( status == "hungry" )
  $c: Cheese( )
then
  retract( $c );
  modify( $p ) {
      setStatus( "full" ),
      setAge( $p.getAge() + 1 )
  }
end</pre></div></div><br class="example-break"><div class="example"><a name="d0e1001"></a><p class="title"><b>Example&nbsp;2.8.&nbsp;Example: modify() block using MVEL dialect</b></p><div class="example-contents"><pre class="programlisting">rule "Eat Cheese"
  dialect "mvel"
when
  $p: Person( status == "hungry" )
  $c: Cheese( )
then
  retract( $c );
  modify( $p ) {
      status = "full",
      age = $p.age + 1
  }
end</pre></div></div><br class="example-break"><p><span class="bold"><strong>3. In your application, attributes are
        only changed between calls to modifyRetract() and
        modifyInsert():</strong></span> this way, the engine becomes aware that
        attributes will be changed and can prepare itself for them.</p><div class="example"><a name="d0e1010"></a><p class="title"><b>Example&nbsp;2.9.&nbsp;Example: safely modifying attributes in the application
          code</b></p><div class="example-contents"><pre class="programlisting">         // create session
         StatefulSession session = ruleBase.newStatefulSession();
      
         // get facts
         Person person = new Person( "Bob", 30 );
         person.setLikes( "cheese" );
      
         // insert facts
         FactHandle handle = session.insert( person );
      
         // do application stuff and/or fire rules
         session.fireAllRules();
      
         // wants to change attributes? 
         session.modifyRetract( handle ); // call modifyRetract() before doing changes
         person.setAge( 31 );
         person.setLikes( "chocolate" );
         session.modifyInsert( handle, person ); // call modifyInsert() after the changes
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e1015"></a>2.5.4.6.2.&nbsp;How to disable Shadow Facts?</h5></div></div></div><p>To disable shadow fact for all classes set the following
        property in a configuration file of system property:</p><pre class="programlisting">drools.shadowProxy = false</pre><p>Alternatively, it is possible to disable through an API
        call:</p><pre class="programlisting">RuleBaseConfiguration conf = new RuleBaseConfiguration();
conf.setShadowProxy( false );
...
RuleBase ruleBase = RuleBaseFactory.newRuleBase( conf );
</pre><p>To disable the shadow proxy for a list of classes only, use the
        following property instead, or the equivalent API:</p><pre class="programlisting">drools.shadowproxy.exclude = org.domainy.* org.domainx.ClassZ</pre><p>As shown above, a space separated list is used to specify more
        than one class, and '*' is used as a wild card.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1032"></a>2.5.4.7.&nbsp;Property Change Listener</h4></div></div></div><p>If your fact objects are Java Beans, you can implement a property
      change listener for them, and then tell the rule engine about it. This
      means that the engine will automatically know when a fact has changed,
      and behave accordingly (you don't need to tell it that it is modified).
      There are proxy libraries that can help automate this (a future version
      of drools will bundle some to make it easier). To use the Object in
      dynamic mode specify true for the second assertObject parameter.</p><pre class="programlisting">Cheese stilton = new Cheese("stilton");
FactHandle stiltonHandle = workingMemory.insert( stilton, true );  //specifies that this is a dynamic fact            </pre><p>To make a JavaBean dynamic add a PropertyChangeSupport field
      memory along with two add/remove mothods and make sure that each setter
      notifies the PropertyChangeSupport instance of the change.</p><pre class="programlisting">private final PropertyChangeSupport changes = new PropertyChangeSupport( this );
...
public void addPropertyChangeListener(final PropertyChangeListener l) {
    this.changes.addPropertyChangeListener( l );
}

public void removePropertyChangeListener(final PropertyChangeListener l) {
    this.changes.removePropertyChangeListener( l );
}
...

public void setState(final String newState) {
    String oldState = this.state;
    this.state = newState;
    this.changes.firePropertyChange( "state",
                                      oldState,
                                      newState );
}              </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1043"></a>2.5.4.8.&nbsp;Initial Fact</h4></div></div></div><p>To support conditional elements like "not" (which will be covered
      later on), there is a need to "seed" the engine with something known as
      the "Initial Fact". This fact is a special fact that is not intended to
      be seen by the user.</p><p>On the first working memory action (assert, fireAllRules) on a
      fresh working memory, the Initial Fact will be propagated through the
      RETE network. This allows rules that have no LHS, or perhaps do not use
      normal facts (such as rules that use "from" to pull data from an
      external source). For instance, if a new working memory is created, and
      no facts are asserted, calling the fireAllRules will cause the Initial
      Fact to propagate, possibly activating rules (otherwise, nothing would
      happen as there area no other facts to start with).</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1050"></a>2.5.5.&nbsp;StatefulSession</h3></div></div></div><div class="figure"><a name="d0e1053"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/StatefulSession.png" align="middle" alt="StatefulSession"></div></div><p class="title"><b>Figure&nbsp;2.20.&nbsp;StatefulSession</b></p></div><br class="figure-break"><p>The StatefulSession extends the WorkingMemory class. It simply adds
    async methods and a dispose() method. The ruleBase retains a reference to
    each StatefulSession is creates, so that it can update them when new rules
    are added, dispose() is needed to release the StatefulSession reference
    from the RuleBase, without it you can get memory leaks.</p><div class="example"><a name="d0e1063"></a><p class="title"><b>Example&nbsp;2.10.&nbsp;Createing a StatefulSession</b></p><div class="example-contents"><pre class="programlisting">StatefulSession session = ruleBase.newStatefulSession();</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1068"></a>2.5.6.&nbsp;Stateless Session</h3></div></div></div><div class="figure"><a name="d0e1071"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/StatelessSession.png" align="middle" alt="StatelessSession"></div></div><p class="title"><b>Figure&nbsp;2.21.&nbsp;StatelessSession</b></p></div><br class="figure-break"><p>The StatelessSession wraps the WorkingMemory, instead of extending
    it, its main focus is on decision service type scenarios.</p><div class="example"><a name="d0e1081"></a><p class="title"><b>Example&nbsp;2.11.&nbsp;Createing a StatelessSession</b></p><div class="example-contents"><pre class="programlisting">StatelessSession session = ruleBase.newStatelessSession();
session.execute( new Cheese( "cheddar" ) );</pre></div></div><br class="example-break"><p>The api is reduced for the problem domain and is thus much simpler;
    which in turn can make maintenance of those services easier. The RuleBase
    never retains a reference to the StatelessSession, thus dispose() is not
    needed, and they only have an execute() method that takes an object, an
    array of objects or a collection of objects - there is no insert or
    fireAllRules. The execute method iterates the objects inserting each and
    calling fireAllRules() at the end; session finished. Should the session
    need access to any results information they can use the executeWithResults
    method, which returns a StatelessSessionResult. The reason for this is in
    remoting situations you do not always want the return payload, so this way
    its optional.</p><p>setAgendaFilter, setGlobal and setGlobalResolver share their state
    across sessions; so each call to execute() will use the set AgendaFilter,
    or see any previous set globals etc.</p><p>StatelessSessions do not currently support
    propertyChangeLissteners.</p><p>Async versions of the Execute method are supported, remember to
    override the ExecutorService implementation when in special managed thread
    environments such as JEE.</p><p>StatelessSessions also support sequential mode, which is a special
    optimised mode that uses less memory and executes faster; please see the
    Sequential section for more details.</p><div class="figure"><a name="d0e1096"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/StatelessSessionResult.png" align="middle" alt="StatelessSessionResult"></div></div><p class="title"><b>Figure&nbsp;2.22.&nbsp;StatelessSessionResult</b></p></div><br class="figure-break"><p>StatelessSession.executeWithResults(....) returns a minimal api to
    examine the sessions data. The inserted Objects can be iterated over,
    querries can be executed and globals retrieved. Once the
    StatelessSessionResult is serialised it loses the reference to the
    underlying WorkingMemory and RuleBase, so querries can no longer be
    executed, however globals can still be retrieved and objects iterated. To
    retrieve globals they must be exported from the StatelessSession; the
    GlobalExporter strategy is set with StatelessSession.setGlobalExporter(
    GlobalExporter globalExporter ). Two implementations of GlobalExporter are
    available and users may implement their own strategies.
    CopyIdentifiersGlobalExporter copies named identifiers into a new
    GlobalResovler that is passed to the StatelessSessionResult; the
    constructor takes a String[] array of identifiers, if no identifiers are
    specified it copies all identifiers declaredin the RuleBase.
    ReferenceOriginalGlobalExporter just passes a reference to the original
    Global Resolver; the later should be used with care as identifier
    instances can be changed at any time by the StatelessSession and the
    GlobalResolver may not be serialisable freindly.</p><div class="example"><a name="d0e1106"></a><p class="title"><b>Example&nbsp;2.12.&nbsp;GlobalExporter with StatelessSessions</b></p><div class="example-contents"><pre class="programlisting">StatelessSession session = ruleBase.newStatelessSession();
session.setGlobalExporter( new CopyIdentifiersGlobalExporter( new String[]{"list"} ) );
StatelessSessionResult result = session.executeWithResults( new Cheese( "stilton" ) );
List list = ( List ) result.getGlobal( "list" );</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1111"></a>2.5.7.&nbsp;Agenda</h3></div></div></div><div class="figure"><a name="d0e1114"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/Agenda.png" align="middle" alt="Two Phase Execution"></div></div><p class="title"><b>Figure&nbsp;2.23.&nbsp;Two Phase Execution</b></p></div><br class="figure-break"><p>The Agenda is a RETE feature. During a Working Memory Action rules
    may become fully matched and eligible for execution; a single Working
    Memory Action can result in multiple eligible rules. When a rule is fully
    matched an Activation is created, referencing the Rule and the matched
    facts, and placed onto the Agenda. The Agenda controls the execution order
    of these Activations using a Conflict Resolution strategy.</p><p>The engine operates in a "2 phase" mode which is recursive:</p><div class="orderedlist"><ol type="1"><li><p>Working Memory Actions - this is where most of the work takes
        place - in either the Consequence or the main java application
        process. Once the Consequence has finished or the main Java
        application process calls fireAllRules() the engine switches to the
        Agenda Evaluation phase.</p></li><li><p>Agenda Evaluation - attempts to select a rule to fire, if a rule
        is not found it exits, otherwise it attempts to fire the found rule,
        switching the phase back to Working Memory Actions and the process
        repeats again until the Agenda is empty.</p></li></ol></div><div class="figure"><a name="d0e1133"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/Two_Phase.png" align="middle" alt="Two Phase Execution"></div></div><p class="title"><b>Figure&nbsp;2.24.&nbsp;Two Phase Execution</b></p></div><br class="figure-break"><p>The process recurses until the agenda is clear, in which case
    control returns to the calling application. When Working Memory Actions
    are taking place, no rules are being fired.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1143"></a>2.5.7.1.&nbsp;Conflict Resolution</h4></div></div></div><p>Conflict resolution is required when there are multiple rules on
      the agenda. As firing a rule may have side effects on working memory,
      the rule engine needs to know in what order the rules should fire (for
      instance, firing ruleA may cause ruleB to be removed from the
      agenda).</p><p>The default conflict resolution strategies emplyed by Drools are:
      Salience and LIFO (last in, first out).</p><p>The most visible one is "salience" or priority, in which case a
      user can specify that a certain rule has a higher priority (by giving it
      a higher number) then other rules. In that case, the higher salience
      rule will always be preferred. LIFO priorities based on the assigned
      Working Memory Action counter value, multiple rules created from the
      same action have the same value - execution of these are considered
      arbitrary.</p><p>As a general rule, it is a good idea not to count on the rules
      firing in any particular order, and try and author the rules without
      worrying about a "flow".</p><p>Custom conflict resolution strategies can be specified by setting
      the Class in the RuleBaseConfiguration method setConflictResolver, or
      using the property "drools.conflictResolver".</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1156"></a>2.5.7.2.&nbsp;Agenda Groups</h4></div></div></div><p>Agenda groups are a way to partition rules (activations, actually)
      on the agenda. At any one time, only one group has "focus" which means
      that the activations for rules in that group will only take effect - you
      can also have rules "auto focus" which means the focus for its agenda
      group is taken when that rules conditions are true.</p><p>They are sometimes known as "modules" in CLIPS terminology. Agenda
      groups are a handy way to create a "flow" between grouped rules. You can
      switch the group which has focus either from within the rule engine, or
      from the API. If you rules have a clear need for multiple "phases" or
      "sequences" of processing, consider using agenda-groups for this
      purpose.</p><p>Each time setFocus(...) is called it pushes that Agenda Group onto
      a stack, when the focus group is empty it is popped off and the next one
      of the stack evaluates. An Agenda Group can appear in multiple locations
      on the stack. The default Agenda Group is "MAIN", all rules which do not
      specify an Agenda Group are placed there, it is also always the first
      group on the Stack and given focus as default.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1165"></a>2.5.7.3.&nbsp;Agenda Filters</h4></div></div></div><div class="figure"><a name="d0e1168"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/AgendaFilter.png" align="middle" alt="AgendaFilters"></div></div><p class="title"><b>Figure&nbsp;2.25.&nbsp;AgendaFilters</b></p></div><br class="figure-break"><p>Filters are optional implementations of a the filter interface
      which are used to allow/or deny an activation from firing (what you
      filter on, is entirely up to the implementation). Drools provides the
      following convenience default implementations</p><div class="itemizedlist"><ul type="disc"><li><p>RuleNameEndWithAgendaFilter</p></li><li><p>RuleNameEqualsAgendaFilter</p></li><li><p>RuleNameStartsWithAgendaFilter</p></li><li><p>RuleNameMatchesAgendaFilter</p></li></ul></div><p>To use a filter specify it while calling FireAllRules. The
      following example will filter out all rules ending with the text
      "Test":</p><pre class="programlisting">workingMemory.fireAllRules( new RuleNameEndsWithAgendaFilter( "Test" ) );      </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1195"></a>2.5.8.&nbsp;Truth Maintenance with <a class="indexterm" name="d0e1198"></a> Logical Objects</h3></div></div></div><p>In a regular insert, you need to explicitly retract a fact. With
    logical assertions, the fact that was asserted will be automatically
    retracted when the conditions that asserted it in the first place are no
    longer true (it's actually more clever then that! If there are no possible
    conditions that could support the logical assertion, only then will it be
    retracted).</p><p>Normal insertions are said to be &#8220;STATED&#8221; (ie The Fact has been
    stated - just like the intuitive concept). Using a HashMap and a counter
    we track how many times a particular equality is STATED; this means we
    count how many different instances are equal. When we logically insert an
    object we are said to justify it and it is justified by the firing rule.
    For each logical insertion there can only be one equal object, each
    subsequent equal logical insertion increases the justification counter for
    this logical assertion. As each justification is removed when we have no
    more justifications the logical object is automatically retracted.</p><p>If we logically insert an object when there is an equal STATED
    object it will fail and return null. If we STATE an object that has an
    exist equal object that is JUSTIFIED we override the Fact - how this
    override works depends on the configuration setting
    "WM_BEHAVIOR_PRESERVE". When the property is set to discard we use the
    existing handle and replace the existing instance with the new Object -
    this is the default behavior - otherwise we override it to STATED but we
    create an new FactHandle.</p><p>This can be confusing on a first read, so hopefully the flow charts
    below help. When it says that it returns a new FactHandle, this also
    indicates the Object was propagated through the network.</p><div class="figure"><a name="d0e1210"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/Stated_Assertion.png" align="middle" alt="Stated Insertion"></div></div><p class="title"><b>Figure&nbsp;2.26.&nbsp;Stated Insertion</b></p></div><br class="figure-break"><div class="figure"><a name="d0e1218"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/Logical_Assertion.png" align="middle" alt="Logical Insertion"></div></div><p class="title"><b>Figure&nbsp;2.27.&nbsp;Logical Insertion</b></p></div><br class="figure-break"><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1226"></a>2.5.8.1.&nbsp;Example Scenario</h4></div></div></div><p>An example may make things clearer. Imagine a credit card
      processing application, processing transactions for a given account (and
      we have a working memory accumulating knowledge about a single accounts
      transaction). The rule engine is doing its best to decide if
      transactions are possibly fraudulent or not. Imagine this rule base
      basically has rules that kick in when there is "reason to be suspicious"
      and when "everything is normal".</p><p>Of course there are many rules that operate no matter what
      (performing standard calculations, etc.). Now there are possibly many
      reasons as to what could trigger a "reason to be suspicious": someone
      notifying the bank, a sequence of large transactions, transactions for
      geographically disparate locations or even reports of credit card theft.
      Rather then smattering all the little conditions in lots of rules,
      imagine there is a fact class called "SuspiciousAccount".</p><p>Then there can be a series of rules whose job is to look for
      things that may raise suspicion, and if they fire, they simply insert a
      new SuspiciousAccount() instance. All the other rules just have
      conditions like "not SuspiciousAccount()" or "SuspiciousAccount()"
      depending on their needs. Note that this has the advantage of allowing
      there to be many rules around raising suspicion, without touching the
      other rules. When the facts causing the SuspiciousAccount() insertion
      are removed, the rule engine reverts back to the normal "mode" of
      operation (and for instance, a rule with "not SuspiciousAccount()" may
      kick in which flushes through any interrupted transactions).</p><p>If you have followed this far, you will note that truth
      maintenance, like logical assertions, allows rules to behave a little
      like a human would, and can certainly make the rules more
      manageable.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1237"></a>2.5.8.2.&nbsp;Important note: Equality for Java objects</h4></div></div></div><p>It is important to note that for Truth Maintenance (and logical
      assertions) to work at all, your Fact objects (which may be Javabeans)
      override equals and hashCode methods (from java.lang.Object) correctly.
      As the truth maintenance system needs to know when 2 different physical
      objects are equal in value, BOTH equals and hashCode must be overridden
      correctly, as per the Java standard.</p><p>Two objects are equal if and only if their equals methods return
      true for each other and if their hashCode methods return the same
      values. See the Java API for more details (but do keep in mind you MUST
      override both equals and hashCode).</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1244"></a>2.5.9.&nbsp;Event Model</h3></div></div></div><p>The event package provides means to be notified of rule engine
    events, including rules firing, objects being asserted, etc. This allows
    you to separate out logging/auditing activities from the main part of your
    application (and the rules) - as events are a cross cutting
    concern.</p><p>There are three types of event listeners -
    WorkingMemoryEventListener, AgendaEventListener
    RuleFlowEventListener.</p><div class="figure"><a name="d0e1251"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/WorkingMemoryEventListener.png" align="middle" alt="WorkingMemoryEventListener"></div></div><p class="title"><b>Figure&nbsp;2.28.&nbsp;WorkingMemoryEventListener</b></p></div><br class="figure-break"><div class="figure"><a name="d0e1259"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/AgendaEventListener.png" align="middle" alt="AgendaEventListener"></div></div><p class="title"><b>Figure&nbsp;2.29.&nbsp;AgendaEventListener</b></p></div><br class="figure-break"><div class="figure"><a name="d0e1267"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/RuleFlowEventListener.png" align="middle" alt="RuEventListener"></div></div><p class="title"><b>Figure&nbsp;2.30.&nbsp;RuEventListener</b></p></div><br class="figure-break"><p>Both stateful and statless sessions implement the EventManager
    interface, which allows event listeners to be added to the session.</p><div class="figure"><a name="d0e1277"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Engine/EventManager.png" align="middle" alt="EventManager"></div></div><p class="title"><b>Figure&nbsp;2.31.&nbsp;EventManager</b></p></div><br class="figure-break"><p>All EventListeners have default implementations that implement each
    method, but do nothing, these are convienience classes that you can
    inherit from to save having to implement each method -
    DefaultAgendaEventListener, DefaultWorkingMemoryEventListener,
    DefaultRuleFlowEventListener. The following shows how to extend
    DefaultAgendaEventListener and add it to the session - the example prints
    statements for only when rules are fired:</p><pre class="programlisting">session.addEventListener( new DefaultAgendaEventListener() {                            
   public void afterActivationFired(AfterActivationFiredEvent event) {
       super.afterActivationFired( event );
       System.out.println( event );
   }
});       </pre><p>Drools also provides DebugWorkingMemoryEventListener,
    DebugAgendaEventListener and DebugRuleFlowEventListener that implements
    each method with a debug print statement:</p><pre class="programlisting">session.addEventListener( new DebugWorkingMemoryEventListener() );        </pre><p>The Eclipse based Rule IDE also provides an audit logger and
    graphical viewer, so that the rule engine can log events for later
    viewing, and auditing.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1295"></a>2.5.10.&nbsp;Sequential Mode</h3></div></div></div><p>With Rete you have a stateful session where objects can be asserted
    and modified over time, rules can also be added and removed. Now what
    happens if we assume a stateless session, where after the initial data set
    no more data can be asserted or modified (no rule re-evaluations) and
    rules cannot be added or removed? This means we can start to make
    assumptions to minimize what work the engine has to do.</p><div class="orderedlist"><ol type="1"><li><p>Order the Rules by salience and position in the ruleset (just
        sets a sequence attribute on the rule terminal node). 4</p></li><li><p>Create an array, one element for each possible rule activation;
        element position indicates firing order.</p></li><li><p>Turn off all node memories, except the right-input Object
        memory.</p></li><li><p>Disconnect the LeftInputAdapterNode propagation, and have the
        Object plus the Node referenced in a Command object, which is added to
        a list on the WorkingMemory for later execution.</p></li><li><p>Assert all objects, when all assertions are finished and thus
        right-input node memories are populated check the Command list and
        execute each in turn.</p></li><li><p>All resulting Activations should be placed in the array, based
        upon the determined sequence number of the Rule. Record the first and
        last populated elements, to reduce the iteration range.</p></li><li><p>Iterate the array of Activations, executing populated element in
        turn.</p></li><li><p>If we have a maximum number of allowed rule executions, we can
        exit our network evaluations early to fire all the rules in the
        array.</p></li></ol></div><p>The LeftInputAdapterNode no longer creates a Tuple, adding the
    Object, and then propagate the Tuple &#8211; instead a Command Object is created
    and added to a list in the Working Memory. This Command Object holds a
    reference to the LeftInputAdapterNode and the propagated Object. This
    stops any left-input propagations at insertion time, so that we know that
    a right-input propagation will never need to attempt a join with the
    left-inputs (removing the need for left-input memory). All nodes have
    their memory turned off, including the left-input Tuple memory but
    excluding the right-input Object memory &#8211; i.e. The only node that
    remembers an insertion propagation is the right-input Object memory. Once
    all the assertions are finished, and all right-input memories populated,
    we can then iterate the list of LeftInputAdatperNode Command objects
    calling each in turn; they will propagate down the network attempting to
    join with the right-input objects; not being remembered in the left input,
    as we know there will be no further object assertions and thus
    propagations into the right-input memory.</p><p>There is no longer an Agenda, with a priority queue to schedule the
    Tuples, instead there is simply an array for the number of rules. The
    sequence number of the RuleTerminalNode indicates the element with the
    array to place the Activation. Once all Command Objects have finished we
    can iterate our array checking each element in turn and firing the
    Activations if they exist. To improve performance in the array we remember
    record the first and last populated cells. The network is constructed
    where each RuleTerminalNode is given a sequence number, based on a
    salience number and its order of being added to the network.</p><p>Typically the right-input node memories are HashMaps, for fast
    Object retraction, as we know there will be no Object retractions, we can
    use a list when the values of the Object are not indexed. For larger
    numbers of Objects indexed HashMaps provide a performance increase; if we
    know an Object type has a low number of instances then indexing is
    probably not of an advantage and an Object list can be used.</p><p>Sequential mode can only be used with a StatelessSession and is off
    by default. To turn on either set the RuleBaseConfiguration.setSequentail
    to true or set the rulebase.conf property drools.sequential to true.
    Sequential mode can fallback to a dynamic agenda with setSequentialAgenda
    to either SequentialAgenda.SEQUENTIAL or SequentialAgenda.DYNAMIC setter
    or the "drools.sequential.agenda" property</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e1334"></a>Chapter&nbsp;3.&nbsp;Installation and Setup (Core and IDE)</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1337"></a>3.1.&nbsp;Installing and using</h2></div></div></div><p>Drools provides an eclipse based IDE (which is optional), but at its
  core only Java 1.4 (J2SE) is required.</p><p>A simple way to get started is to download and install the eclipse
  plug in - this will also require the Eclipse GEF framework to be installed
  (see below, if you don't have it installed already). This will provide you
  with all the dependencies you need to get going: you can simply create a new
  rule project and everything will be done for you. Refer to the chapter on
  the Rule Workbench and IDE for detailed instructions on this. Installing the
  eclipse plugin is generally as simple as unzipping a file into your eclipse
  plugin directory.</p><p>Use of the eclipse plug in is not required. Rule files are just
  textual input (or spreadsheets as the case may be) and the IDE (also known
  as the Rule Workbench) is just a convenience. People have integrated the
  rule engine in many ways, there is no "one size fits all".</p><p>Alternatively, you can download the binary distribution, and include
  the relevant jars in your projects classpath.</p><p></p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1349"></a>3.1.1.&nbsp;Dependencies and jars</h3></div></div></div><p>Drools is broken down into a few modules, some are required during
    rule development/compiling, and some are required at runtime. In many
    cases, people will simply want to include all the dependencies at runtime,
    and this is fine. It allows you to have the most flexibility. However,
    some may prefer to have their "runtime" stripped down to the bare minimum,
    as they will be deploying rules in binary form - this is also possible.
    The core runtime engine can be quite compact, and only require a few 100
    kilobytes across 2 jar files.</p><p>The following is a description of the important libraries that make
    up JBoss Rules</p><div class="itemizedlist"><ul type="disc"><li><p>drools-core.jar - this is the core engine, runtime component.
        Contains both the RETE engine and the LEAPS engine. This is the only
        runtime dependency if you are pre-compiling rules (and deploying via
        Package or RuleBase objects).</p></li><li><p>drools-compiler.jar - this contains the compiler/builder
        components to take rule source, and build executable rule bases. This
        is often a runtime dependency of your application, but it need not be
        if you are pre-compiling your rules. This depends on
        drools-core</p></li><li><p>drools-jsr94.jar - this is the JSR-94 compliant implementation,
        this is essentially a layer over the drools-compiler component. Note
        that due to the nature of the JSR-94 specification, not all features
        are easily exposed via this interface. In some cases, it will be
        easier to go direct to the drools API, but in some environments the
        JSR-94 is mandated.</p></li><li><p>drools-decisiontables.jar - this is the decision tables
        'compiler' component, which uses the drools-compiler component. This
        supports both excel and CSV input formats.</p></li></ul></div><p>There are quite a few other dependencies which the above components
    require, most of which are for the drools-compiler, drools-jsr94 or
    drools-decisiontables module. Some of these (such as the XML libraries)
    may not be required if you run in a Java 1.5 environment. Some key ones to
    note are "JCI" - which is the apache Java Compiler Interface utility which
    provides runtime compiling capability, "POI" which provides the
    spreadsheet parsing ability, and "antlr" which provides the parsing for
    the rule language itself.</p><p>NOTE: if you are using Drools in J2EE or servlet containers and you
    come across classpath issues with "JDT", then you can switch to the janino
    compiler. Set the system property "drools.compiler": For example:
    -Ddrools.compiler=JANINO.</p><p>For up to date info on dependencies in a release, consult the
    README_DEPENDENCIES.txt file, which can be found in the lib directory of
    the download bundle, or in the root of the project directory.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1375"></a>3.1.2.&nbsp;Runtime</h3></div></div></div><p>The "runtime" requirements mentioned here are if you are deploying
    rules as their binary form (either as Package objects, or RuleBase objects
    etc). This is an optional feature that allows you to keep your runtime
    very light. You may use drools-compiler to produce rule packages "out of
    process", and then deploy them to a runtime system. This runtime system
    only requires drools-core.jar for execution. This is an optional
    deployment pattern, and many people do not need to "trim" their
    application this much, but it is an ideal option for certain
    environments.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1380"></a>3.1.3.&nbsp;Installing IDE (Rule Workbench)</h3></div></div></div><p>The rule workbench (for Eclipse) requires that you have eclipse 3.2
    or greater, as well as Eclipse GEF 3.2 or greater. You can install it
    either by downloading the plugin or, or using the update site.</p><p>Another option is to use the JBoss IDE, which comes with all the
    plug in requirements pre packaged, as well as a choice of other tools
    separate to rules. You can choose just to install rules from the "bundle"
    that JBoss IDE ships with.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1387"></a>3.1.3.1.&nbsp;Installing GEF (a required dependency)</h4></div></div></div><p>GEF is the eclipse Graphical Editing Framework, which is used for
      graph viewing components in the plug in.</p><p>If you don't have GEF installed, you can install it using the
      built in update mechanism (or downloading GEF from the eclipse.org
      website not recommended). JBoss IDE has GEF already, as do many other "distributions" of
      Eclipse, so this step may be redundant for some people.</p><p>First you open the Help-&gt;Software updates-&gt;Find and install
      from the help menu. Then you choose the Calisto update site:</p><p>If you aren't using Calisto you can use the following update site do download GEF</p><pre class="programlisting">http://europa-mirror1.eclipse.org/tools/gef/update-site/releases/</pre><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/gef_update.png"></div></div><p>Next you choose the GEF plug in:</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/install_gef.png"></div></div><p>Press next, and agree to install the plug in (an eclipse restart
      may be required). Once this is completed, then you can continue on
      installing the rules plug in.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1412"></a>3.1.3.2.&nbsp;Installing from zip file</h4></div></div></div><p>To install from the zip file, download and unzip the file. Inside
      the zip you will see a plugin directory, and the plugin jar itself. You
      place the plugin jar into your eclipse applications plugin directory,
      and restart eclipse.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1417"></a>3.1.3.3.&nbsp;Installing from the update site</h4></div></div></div><p>Using the update site is a handy way to install the plug in, and
      keep it up to date (the eclipse platform will check for updates as
      needed). It gives you a good chance of staying up to date with
      improvements, fixes etc.</p><p>Some firewalls may cause trouble with using update sites in
      eclipse, if you have issues, then install it manually from the plugin.
      Also, if you have previously installed the plug in manually, you will
      need to manually remove it from your plug in directory.</p><p>Step 1. Use the eclipse help menu to find the feature installer.
      </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/help_menu.png"></div></div><p>Step 2: Choose the option for installing a new feature (obviously
      in future, if you want to check for updates, you use the other option
      !). </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/search_new_features.png"></div></div><p>Step 3: This screen will show what update sites are already
      configured for your Eclipse instance. </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/update_sites_existing.png"></div></div><p>Step 4: This screen is where you enter in the remote site details.
      You give it a name eg "JBoss Drools" and the url. </p><pre class="programlisting"> Check the Drools IDE Update Site section of the Drools Downloads webpage: 
			http://labs.jboss.com/drools/downloads.html</pre><p>
      </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/new_remote_site.png"></div></div><p>Step 5: Select the new update site you just added. Eclipse will
      remember this for when it checks for updates automatically in the
      future. </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/update_sites.png"></div></div><p>Step 6: You should see the available features (Drools IDE)
      retrieved from the update site. </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/search_results.png"></div></div><p>Step 7: The license agreement. Choose the option to accept the
      license agreement. Once this happens, the workbench will start
      downloading. Might be an opportune time to go have a coffee. </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/licence.png"></div></div><p>Step 8: Confirm that this is the feature you want. </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/confirm.png"></div></div><p>Step 9: Press Accept to accept the fact that the feature is not
      digitally signed. No one signs their features, its a silly default
      screen in Eclipse. </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/digital_sign.png"></div></div><p>Step 10: The workbench will need to restart now for the feature to
      take effect. </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/restart.png"></div></div><p>Now go have another coffee, and then take a look at the chapter on
      the Rule Workbench for what you can do with it.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1509"></a>3.2.&nbsp;Setup from source</h2></div></div></div><p>As Drools is an open source project, instructions for building from
  source are part of the manual ! Building from source means you can stay on
  top with the latest features. Whilst aspects of Drools are quite
  complicated, many users have found ways to become contributors.</p><p>Drools works with JDK1.5 and above. you will need also need to have
  the following tools installed. Minimum requirement version numbers
  provided.</p><div class="itemizedlist"><ul type="disc"><li><p><a class="indexterm" name="d0e1519"></a>Eclipse 3.2 </p><p>http://www.eclipse.org/</p></li><li><p><a class="indexterm" name="d0e1527"></a>Subversion Client 1.3</p><p>http://subversion.tigris.org</p><p><a class="indexterm" name="d0e1534"></a>http://tortoisesvn.tigris.org - recommended win32
      client</p></li><li><p><a class="indexterm" name="d0e1540"></a>Maven 2.0.7</p><p>http://maven.apache.org/</p></li><li><p><a class="indexterm" name="d0e1548"></a>Ant 1.7.0</p><p>http://ant.apache.org</p></li></ul></div><p>Ensure the executables for ant, maven and java are in your <a class="indexterm" name="d0e1556"></a>path. The examples given illustrative and are for a win32
  system:</p><div class="literallayout"><p>Path=D:\java\j2sdk1.5.0_8\bin;D:\java\apache-ant-1.7\bin;D:\java\maven-2.0.7\bin</p></div><p>Following environment variables will also need to be set. The examples
  given illustrative and are for a win32 system::</p><div class="literallayout"><p>JAVA_HOME=D:\java\j2sdk1.5.0_8<br>
ANT_HOME=D:\java\apache-ant-1.6.5<br>
MAVEN_HOME=D:\java\maven-2.0.7<br>
<br>
</p></div><p>
		Past releases used to have an ant based build mechanism, but now maven is mandatory, although Ant is used internally in maven for document building proposes
	</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1568"></a>3.3.&nbsp;Source Checkout</h2></div></div></div><p>Drools is available from two <a class="indexterm" name="d0e1573"></a>Subversion repositories.</p><div class="itemizedlist"><ul type="disc"><li><p>Anonymous SVN</p><p>http://anonsvn.labs.jboss.com/labs/jbossrules/trunk/</p></li><li><p>Developers secured SVN</p><p>https://svn.labs.jboss.com/labs/jbossrules/trunk/</p></li></ul></div>

To checkout drools source code just execute the following command.

<pre class="programlisting">fmeyer:~/jboss $ svn checkout http://anonsvn.labs.jboss.com/labs/jbossrules/trunk/ jbossrules</pre>

And wait to complete the files download.

<pre class="programlisting">A    jbossrules/drools-repository
A    jbossrules/drools-repository/.classpath
A    jbossrules/drools-repository/.project
A    jbossrules/drools-repository/doc
A    jbossrules/drools-repository/doc/repository_layout.jpeg
A    jbossrules/drools-repository/doc/high_level_design.jpeg
A    jbossrules/drools-repository/doc/javadoc
A    jbossrules/drools-repository/doc/javadoc/serialized-form.html
A    jbossrules/drools-repository/doc/javadoc/index-all.html
A    jbossrules/drools-repository/doc/javadoc/stylesheet.css
A    jbossrules/drools-repository/doc/javadoc/allclasses-frame.html
A    jbossrules/drools-repository/doc/javadoc/package-list
A    jbossrules/drools-repository/doc/javadoc/overview-tree.html
A    jbossrules/drools-repository/doc/javadoc/org
A    jbossrules/drools-repository/doc/javadoc/org/drools
A    jbossrules/drools-repository/doc/javadoc/org/drools/repository
A    jbossrules/drools-repository/doc/javadoc/org/drools/repository/class-use
A    jbossrules/drools-repository/doc/javadoc/org/drools/repository/class-use/RuleSet.html
A    jbossrules/drools-repository/doc/javadoc/org/drools/repository/class-use/RulesRepositoryException.html
A    jbossrules/drools-repository/doc/javadoc/org/drools/repository/class-use/RulesRepository.html
A    jbossrules/drools-repository/doc/javadoc/org/drools/repository/RuleSet.html

....

snip 

....

A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/benchmark/waltz
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/benchmark/waltz/waltz.drl
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/benchmark/manners
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/benchmark/manners/manners.drl
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/benchmark/waltzdb
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/benchmark/waltzdb/waltzdb.drl
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/TroubleTicketWithDSL.drl
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/TroubleTicket.drl
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/calculate.rfm
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/generation.rf
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/calculate.rf
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/registerNeighbor.rfm
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/killAll.rfm
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/registerNeighbor.rf
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/conway-agendagroup.drl
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/killAll.rf
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/conway-ruleflow.drl
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/conway/generation.rfm
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/ticketing.dsl
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/StateExampleUsingSalience.drl
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/golf.drl
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/LogicalAssertionsNotPingPong.drl
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/StateExampleDynamicRule.drl
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/sudoku
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/sudoku/sudoku.drl
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/HelloWorld.drl
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/ExamplePolicyPricing.xls
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/HonestPolitician.drl
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/Fibonacci.drl
A    jbossrules/drools-examples/drools-examples-drl/src/main/rules/org/drools/examples/StateExampleUsingAgendGroup.drl
A    jbossrules/drools-examples/drools-examples-drl/pom.xml
A    jbossrules/drools-examples/drools-examples-drl/build.xml
 U   jbossrules
Checked out revision 13656.</pre><p>Although, we highly recommend command line tools to work with repository you can also use both eclipse's integrated SVN client or TortoiseSVN</p><p>Setup TortoiseSVN to checkout from the subversion repository and click
  <code class="literal">'OK'</code> Once the checkout has finished you should see the
  folders as shown below.</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/svn_checkout1.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/svn_checkout2.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/svn_checkout3.jpg"></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1619"></a>3.4.&nbsp;Build</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1622"></a>3.4.1.&nbsp;Building the Source</h3></div></div></div><p>Now that we have the source the next step is to build and install
    the source. Since version 3.1 Drools uses <a class="indexterm" name="d0e1627"></a> to build the system. There are two profiles
    available which enable the associated modules "documentation" and
    "eclipse"; this enables quicker building of the core modules for
    developers. The eclipse profile will download eclipse into the
    drools-eclipse folder, which is over 100MB download (It depends on your operating system), however this only
    needs to be done once; if you wish you can move that eclipse download into
    another location and specify it with
    -DlocalEclipseDrop=/folder/jboss-rules/local-eclipse-drop-mirror. The
    following builds all the jars, the documentation and the eclipse zip with
    a local folder specified to avoid downloading eclipse:</p><pre class="programlisting">mvn -Declipse -Ddocumentation clean install -DlocalEclipseDrop=/folder/jboss-rules/local-eclipse-drop-mirror </pre><p>You can produce distribution builds, which puts everything into
    zips, as follows:
</p><pre class="programlisting">mvn -Declipse -Ddocumentation clean install -DlocalEclipseDrop=/folder/jboss-rules/local-eclipse-drop-mirror
mvn -Ddocumentation -Declipse -Dmaven.test.skip package javadoc:javadoc assembly:assembly -DlocalEclipseDrop=/folder/jboss-rules/local-eclipse-drop-mirror
</pre><p>Note that install must be done first as javadoc:javadoc won't work
    unless the jars are in the local maven repo, but the tests can be skipped
    on the second run. assembly:assembly fails unless you increase the
    available memory to Maven, on windows the following command worked well:
    set MAVEN_OPTS=-Xmx512m</p><p>Type mvn clean to clear old artifacts, and then test and built the
    source, and report on any errors.</p><p>The resulting jars are put in the /target directory from the top
    level of the project.</p><p>As maven builds each module it will install the resulting jars in
    the local Maven 2 repository automatically. Where it can be easily used
    from other project <code class="literal">pom.xml</code> or copied else where.</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/mvn_install4.jpg"></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1654"></a>3.4.2.&nbsp;Building the Manual</h3></div></div></div><p>
		The building of the manual is now integrated into the maven build process, and is built by either using the profile (-Ddocumentation) switch or 
		cding into the main directory. The manual can still be built from ant command line too by cding into the documentation/manual itself.
	</p><p>Drools uses <a class="indexterm" name="d0e1661"></a>Docbook for this manual. Ant is used internally in maven to build documents and this build produces three different formats, 
      all sharing the same images directory.</p><div class="itemizedlist"><ul type="disc"><li><p>html_single</p><p>The entire manual in a single html document</p></li><li><p><a class="indexterm" name="d0e1673"></a>html</p><p>The manual is split into multiple documents and placed in a
        frameset. The left frame provides navigation</p></li><li><p>eclipse</p><p>Documentation suitable for including in an eclipse plugin</p></li></ul></div><p>The manual can be generated from the project pom.xml by
    calling <code class="literal">'mvn package'</code> in the documentation directory or adding the -Ddocumentation switch when you build the sources, 
	with the generated documentation being copied to <code class="literal">'target/</code>. What actually happens is that maven
    call a separate ant build.xml for the manual, located at
    <code class="literal">documentation/manual</code>; the documentation is generated
    into <code class="literal">documentation/manual/build</code> before being copied to
    <code class="literal">'target/'.</code>

    </p><pre class="programlisting">fmeyer:~/projects/jbossrules/documentation $ mvn clean package
[INFO] Scanning for projects...
[INFO] ----------------------------------------------------------------------------
[INFO] Building Drools :: Documentation
[INFO]    task-segment: [install]
[INFO] ----------------------------------------------------------------------------
[INFO] [antrun:run {execution: manual}]
[INFO] Executing tasks
 [delete] Deleting directory /Users/fernandomeyer/projects/jbossrules/documentation/manual/build

clean:

all.doc:

lang.all:

lang.misc:
   [copy] Copying 188 files to /Users/fernandomeyer/projects/jbossrules/documentation/manual/build/en/shared/images
   [copy] Copying 1 file to /Users/fernandomeyer/projects/jbossrules/documentation/manual/build/en/shared/css

lang.dochtml:
  [mkdir] Created dir: /Users/fernandomeyer/projects/jbossrules/documentation/manual/build/en/html
   [copy] Copying 1 file to /Users/fernandomeyer/projects/jbossrules/documentation/manual/build/en/html
   [java] Writing bk01-toc.html for book
   [java] Writing pr01.html for preface(preface)
   [java] Writing ch01s02.html for section
   [java] Writing ch01s03.html for section
   [java] Writing ch01s04.html for section
   [java] Writing ch01s05.html for section
   [java] Writing ch01s06.html for section
   [java] Writing ch01.html for chapter
   [java] Writing ch02s02.html for section
   [java] Writing ch02s03.html for section
   [java] Writing ch02s04.html for section
   [java] Writing ch02s05.html for section
   [java] Writing ch02.html for chapter
   [java] Writing ch03s02.html for section
   [java] Writing ch03s03.html for section
   [java] Writing ch03s04.html for section
   [java] Writing ch03s05.html for section
   [java] Writing ch03s06.html for section
   [java] Writing ch03s07.html for section
   [java] Writing ch03s08.html for section
   [java] Writing ch03s09.html for section
   [java] Writing ch03.html for chapter
   [java] Writing ch04.html for chapter
   [java] Writing ch05.html for chapter
   [java] Writing ch06s02.html for section
   [java] Writing ch06s03.html for section
   [java] Writing ch06s04.html for section
   [java] Writing ch06s05.html for section
   [java] Writing ch06.html for chapter
   [java] Writing ch07s02.html for section
   [java] Writing ch07s03.html for section
   [java] Writing ch07.html for chapter
   [java] Writing ch08.html for chapter
   [java] Writing ch09.html for chapter
   [java] Writing ch10s02.html for section
   [java] Writing ch10.html for chapter
   [java] Writing ch11.html for chapter
   [java] Writing pt01.html for part
   [java] Writing ix01.html for index
   [java] Writing title.html for book

...snip ...

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 51 seconds
[INFO] Finished at: Mon Jul 21 12:03:38 BRT 2007
[INFO] Final Memory: 5M/10M
[INFO] ------------------------------------------------------------------------&gt;</pre><p>
    </p><p>The generated manual can be found in the
    <code class="literal">target\drools-documentation$VERSION.jar'</code> file, a compressed archive with all formats.</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/manual4.jpg"></div></div><p>The manual was first generated into the manual's
    <code class="literal">build</code> directory, as shown below, before being copied
    across.</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/manual3.jpg"></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1726"></a>3.5.&nbsp;Eclipse</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1729"></a>3.5.1.&nbsp;Generating Eclipse Projects</h3></div></div></div><p>The drools project has eclipse projects checked in for convenience.
    However, these are originally generated by maven 2. If you have maven 2
    installed, you can also regenerate the eclipse projects automatically, or
    even generate it for IntelliJ etc, see the instructions below for this
    (most people can ignore this section)</p><p><a class="indexterm" name="d0e1735"></a>Maven is able to generate standard <a class="indexterm" name="d0e1739"></a>Eclipse projects, but it is not able to generate Eclipse
    plugin projects. To generate the Eclipse projects for drools-core,
    drools-compiler and drools-jsr94 type <code class="literal">'mvn
    eclipse:eclipse'</code>.</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/mvn_eclipse1.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/mvn_eclipse2.jpg"></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1758"></a>3.5.2.&nbsp;Importing Eclipse Projects</h3></div></div></div><p>With the <a class="indexterm" name="d0e1763"></a>Eclispe project files generated they can now be imported
    into eclipse. When starting Eclipse open the workspace in the root of your
    subversion checkout.</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/eclipse_import1.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/eclipse_import2.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/eclipse_import3.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/eclipse_import4.jpg"></div></div><p>When calling <code class="literal">'mvn install'</code> all the project
    dependencies were downloaded and added to the local Maven repository.
    Eclipse cannot find those dependencies unless you tell it where that
    repository is. To do this setup an M2_REPO classpath variable.</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/eclipse_import6.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/eclipse_import7.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/eclipse_import8.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/eclipse_import9.jpg"></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1820"></a>3.5.3.&nbsp;Exporting the IDE Plugin</h3></div></div></div><p>The drools-ide project was checked out out using subversion and is
    ready for exporting.</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/eclipse_plugin1.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/eclipse_plugin2.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/eclipse_plugin3.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/eclipse_plugin4.jpg"></div></div><p>Once the plugin has been built open the output directory and copy
    the jar to the Eclipse plugin directory.</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/eclipse_plugin5.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/eclipse_plugin6.jpg"></div></div><p>At this point if Eclipse is already open it will need to be
    restarted. At which point you show now see the new Drools menu icon and
    drl's should have icons and be provided with syntax highlighting and
    intellisense.</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/eclipse_plugin7.jpg"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Install/eclipse_plugin8.jpg"></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1877"></a>3.5.4.&nbsp;Building the update site</h3></div></div></div><p>There is also an update site for the plug in. For developers who
    want to update the update site (ha) you will need to get to the update
    site project (or create a new one). They are kept in SVN, but in
    /jbossrules/update instead of /trunk. They are plain vanilla eclipse
    feature and site projects.</p><p>PLEASE REMEMBER that the plug in in the downloads directory, as a
    zip, should also be updated at the same time as the update site (as they
    are alternative ways ot getting the same plug in).</p><p>Eclipse refreshing plugins in features and sites seems to not work,
    so what is best is to manually edit the site.xml project and the
    feature.xml. To do this, open the site.xml file in the drools-ide-update
    project, it should look something like this: </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;site&gt;
   &lt;!-- change both the jar and the version number, make sure the new features jar is named
        the same as what you put in --&gt;
   &lt;feature url="features/org.drools.ide_1.0.2.jar" id="org.drools.ide" version="1.0.2"&gt;
  &lt;category name="JBossRules"/&gt;
   &lt;/feature&gt;
   &lt;category-def name="JBossRules" label="JBoss Rules"/&gt;
&lt;/site&gt;
</pre><p> Change the version attribute to be something new, and also
    the name of the feature jar to have a new version number at the
    end.</p><p>Go into the /feature directory, and unzip the feature jar to get to
    the feature.xml. (the feature jar really just contains the feature.xml).
    Open the feature.xml, and it should look like: </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;feature
  id="org.drools.ide"
  label="Drools Rule Workbench"
  version="1.0.2"&gt; &lt;!-- UPDATE THIS !! --&gt;

   &lt;description&gt;
  JBoss Rules (Drools) Workbench for developers.
   &lt;/description&gt;

   &lt;copyright&gt;
  Copyright 2005 JBoss Inc
   &lt;/copyright&gt;

   &lt;license&gt;
  Licensed under the Apache License, Version 2.0(the &amp;quot;License&amp;quot;);
 you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  
   http://www.apache.org/licenses/LICENSE-2.0
  
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
   &lt;/license&gt;

   &lt;plugin
 id="org.drools.ide"
 download-size="0"
 install-size="0"
 version="1.0.0"/&gt; &lt;!-- THIS JUST HAS TO BE CONSISTENT WITH THE PLUG IN --&gt;

&lt;/feature&gt;
</pre><p> Change the version number in the FEATURE tag to be the same
    as what you referred to in the site.xml. If you changed the version number
    of the main plug in, you will need to put the version number in the plug
    in tag (which refers to org.drools.ide plugin). Then zip up the
    feature.xml into a jar with the same name as you referred to in the
    site.xml.</p><p>Finally, drop the plugin jar into the /plugins jar directory of the
    update site (get the actual plug in from the exported plugin in the
    previous step). Now you can upload the site as is, and it will show up as
    a new version for Eclipse clients.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e1896"></a>Chapter&nbsp;4.&nbsp;Decision Tables</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1899"></a>4.1.&nbsp;Decision tables in spreadsheets</h2></div></div></div><p>Decision tables are a "precise yet compact" (ref. Wikipedia) way of
  representing conditional logic, and are well suited to "business" level
  rules.</p><p>Drools supports managing rules in a Spreadsheet format. Formats
  supported are Excel, and CSV. Thus you can use a variety of spreadsheet
  programs (such as Microsoft Excel, OpenOffice.org Calc amongst others). It
  is expected that web based decision table editors will be included in a near
  future release.</p><p>Decision tables are an old concept (in software terms) but have proven
  useful over the years. Very briefly speaking, in Drools decision tables are
  a way to generate rules driven from the data entered into a spreadsheet. All
  the usual features of a spreadsheet for data capture and manipulation can be
  taken advantage of.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1908"></a>4.1.1.&nbsp;When to use Decision tables</h3></div></div></div><p>You may want to consider decision tables if you have rules that can
    be expressed as rule templates + data. In each row of a decision table,
    data is collected that is combined with the templates to generate a
    rule.</p><p>Many businesses already use spreadsheets for managing data,
    calculations etc. If you are happy to continue this way, you can also
    manage your business rules this way. This also assumes you are happy to
    manage packages of rules in .xls or .csv files. Decision tables are not
    recommenced for rules that do not follow a set of templates, or where
    there are a small number of rules (or if you don't want to use software
    like excel or open office). They are ideal in the sense that you can
    control what "parameters" of rules can be edited, without exposing the
    rules directly.</p><p>Decision tables also provide a degree of insulation from the
    underlying object model.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1917"></a>4.1.2.&nbsp;Overview</h3></div></div></div><p>Here are some examples of real world decision tables (slightly
    edited to protect the innocent).</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Decision_Tables/excel.png"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Decision_Tables/actions.png"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Decision_Tables/open_office.png"></div></div><p>In the above examples, the technical aspects of the decision table
    have been collapsed away (standard spreadsheet feature).</p><p>The rules start from row 17 (each row results in a rule). The
    conditions are in column C, D, E etc.. (off screen are the actions). You
    can see that the value in the cells are quite simple, and have meaning
    when you look at the headers in Row 16. Column B is just a description. It
    is conventional to use color to make it obvious what the different areas
    of the table mean.</p><p>Note that although the decision tables look like they process top
    down, this is not necessarily the case. It is ideal if you can author
    rules in such a way as order does not matter (simply as it makes
    maintenance easier, you are not trying to shift rows around all the time).
    As each row is a rule, the same principles apply. As the rule engine
    processes the facts, any rules that match may fire (some people are
    confused by this - it is possible to clear the agenda when a rule fires
    and simulate a very simple decision table where the first match exists).
    Also note that you can have multiple tables on the one spreadsheet (so
    rules can be grouped where they share common templates - yet at the end of
    the day they are all combined into a one rule package). Decision tables
    are essentially a tool to generate DRL rules automatically.</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Decision_Tables/multi_table.png"></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1952"></a>4.1.3.&nbsp;How decision tables work</h3></div></div></div><p>The key point to keep in mind is that in a decision table, each row
    is a rule, and each column in that row is either a condition or action for
    that rule.</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Decision_Tables/row_col.png"></div></div><p>The spreadsheet looks for the "RuleTable" keyword to indicate the
    start of a rule table (both the starting row and column). Other keywords
    are also used to define other package level attributes (covered later). It
    is important to keep the keywords in the one column. By convention the
    second column ("B") is used for this, but it can be any column (convention
    is to leave a margin on the left for notes). In the following diagram, C
    is actually the column where it starts. Everything to the left of this is
    ignored.</p><p>If we expand the hidden sections, it starts to make more sense how
    it works. Note the keywords in column C.</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Decision_Tables/expanded.png"></div></div><p>Now you can see the hidden magic that makes it work. The RuleSet
    keyword indicates the name to be used in the "rule package" that all the
    rules will come under (the name is optional, it will have a default but
    you MUST have the "RuleSet" keyword) in the cell immediately to the right.
    The other keywords visible in Column C are: Import, Sequential which will
    be covered later - just note that in general the keywords make up
    name/value pairs. The RuleTable keyword is important as it indicates that
    a chunk of rules will follow, based on some rule templates. After the
    RuleTable keyword there is a name - this name is used to prefix the
    generated rules names (the row numbers are appended to create unique rule
    names). The column of RuleTable indicates the column in which the rules
    start (columns to the left are ignored).</p><p>Referring to row 14 (the row immediately after RuleTable): the
    keywords CONDITION and ACTION indicate that the data in the columns below
    are for either the LHS or the RHS parts of a rule. There are other
    attributes on the rule which can also be optionally set this way.</p><p>Row 15 contains declarations of "ObjectTypes" - the content in this
    row is optional (if you are not using it, you must leave a blank row - but
    you *will* want to use it !). When you use this row, the values in the
    cells below (row 16) become constraints on that object type. In the above
    case, it will generate: Person(age=="42") etc (where 42 comes from row
    18). In the above example, the "==" is implicit (if you just put a field
    name, it will assume that you are looking for exact matches). Also note
    that you can have a ObjectType declaration span columns (via merged cells)
    - and that means that all columns below the merged range will be combined
    into the one set of constraints.</p><p>Row 16 contains the rule templates themselves: note that they can
    use the "$para" place holder to indicate where data from the cells below
    will be populated (you can use $param, or $1, $2 etc to indicate
    parameters from a comma separated list in a cell below). Row 17 is ignored
    - it is textual descriptions of the rule template.</p><p>Row 18 to 19 shows data, which will be combined (interpolated) with
    the templates in row 15, to generate rules. If a cell contains no data,
    then its template is ignored (eg it means that condition, or action, does
    not apply for that rule-row). Rule rows are read until there is a BLANK
    row. You can have multiple RuleTables in a sheet. Row 20 contains another
    keyword, and a value - the row positions of keywords like this do not
    matter (most people put them at the top) but their column should be the
    same one where the RuleTable or RuleSet keywords should appear (in this
    case column C has been chosen to be significant, but you can use column A
    if you like).</p><p>In the above example, rules would be rendered like the following (as
    it uses the "ObjectType" row): </p><pre class="programlisting">//row 18
rule "Cheese_fans_18"
  when
    Person(age=="42")
    Cheese(type=="stilton")
  then
    list.add("Old man stilton");
end

</pre><p> Note that the [age=="42"] and [type=="stilton"] are
    interpreted as single constraints to be added to the respective ObjectType
    in the cell above (if the cells above were spanned, then there could be
    multiple constraints on one "column".</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1988"></a>4.1.4.&nbsp;Keywords and syntax</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1991"></a>4.1.4.1.&nbsp;Syntax of templates</h4></div></div></div><p>The syntax of what goes in the templates is dependent on if it is
      a CONDITION column or ACTION column. In most cases, it is identical to
      "vanilla" DRL for the LHS or RHS respectively. This means in the LHS,
      the constraint language must be used, and in the RHS it is a snippet of
      code to be executed.</p><p>The "$param" place holder is used in templates to indicate where
      data form the cell will be interpolated. You can also use "$1" to the
      same effect. If the cell contains a comma separated list of values, $1
      and $2 etc. may be used to indicate which positional parameter from the
      list of values in the cell will be used. </p><pre class="programlisting">For example: If the templates is [Foo(bar == $param)] and the cell is [ 42 ] then the result will be [Foo(bar == 42)]
If the template is [Foo(bar &lt; $1, baz == $2)] and the cell is [42,42] then the result will be [Foo(bar &gt; 42, baz ==42)]
</pre><p>For conditions: How snippets are rendered depends on if there is
      anything in the row above (where ObjectType declarations may appear). If
      there is, then the snippets are rendered as individual constraints on
      that ObjectType. If there isn't, then they are just rendered as is (with
      values substituted). If you put just a plain field (as in the example
      above) then it will assume you mean equality. If you put another
      operator at the end of the snippet, then the values will put
      interpolated at the end of the constraint, otherwise it will look for
      "$param" as outlined previously.</p><p>For consequences: How snippets are rendered also depends on if
      there is anything in the row immediately above it. If there is nothing
      there, the output is simple the interpolated snippets. If there is
      something there (which would typically be a bound variable or a global
      like in the example above) then it will append it as a method call on
      that object (refer to the above example).</p><p>This may be easiest to understand with some examples below.
      </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Decision_Tables/spanned_column.png"></div></div><p> The above shows how the Person ObjectType declaration
      spans 2 columns in the spreadsheet, thus both constraints will appear as
      Person(age == ... , type == ...). As before, as only the field names are
      present in the snippet, they imply an equality test. </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Decision_Tables/with_param.png"></div></div><p> The above condition example shows how you use
      interpolation to place the values in the snippet (in this case it would
      result in Person(age == "42")).</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Decision_Tables/operator_completion.png"></div></div><p> The above condition example show that if you put an
      operator on the end by itself, the values will be placed after the
      operator automatically. </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Decision_Tables/with_binding.png"></div></div><p> You can of course put a binding in before the column
      (the constraints will be added from the cells below). You can put
      anything in the ObjectType row (eg it could be a pre condition for the
      columns in the spreadsheet columns that follow).</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Decision_Tables/consequence.png"></div></div><p> This shows how the consequence could be done the by
      simple interpolation (just leave the cell above blank, the same applies
      to condition columns) - with this style you can put whatever you want in
      the consequence (not just one method call).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2031"></a>4.1.4.2.&nbsp;Keywords</h4></div></div></div><p>The following table describes the keywords that are pertinent to
      the rule table structure.</p><div class="table"><a name="d0e2036"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;Keywords</b></p><div class="table-contents"><table summary="Keywords" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Keyword</th><th>Description</th><th>Is required?</th></tr></thead><tbody><tr><td>RuleSet</td><td>The cell to the right of this contains the ruleset
              name</td><td>One only (if left out, it will default)</td></tr><tr><td>Sequential</td><td>The cell to the right of this can be true or false. If
              true, then salience is used to ensure that rules fire from the
              top down</td><td>optional</td></tr><tr><td>Import</td><td>The cell to the right contains a comma separated list of
              java classes to import</td><td>optional</td></tr><tr><td>RuleTable</td><td>A cell starting with RuleTable indicates the start of a
              definition of a rule table. The actual rule table starts the
              next row down. The rule table is read left-to-right, and
              top-down, until there is one BLANK ROW.</td><td>at least one. if there are more, then they are all added
              to the one ruleset</td></tr><tr><td>CONDITION</td><td>Indicates that this column will be for rule
              conditions</td><td>At least one per rule table</td></tr><tr><td>ACTION</td><td>Indicates that this column will be for rule
              consequences</td><td>At least one per rule table</td></tr><tr><td>PRIORITY</td><td>Indicates that this columns values will set the
              'salience' values for the rule row. Over-rides the 'Sequential'
              flag.</td><td>optional</td></tr><tr><td>DURATION</td><td>Indicates that this columns values will set the duration
              values for the rule row.</td><td>optional</td></tr><tr><td>NAME</td><td>Indicates that this columns values will set the name for
              the rule generated from that row</td><td>optional</td></tr><tr><td>Functions</td><td>The cell immediately to the right can contain functions
              which can be used in the rule snippets. Drools supports
              functions defined in the DRL, allowing logic to be embedded in
              the rule, and changed without hard coding, use with care. Same
              syntax as regular DRL.</td><td>optional</td></tr><tr><td>Variables</td><td>The cell immediately to the right can contain global
              declarations which drools supports. This is a type, followed by a
              variable name. (if multiple variables are needed, comma separate
              them).</td><td>optional</td></tr><tr><td>NO-LOOP</td><td>if there is a column with the this keyword, the
              no-loop attribute will be set for the rule. Setting no-loop column means the attempt to create the Activation for the current set of data will be ignored.</td><td>optional</td></tr><tr><td>ACTIVATION-GROUP</td><td>Cell values in this column mean that the rule-row belongs
              to the given XOR/activation group . An Activation group means
              that only one rule in the named group will fire (ie the first
              one to fire cancels the other rules activations).</td><td>optional</td></tr><tr><td>RULEFLOW-GROUP</td><td>Cell values in this column mean that the rule-row belongs
              to the given RULEFLOW-GROUP. Ruleflow allows you to specify the order in which rule sets should be evaluated by using a flow chart. See the documentation for ruleflow on this manual</td><td>optional</td></tr><tr><td>Worksheet</td><td>By default, the first worksheet is only looked at for
              decision tables.</td><td>N/A</td></tr></tbody></table></div></div><br class="table-break"><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Decision_Tables/Key.png"></div></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Decision_Tables/keywords.png"></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2166"></a>4.1.5.&nbsp;Creating and integrating Spreadsheet based Decision Tables</h3></div></div></div><p>The API to use spreadsheet based decision tables is in the
    drools-decisiontables module. There is really only one class to look at:
    SpreadsheetCompiler. This class will take spreadsheets in various formats,
    and generate rules in DRL (which you can then use in the normal way). Also
    note that if you like you can just use the SpreadsheetComiler to generate
    partial rule files, and assemble it into a complete rule package after the
    fact (this allows to you seperate technical and non technical aspects of
    the rules if needed).</p><p>To get started, you can find a sample spreadsheet and base it on
    that. Alternatively, if you are using the plug in (Rule Workbench IDE) the
    wizard can generate a spreadsheet for you from a template (to edit it you
    will need to use an xls compatible spreadsheet editor). </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Decision_Tables/wizard.png"></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2179"></a>4.1.6.&nbsp;Managing business rules in decision tables.</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2182"></a>4.1.6.1.&nbsp;Workflow and collaboration.</h4></div></div></div><p>Spreadsheets are well established business tools (in use for over
      25 years). Decision tables lend themselves to close collaboration
      between IT and domain experts, while making the business rules clear to
      business analysts, it is an ideal separation of concerns.</p><p>Typically, the whole process of authoring rules (coming up with a
      new decision table) would be something like:</p><div class="orderedlist"><ol type="1"><li><p>Business analyst takes a template decision table (from a
          repository, or from IT)</p></li><li><p>Decision table business language descriptions are entered in
          the table(s)</p></li><li><p>Decision table rules (rows) are entered (roughly)</p></li><li><p>Decision table is handed to a technical resource, who maps the
          business language (descriptions) to scripts (this may involve
          software development of course, if it is a new application or data
          model !)</p></li><li><p>Technical person hands back and reviews the modifications with
          the business analyst.</p></li><li><p>The business analyst can continue editing the rule rows as
          needed (moving columns around is also fine etc).</p></li><li><p>In parallel, the technical person can develop test cases for
          the rules (liaising with business analysts) as these test cases can
          be used to verify rules and rule changes once the system is
          running.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2211"></a>4.1.6.2.&nbsp;Using spreadsheet features</h4></div></div></div><p>You can use the features of applications like Excel to provide
      assistance in entering data into spreadsheets, such as validating
      fields. You can use lists that are stored in other worksheets to provide
      valid lists of values for cells, like in the following diagram.
      </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Decision_Tables/lists.png"></div></div><p>Some applications provide a limited ability to keep a history of
      changes, but it is recommended that an alternative means of revision
      control is also used. So when you are making changes to rules over time,
      older versions are archived (many solutions exist for this which are
      also open source, such as Subversion).
      http://www.drools.org/Business+rules+in+decision+tables+explained</p></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e2224"></a>Chapter&nbsp;5.&nbsp;The (Eclipse based) Rule IDE</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2227"></a>5.1.&nbsp;Introduction</h2></div></div></div><p>
    The IDE provides developers (and very technical users) with an environment to edit and test rules in various formats, and integrate it deeply with their applications. In cases where you prefer business rules and web tooling, you will want to look at the BRMS (but using the BRMS and the IDE together is not uncommon).</p><p>The Drools IDE is delivered as an eclipse plugin, which
  allows you to author and manage rules from within Eclipse, as well as
  integrate rules with your application. This is an optional tool, and not all
  components are required to be used, you can use what components are relevant
  to you. The Drools IDE is also a part of the Red Hat Developer Studio (formerly known as JBoss IDE).</p><p>This guide will cover some of the features of JBoss Drools, in as far
  as the IDE touches on them (it is assumed that the reader has some
  familiarity with rule engines, and Drools in particular. It is important to
  note that none of the underlying features of the rule engine are dependent
  on Eclipse, and integrators are free to use their tools of choice, as always
  ! Plenty of people use IntelliJ with rules, for instance.</p><p>Note you can get the plug in either as a zip to download, or from an
  update site (refer to the chapter on installation).</p><div class="figure"><a name="d0e2238"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-IDE/all.jpg" align="middle" alt="Overview"></div></div><p class="title"><b>Figure&nbsp;5.1.&nbsp;Overview</b></p></div><br class="figure-break"><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2244"></a>5.1.1.&nbsp;Features outline</h3></div></div></div><p>The rules IDE has the following features</p><div class="orderedlist"><ol type="1"><li><p>Textual/graphical rule editor</p><div class="orderedlist"><ol type="a"><li><p>An editor that is aware of DRL syntax, and provides content
            assistance (including an outline view)</p></li><li><p>An editor that is aware of DSL (domain specific langauge) extensions, and provides content assistance.</p></li></ol></div></li><li><p>RuleFlow graphical editor</p><p>You can edit visual graphs which represent a process (a rule flow). The RuleFlow can then be applied to your rule package to have imperative control.</p></li><li><p>Wizards to accelerate and ...</p><div class="orderedlist"><ol type="a"><li><p>Help you quickly create a new "rules" project</p></li><li><p>Create a new rule resource</p></li><li><p>Create a new Domain Specific language</p></li><li><p>Create a new decision table, guided editor, ruleflow</p></li></ol></div></li><li><p>A domain specific language editor</p><div class="orderedlist"><ol type="a"><li><p>Create and manage mappings from your users language to the
            rule language</p></li></ol></div></li><li><p>Rule validation</p><div class="orderedlist"><ol type="a"><li><p>As rules are entered, the rule is "built" in the background
            and errors reported via the problem "view" where possible</p></li></ol></div></li></ol></div><p>You can see the above features make use of Eclipse infrastructure
    and features. All of the power of eclipse is available.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2297"></a>5.1.2.&nbsp;Creating a Rule project</h3></div></div></div><p>The aim of the new project wizard is to setup an executable scaffold
    project to start using rules immediately. This will setup a basic
    structure, classpath and sample rules and test case to get you
    started.</p><div class="figure"><a name="d0e2302"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-IDE/new_project1.jpg" align="middle" alt="New rule project scaffolding"></div></div><p class="title"><b>Figure&nbsp;5.2.&nbsp;New rule project scaffolding</b></p></div><br class="figure-break"><p>When you choose to create a new "rule project" - you will get a choice to add some default artifacts to it (like rules, decision tables, ruleflows etc). These can serve as a starting point, and will give you something executable to play with (which you can then modify and mould to your needs). The simplest case (a hello world rule) is shown below. Feel free to experiment with the plugin at this point.</p><div class="figure"><a name="d0e2310"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-IDE/new_project2.png" align="middle" alt="New rule project result"></div></div><p class="title"><b>Figure&nbsp;5.3.&nbsp;New rule project result</b></p></div><br class="figure-break"><p>The newly created project contains an example rule file (Sample.drl)
    in the src/rules dir and an example java file (DroolsTest.java) that can
    be used to execute the rules in a Drools engine in the folder src/java, in
    the com.sample package. All the others jars that are necessary during
    execution are also added to the classpath in a custom classpath container
    called Drools Library. Rules do not have to be kept in "java"
    projects at all, this is just a convenience for people who are already
    using eclipse as their Java IDE.</p><p>Important note: The Drools plug in adds a "Drools Builder"
    capability to your eclipse instance. This means you can enable a builder
    on any project that will build and validate your rules when resources
    change. This happens automatically with the Rule Project Wizard, but you
    can also enable it manually on any project. One downside of this is if you
    have rule files that have a large number of rules (&gt;500 rules per file)
     it means that the background builder may be doing a lot of work to
    build the rules on each change. An option here is to turn off the builder,
    or put the large rules into .rule files, where you can still use the rule
    editor, but it won't build them in the background - to fully validate the
    rules you will need to run them in a unit test of course.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2320"></a>5.1.3.&nbsp;Creating a new rule and wizards</h3></div></div></div><p>You can create a rule simple as an empty text ".drl" file, or use
    the wizard to do so. The wizard menu can be invoked by Control+N, or
    choosing it from the toolbar (there will be a menu with the JBoss Drools
    icon).</p><div class="figure"><a name="d0e2325"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-IDE/wizards.jpg" align="middle" alt="The wizard menu"></div></div><p class="title"><b>Figure&nbsp;5.4.&nbsp;The wizard menu</b></p></div><br class="figure-break"><p>The wizard will ask for some basic options for generating a rule
    resource. These are just hints, you can change your mind later !. In terms
    of location, typically you would create a top level /rules directory to
    store your rules if you are creating a rule project, and store it in a
    suitably named subdirectory. The package name is mandatory, and is similar
    to a package name in java (ie. its a namespace that groups like rules
    together).</p><div class="figure"><a name="d0e2333"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-IDE/new_rule.jpg" align="middle" alt="New rule wizard"></div></div><p class="title"><b>Figure&nbsp;5.5.&nbsp;New rule wizard</b></p></div><br class="figure-break"><p>This result of this wizard is to generate a rule skeleton to work
    from. As with all wizards, they are candy: you don't have to use them if
    you don't want !</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2341"></a>5.1.4.&nbsp;Textual rule editor</h3></div></div></div><p>The rule editor is where rule managers and developers will be
    spending most of their time. The rule editor follows the pattern of a
    normal text editor in eclipse, with all the normal features of a text
    editor. On top of this, the rule editor provides pop up content
    assistance. You invoke popup content assistance the "normal" way by
    pressing Control + Space at the same time.</p><div class="figure"><a name="d0e2346"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-IDE/editor1.jpg" align="middle" alt="The rule editor in action"></div></div><p class="title"><b>Figure&nbsp;5.6.&nbsp;The rule editor in action</b></p></div><br class="figure-break"><p>The rule editor works on files that have a .drl (or .rule)
    extension. Rules are generally grouped together as a "package" of rules
    (like the old ruleset construct). It will also be possible to have rules
    in individual files (grouped by being in the same package "namespace" if
    you like). These DRL files are plain text files.</p><p>You can see from the example above that the package is using a
    domain specific language (note the expander keyword, which tells the rule
    compiler to look for a dsl file of that name, to resolve the rule
    language). Even with the domain specific language (DSL) the rules are
    still stored as plain text as you see on screen, which allows simpler
    management of rules and versions (comparing versions of rules for
    instance).</p><p>The editor has an outline view that is kept in sync with the
    structure of the rules (updated on save). This provides a quick way of
    navigating around rules by name, in a file which may have hundreds of
    rules. The items are sorted alphabetically by default.</p><div class="figure"><a name="d0e2358"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-IDE/outline.jpg" align="middle" alt="The rule outline view"></div></div><p class="title"><b>Figure&nbsp;5.7.&nbsp;The rule outline view</b></p></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2364"></a>5.1.5.&nbsp;Guided editor (rule GUI)</h3></div></div></div><p>
    A new feature of the Drools IDE (since version 4) is the guided editor for rules. This is similar to the web based editor that is available in the BRMS. This allows you to build rules in a GUI driven fashion, based on your object model. 
  </p><div class="figure"><a name="d0e2369"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-IDE/guidededitor1.png" align="middle" alt="The guided editor"></div></div><p class="title"><b>Figure&nbsp;5.8.&nbsp;The guided editor</b></p></div><br class="figure-break"><p>
      To create a rule this way, use the wizard menu. It will create a instance of a .brl file and open an editor. The guided editor works based on a .package file in the same directory as the .brl file. In this "package" file - you have the package name and import statements - just like you would in the top of a normal DRL file. So the first time you create a brl rule - you will need to ppulate the package file with the fact classes you are interested in. Once you have this the guided editor will be able to prompt you with facts/fields and build rules graphically.
    </p><p>
      The guided editor works off the model classes (fact classes) that you configure. It then is able to "render" to DRL the rule that you have entered graphically. You can do this visually - and use it as a basis for learning DRL, or you can use it and build rules of the brl directly. To do this, you can either use the drools-ant module (it is an ant task that will build up all the rule assets in a folder as a rule package - so you can then deploy it as a binary file), OR you can use the following snippet of code to convert the brl to a drl rule:

    </p><pre class="programlisting">BRXMLPersitence read = BRXMLPersitence.getInstance();
BRDRLPersistence write = BRDRLPersistence.getInstance();
String brl = ... read from the .brl file as needed...
String outputDRL = write.marshall(read.unmarshal(brl));
//then pass the outputDRL to the PackageBuilder as normal</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2381"></a>5.1.6.&nbsp;Views</h3></div></div></div><p>When debugging an application using a Drools engine, these views
    can be used to check the state of the Drools engine itself: the Working
    Memory View, the Agenda View the Global Data View. To be able to use
    these views, create breakpoints in your code invoking the working memory.
    For example, the line where you call workingMemory.fireAllRules() is a
    good candidate. If the debugger halts at that joinpoint, you should select
    the working memory variable in the debug variables view. The following
    rules can then be used to show the details of the selected working
    memory:</p><div class="orderedlist"><ol type="1"><li><p>The Working Memory shows all elements in the working memory of
        the Drools working memory.</p></li><li><p>The Agenda View shows all elements on the agenda. For each rule
        on the agenda, the rule name and bound variables are shown.</p></li><li><p>The Global Data View shows all global data currently defined in
        the Drools working memory.</p></li></ol></div><p>The Audit view can be used to show audit logs that contain events
    that were logged during the execution of a rules engine in a tree
    view.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2398"></a>5.1.6.1.&nbsp;The Working Memory View</h4></div></div></div><div class="mediaobject"><img src="../shared/images/Chapter-IDE/workingMemory.png"></div><p>The Working Memory shows all elements in the working memory of the
      Drools engine.</p><p>An action is added to the right of the view, to customize what is
      shown:</p><div class="orderedlist"><ol type="1"><li><p>The Show Logical Structure toggles showing the logical
          structure of the elements in the working memory, or all their
          details. Logical structures allow for example visualizing sets of
          elements in a more obvious way.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2412"></a>5.1.6.2.&nbsp;The Agenda View</h4></div></div></div><div class="mediaobject"><img src="../shared/images/Chapter-IDE/agenda.png"></div><p>The Agenda View shows all elements on the agenda. For each rule on
      the agenda, the rule name and bound variables are shown.</p><p>An action is added to the right of the view, to customize what is
      shown:</p><div class="orderedlist"><ol type="1"><li><p>The Show Logical Structure toggles showing the logical
          structure of the agenda item, or all their details. Logical
          structures allow for example visualizing sets of elements in a more
          obvious way. The logical structure of AgendaItems shows the rule
          that is represented by the AgendaItem, and the values of all the
          parameters used in the rule.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2426"></a>5.1.6.3.&nbsp;The Global Data View</h4></div></div></div><div class="mediaobject"><img src="../shared/images/Chapter-IDE/globals.png"></div><p>The Global Data View shows all global data currently defined in
      the Drools engine.</p><p>An action is added to the right of the view, to customize what is
      shown:</p><div class="orderedlist"><ol type="1"><li><p>The Show Logical Structure toggles showing the logical
          structure of the elements in the working memory, or all their
          details. Logical structures allow for example visualizing sets of
          elements in a more obvious way.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2440"></a>5.1.6.4.&nbsp;The Audit View</h4></div></div></div><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="../shared/images/Chapter-IDE/audit.jpg" width="100%"></td></tr></table></div><p>The audit view can be used to visualize an audit log that can be
      created when executing the rules engine. To create an audit log, use the
      following code:</p><pre class="programlisting">    WorkingMemory workingMemory = ruleBase.newWorkingMemory();
    // create a new Working Memory Logger, that logs to file.
    WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger(workingMemory);
    // an event.log file is created in the log dir (which must exist)
    // in the working directory
    logger.setFileName("log/event");

    workingMemory.assertObject( ... );
    workingMemory.fireAllRules();

    // stop logging
    logger.writeToDisk();</pre><p>Open the log by clicking the Open Log action (first action in the
      Audit View) and select the file. The Audit view now shows all events
      that where logged during the executing of the rules. There are different
      types of events (each with a different icon):</p><div class="orderedlist"><ol type="1"><li><p>Object inserted (green square)</p></li><li><p>Object updated (yellow square)</p></li><li><p>Object removed (red square)</p></li><li><p>Activation created (arrow to the right)</p></li><li><p>Activation cancelled (arrow to the left)</p></li><li><p>Activation executed (blue diamond)</p></li><li><p>Ruleflow started / ended (process icon)</p></li><li><p>Ruleflow-group activated / deactivated (process icon)</p></li><li><p>Rule package added / removed (Drools icon)</p></li><li><p>Rule added / removed (Drools icon)</p></li></ol></div><p>All these events show extra information concerning the event, like
      the id and toString representation of the object in case of working
      memory events (assert, modify and retract), the name of the rule and all
      the variables bound in the activation in case of an activation event
      (created, cancelled or executed). If an event occurs when executing an
      activation, it is shown as a child of the activation executed event. For
      some events, you can retrieve the "cause":</p><div class="orderedlist"><ol type="1"><li><p>The cause of an object modified or retracted event is the last
          object event for that object. This is either the object asserted
          event, or the last object modified event for that object.</p></li><li><p>The cause of an activation cancelled or executed event is the
          corresponding activation created event.</p></li></ol></div><p>When selecting an event, the cause of that event is shown in green
      in the audit view (if visible of course). You can also right click the
      action and select the "Show Cause" menu item. This will scroll you to
      the cause of the selected event.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2494"></a>5.1.7.&nbsp;Domain Specific Languages</h3></div></div></div><p>Domain Specific Languages (dsl) allow you to create a language that
    allows your rules to look like, rules ! Most often the domain specific
    language reads like natural language. Typically you would look at how a
    business analyst would describe the rule, in their own words, and then map
    this to your object model via rule constructs. A side benefit of this is
    that it can provide an insulation layer between your domain objects, and
    the rules themselves (as we know you like to refactor !). A domain
    specific language will grow as the rules grow, and works best when there
    are common terms used over an over, with different parameters.</p><p>To aid with this, the rule workbench provides an editor for domain
    specific languages (they are stored in a plain text format, so you can
    use any editor of your choice - it uses a slightly enhanced version of the
    "Properties" file format, simply). The editor will be invoked on any files
    with a .dsl extension (there is also a wizard to create a sample
    DSL).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2501"></a>5.1.7.1.&nbsp;Editing languages</h4></div></div></div><div class="figure"><a name="d0e2504"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-IDE/dsl_editor.jpg" align="middle" alt="The Domain Specific Language editor"></div></div><p class="title"><b>Figure&nbsp;5.9.&nbsp;The Domain Specific Language editor</b></p></div><br class="figure-break"><p>The DSL editor provides a table view of Language Expression to
      Rule Expression mapping. The Language expression is what is used in the
      rules. This also feeds the content assistance for the rule editor, so
      that it can suggest Language Expressions from the DSL configuration (the
      rule editor loads up the DSL configuration when the rule resource is
      loaded for editing). The Rule language mapping is the "code" for the
      rules - which the language expression will be compiled to by the rule
      engine compiler. For form of this Rule language depends if it is for a
      condition or action part of a rule (it may be a snippet of java, for
      instance). The "scope" item indicates where the expression is targeted:
      is it for the "when" part of the rule (LHS)? the "then" part (RHS)? Or
      anywhere?</p><p>By selecting a mapping item (a row in the table) you can see the
      expression and mapping in the greyed out fields below. Double clicking
      or pressing the edit button will open the edit dialog. You can remove
      items, and add new ones (you should generally only remove when you know
      that expression is no longer in use).</p><div class="figure"><a name="d0e2514"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-IDE/mapping_editor.jpg" align="middle" alt="Language Mapping editor dialog"></div></div><p class="title"><b>Figure&nbsp;5.10.&nbsp;Language Mapping editor dialog</b></p></div><br class="figure-break"><p>How it works: the "Language expression" is used to parse the rule
      language, depending on what the "scope" is set to. When it is found in a
      rule, the values that are market by the curly braces {value} are
      extracted from the rule source. These values are then interpolated with
      the "Rule mapping" expression, based on the names between the curly
      braces. So in the example above, the natural language expression maps
      to 2 constraints on a fact of type Person (ie the person object has the
      age field as less than {age}, and the location value is the string of
      {value}, where {age} and {value} are pulled out of the original rule
      source. The Rule mapping may be a java expression (such as if the scope
      was "then"). If you did not wish to use a language mapping for a
      particular rule in a drl, prefix the expression with &gt; and the
      compiler will not try to translate it according to the language
      definition. Also note that domain specific languages are optional. When
      the rule is compiled, the .dsl file will also need to be
      available.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2522"></a>5.1.8.&nbsp;The Rete View</h3></div></div></div><p>The Rete Tree View shows you the current Rete Network for your drl
    file. Just click on the tab "Rete Tree" below on the DRL Editor.
    Afterwards you can generate the current Rete Network visualization. You
    can push and pull the nodes to arrange your optimal network overview. If
    you got hundreds of nodes, select some of them with a frame. Then you can
    pull groups of them. You can zoom in and out, in case not all nodes are
    shown in the current view. For this press the button "+" oder "-".</p><p>There is no export function, which creates a gif or jpeg picture, in
    the current release. Please use ctrl + alt + print to create a copy of
    your current eclipse window and cut it off.</p><div class="mediaobject"><img src="../shared/images/Chapter-IDE/thereteview.jpg"></div><p>The graph is created with the Java Universal Network/Graph Framework
    (<a class="ulink" href="http://jung.sourceforge.net/" target="_top">JUNG</a>). The Rete View is
    an advanced feature which is still in experimental state. It uses Swing
    inside eclipse. In future it will maybe improved using SWT or GEF.</p><p>The Rete view works only in Drools Rule Projects, where the Drools
    Builder is set in the project&acute;s properties.</p><p>If you are using Drools in an other type of project, where you are
    not having a Drools Rule Project with the appropriate Drools Builder, you
    can create a little workaround:</p><p>Set up a little Drools Rule Project next to it, putting needed
    libraries into it and the drls you want to inspect with the Rete View.
    Just click on the right tab below in the DRL Editor, followed by a click
    on "Generate Rete View".</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2543"></a>5.1.9.&nbsp;Large drl files</h3></div></div></div><p>Depending on the JDK you use, it may be necessary to increase the
    permanent generation max size. Both SUN and IBM jdk have a permanent
    generation, whereas BEA JRockit does not.</p><p>To increase the permanent generation, start eclipse with
    -XX:MaxPermSize=###m</p><p>Example: c:\eclipse\eclipse.exe -XX:MaxPermSize=128m</p><p>Rulesets of 4,000 rules or greater should set the permanent
    generation to atleast 128Mb.</p><p>(note that this may also apply to compiling large numbers of rules
    in general - as there is generally one or more classes per rule).</p><p>As an alternative to the above, you may put rules in a file with the
    ".rule" extension, and the background builder will not try to compile them
    with each change, which may provide performance improvements if your IDE
    becomes sluggish with very large numbers of rules.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2558"></a>5.1.10.&nbsp;Debugging rules</h3></div></div></div><div class="figure"><a name="d0e2561"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-IDE/debug-overview.png" align="middle" alt="Debugging"></div></div><p class="title"><b>Figure&nbsp;5.11.&nbsp;Debugging</b></p></div><br class="figure-break"><p>You can debug rules during the execution of your Drools application.
      You can add breakpoints in the consequences of your rules, and whenever
      such a breakpoint is uncounted during the execution of the rules, the execution
      is halted.  You can then inspect the variables known at that point and use any
      of the default debugging actions to decide what should happen next (step over,
      continue, etc.).  You can also use the debug views to inspect the content of the
      working memory and agenda.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2569"></a>5.1.10.1.&nbsp;Creating breakpoints</h4></div></div></div><p>You can add/remove rule breakpoints in drl files in two ways, similar to adding
     breakpoints to Java files:</p><div class="orderedlist"><ol type="1"><li><p>Double-click the ruler of the DRL editor at the line where you want to
          add a breakpoint.  Note that rule breakpoints can only be created in the
          consequence of a rule.  Double-clicking on a line where no breakpoint is allowed
          will do nothing.  A breakpoint can be removed by double-clicking the ruler once more.
          </p></li><li><p>If you right-click the ruler, a popup menu will show up, containing the
          "Toggle breakpoint" action.  Note that rule breakpoints can only be created in the
          consequence of a rule.  The action is automatically disabled if no rule
          breakpoint is allowed at that line.  Clicking the action will add a breakpoint at the
          selected line, or remove it if there was one already.</p></li></ol></div><p>The Debug Perspective contains a Breakpoints view which can be used to see
     all defined breakpoints, get their properties, enable/disable or remove them, etc.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2583"></a>5.1.10.2.&nbsp;Debugging rules</h4></div></div></div><p>Drools breakpoints are only enabled if you debug your application as
      a Drools Application.  You can do this like this:</p><div class="figure"><a name="d0e2588"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-IDE/debugAsDrools.png" align="middle" alt="Debug as Drools Application"></div></div><p class="title"><b>Figure&nbsp;5.12.&nbsp;Debug as Drools Application</b></p></div><br class="figure-break"><div class="orderedlist"><ol type="1"><li><p>Select the main class of your application. Right click it and select the
          "Debug As &gt;" sub-menu and select Drools Application. Alternatively, you can also select
          the "Debug ..." menu item to open a
          new dialog for creating, managing and running debug configurations (see
          screenshot below)</p><div class="orderedlist"><ol type="a"><li><p>Select the "Drools Application" item in the left tree and click the "New
          launch configuration" button (leftmost icon in the toolbar above the tree).  This
          will create a new configuration and already fill in some of the properties
          (like the project and main class) based on main class you selected in the beginning.
          All properties shown here are the same as any standard Java program.</p></li><li><p>Change the name of your debug configuration to something meaningful.
          You can just accept the defaults for all other properties.  For more information
          about these properties, please check the eclipse jdt documentation.</p></li><li><p>Click the "Debug" button on the bottom to start debugging your application. You only have to define your debug configuration once.  The next time you try to run your Drools application, you don't have to create a new one but select the one you defined previously by selecting it in the tree on the left, as a sub-element of the "Drools Application"
     tree node, and then click the Debug button.  The eclipse toolbar also contains shortcut
     buttons to quickly re-execute the one of your previous configurations (at least when the
     Java, Java Debug, or Drools perspective has been selected).
              </p></li></ol></div></li></ol></div><div class="figure"><a name="d0e2608"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-IDE/debug_rules_configuration.png" align="middle" alt="Debug as Drools Application Configuration"></div></div><p class="title"><b>Figure&nbsp;5.13.&nbsp;Debug as Drools Application Configuration</b></p></div><br class="figure-break"><p>After clicking the "Debug" button, the application starts executing and will halt if any
     breakpoint is encountered.  This can be a Drools rule breakpoint, or any other standard
     Java breakpoint.  Whenever a Drools rule breakpoint is encountered, the corresponding drl
     file is opened and the active line is highlighted.  The Variables view also contains all rule
     parameters and their value. You can then use the default Java debug actions
     to decide what to do next (resume, terminate, step over, etc.).  The debug views can also
     be used to determine the contents of the working memory and agenda at that time as well
     (you don't have to select a working memory now, the current executing working memory
     is automatically shown).
     </p><div class="figure"><a name="d0e2616"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-IDE/debug.png" align="middle" alt="Debugging"></div></div><p class="title"><b>Figure&nbsp;5.14.&nbsp;Debugging</b></p></div><br class="figure-break"></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e2622"></a>Chapter&nbsp;6.&nbsp;The Rule Language</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2625"></a>6.1.&nbsp;Overview</h2></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><em class="replaceable"><code>(updated to Drools 4.0)</code></em></p></div><p>Drools 4.0 has a "native" rule language that is non XML textual
  format. This format is very light in terms of punctuation, and supports
  natural and domain specific languages via "expanders" that allow the
  language to morph to your problem domain. This chapter is mostly concerted
  with the native rule format. The Diagrams used are known as "rail road"
  diagrams, and are basically flow charts for the language terms. For the
  technically very keen, you can also refer to "DRL.g" which is the Antlr3
  grammar for the rule language. If you use the Rule Workbench, a lot of the
  rule structure is done for you with content assistance, for example, type
  "ru" and press ctrl+space, and it will build the rule structure for
  you.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2634"></a>6.1.1.&nbsp;A rule file</h3></div></div></div><p>A rule file is typically a file with a .drl extension. In a drl file
    you can have multiple rules, queries and functions, as well as some
    resource declarations like imports, globals and attributes that are
    assigned and used by your rules and queries. However, you are also able to
    spread your rules across multiple rule files (in that case, the extension
    .rule is suggested, but not required) - spreading rules across files can
    help with managing large numbers of rules. A DRL file is simply a text
    file.</p><p>The overall structure of a rule file is:</p><div class="example"><a name="d0e2641"></a><p class="title"><b>Example&nbsp;6.1.&nbsp;Rules file</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>package </strong></span><em class="replaceable"><code>package-name</code></em>

<em class="replaceable"><code>imports</code></em>

<em class="replaceable"><code>globals</code></em>

<em class="replaceable"><code>functions</code></em>

<em class="replaceable"><code>queries</code></em>

<em class="replaceable"><code>rules</code></em>
</pre></div></div><br class="example-break"><p>The order in which the elements are declared is not important,
    except for the package name that, if declared, must be the first element
    in the rules file. All elements are optional, so you will use only those
    you need. We will discuss each of them in the following sections.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2667"></a>6.1.2.&nbsp;What makes a rule</h3></div></div></div><p>For the inpatients, just as an early view, a rule has the following
    rough structure:</p><pre class="programlisting"><span class="bold"><strong>rule</strong></span> <em class="replaceable"><code>"name"</code></em>
    <em class="replaceable"><code>attributes</code></em>
    <span class="bold"><strong>when</strong></span>
        <em class="replaceable"><code>LHS</code></em>
    <span class="bold"><strong>then</strong></span>
        <em class="replaceable"><code>RHS</code></em>
<span class="bold"><strong>end</strong></span>
</pre><p>Its really that simple. Mostly punctuation is not needed,
    even the double quotes for "name" are optional, as are newlines.
    Attributes are simple (always optional) hints to how the rule should
    behave. LHS is the conditional parts of the rule, which follows a certain
    syntax which is covered below. RHS is basically a block that allows
    dialect specific semantic code to be executed.</p><p>It is important to note that white space is not important, EXCEPT in
    these case of domain specific languages, in which case each line is
    processed before the following line (and spaces may be significant to the
    domain language).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2700"></a>6.1.3.&nbsp;Reserved words</h3></div></div></div><p>There are some reserved keywords that are used in the rule language.
    It is wise to avoid collisions with these words when naming your domain
    objects, properties, methods, functions and other elements that are used
    in the rule text. The parser is a bit smart and sometimes knows when a
    keyword is not being used as a keyword, but avoiding the use of them might
    prevent some headaches.</p><p>The following is a list of keywords that must be avoided as
    identifiers when writing rules:</p><div class="itemizedlist"><ul type="disc"><li><p>rule</p></li><li><p>query</p></li><li><p>when</p></li><li><p>then</p></li><li><p>end</p></li><li><p>null</p></li><li><p>and</p></li><li><p>or</p></li><li><p>not</p></li><li><p>exists</p></li><li><p>collect</p></li><li><p>accumulate</p></li><li><p>from</p></li><li><p>forall</p></li><li><p>true</p></li><li><p>false</p></li><li><p>eval</p></li></ul></div><p>The following list are keywords that you should try and avoid in the
    rule contents if possible, but the parser usually will work fine, even if
    you use them for something else.</p><div class="itemizedlist"><ul type="disc"><li><p>package</p></li><li><p>function</p></li><li><p>global</p></li><li><p>import</p></li><li><p>template</p></li><li><p>attributes</p></li><li><p>enabled</p></li><li><p>salience</p></li><li><p>duration</p></li><li><p>init</p></li><li><p>action</p></li><li><p>reverse</p></li><li><p>result</p></li><li><p>contains</p></li><li><p>excludes</p></li><li><p>memberOf</p></li><li><p>matches</p></li><li><p>in</p></li><li><p>date-effective</p></li><li><p>date-expires</p></li><li><p>no-loop</p></li><li><p>auto-focus</p></li><li><p>activation-group</p></li><li><p>agenda-group</p></li><li><p>dialect</p></li><li><p>rule-flow-group</p></li></ul></div><p>Of course, you can have words as part of a method name in camel
    case, like notSomething() - there are no issues with that scenario.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2842"></a>6.2.&nbsp;Comments</h2></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><em class="replaceable"><code>(updated to Drools 4.0)</code></em></p></div><p>Comments are sections of text that are ignored by the rule engine.
  They are stripped out when they are encountered, except inside semantic code
  blocks, like the RHS of a rule.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2851"></a>6.2.1.&nbsp;Single line comment</h3></div></div></div><div class="figure"><a name="d0e2854"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/single_line_comment.png" align="middle" alt="Single line comment"></div></div><p class="title"><b>Figure&nbsp;6.1.&nbsp;Single line comment</b></p></div><br class="figure-break"><p>To create single line comments, you can use either '#' or '//'. The
    parser will ignore anything in the line after the comment symbol.
    Example:</p><pre class="programlisting">rule "Testing Comments"
when
    # this is a single line comment
    // this is also a single line comment
    eval( true ) # this is a comment in the same line of a pattern
then
    // this is a comment inside a semantic code block
    # this is another comment in a semantic code block
end
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2866"></a>6.2.2.&nbsp;Multi line comment</h3></div></div></div><div class="figure"><a name="d0e2869"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/multi_line_comment.png" align="middle" alt="Multi line comment"></div></div><p class="title"><b>Figure&nbsp;6.2.&nbsp;Multi line comment</b></p></div><br class="figure-break"><p>Multi-line comments are used to comment blocks of text, both in and
    outside semantic code blocks. Example:</p><pre class="programlisting">rule "Test Multi-line Comments"
when
    /* this is a multi-line comment
       in the left hand side of a rule */
    eval( true )
then
    /* and this is a multi-line comment
       in the right hand side of a rule */
end </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2881"></a>6.3.&nbsp;Package</h2></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><em class="replaceable"><code>(updated to Drools 4.0)</code></em></p></div><p>A package is a collection of rules and other related constructs, such
  as imports and globals. The package members are typically related to each
  other - perhaps HR rules, for instance. A package represents a namespace,
  which ideally is kept unique for a given grouping of rules. The package name
  itself is the namespace, and is not related to files or folders in any
  way.</p><p>It is possible to assemble rules from multiple rule sources, and have
  one top level package configuration that all the rules are kept under (when
  the rules are assembled). Although, it is not possible to merge into the
  same package resources declared under different names. A single Rulebase,
  can though, contain multiple packages built on it. A common structure, is to
  have all the rules for a package in the same file as the package declaration
  (so that is it entirely self contained).</p><p>The following rail road diagram shows all the components that may make
  up a package. Note that a package MUST have a namespace and be declared
  using standard java conventions for package names; i.e. no spaces, unlike
  rule names which allow spaces. In terms of the order of elements, they can
  appear in any order in the rule file, with the exception of the "package"
  and "expander" statements being at the top of the file, before any rules
  appear. In all cases, the semi colons are optional.</p><div class="figure"><a name="d0e2894"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/package.png" align="middle" alt="package"></div></div><p class="title"><b>Figure&nbsp;6.3.&nbsp;package</b></p></div><br class="figure-break"><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2902"></a>6.3.1.&nbsp;import</h3></div></div></div><div class="figure"><a name="d0e2905"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Rule_Language/import.png" alt="import"></div></div><p class="title"><b>Figure&nbsp;6.4.&nbsp;import</b></p></div><br class="figure-break"><p>Import statements work like import statements in Java. You need to
    specify the fully qualified paths and type names for any objects you want
    to use in the rules. Drools automatically imports classes from the same
    named java package and from the java.lang package.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2915"></a>6.3.2.&nbsp;expander</h3></div></div></div><div class="figure"><a name="d0e2918"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Rule_Language/expander.png" alt="expander"></div></div><p class="title"><b>Figure&nbsp;6.5.&nbsp;expander</b></p></div><br class="figure-break"><p>The expander statement (optional) is used to specify domain specific
    language (DSL) configurations (which are normally stored in a separate
    file). This provides clues to the parser as how to understand what you are
    raving on about in your rules. It is important to note that in Drools 4.0
    (that is different from Drools 3.x) the expander declaration is mandatory
    for the tools to provide you context assist and avoiding error reporting,
    but the API allows the program to apply DSL templates, even if the
    expanders are not declared in the source file.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2928"></a>6.3.3.&nbsp;global</h3></div></div></div><div class="figure"><a name="d0e2931"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Rule_Language/global.png" alt="global"></div></div><p class="title"><b>Figure&nbsp;6.6.&nbsp;global</b></p></div><br class="figure-break"><p>Globals are global variables. They are used to make application
    objects available to the rules, and are typically used to provide data or
    services that the rules use (specially application services used in rule
    consequences), to return data from the rules (like logs or values added in
    rules consequence) or for the rules to interact with the application doing
    callbacks. Globals are not inserted into the Working Memory so they should
    never be reasoned over, and only use them in rules LHS if the global has a
    constant immutable value. The engine is not notified and does not track
    globals value changes. Incorrect use of globals in constraints may yield
    surprising results - surprising in a bad way, like when a doctor says
    "thats interesting" to a chest XRay of yours.</p><p>If multiple packages declare globals with the same identifier they
    must be of the same type and all of them will reference the same global
    value.</p><p>In order to use globals you must:</p><div class="orderedlist"><ol type="1"><li><p>Declare your global variable in your rules file and use it in
        rules. Example:</p><pre class="programlisting">global java.util.List myGlobalList;

rule "Using a global"
when
    eval( true )
then
    myGlobalList.add( "Hello World" );
end
</pre></li><li><p>Set the global value on your working memory. It is a best
        practice to set all global values before asserting any fact to the
        working memory. Example:</p><pre class="programlisting">List list = new ArrayList();
WorkingMemory wm = rulebase.newStatefulSession();
wm.setGlobal( "myGlobalList", list );
</pre></li></ol></div><p>Note that these are just named instances of objects that you pass in
    from your application to the working memory. This means you can pass in
    any object you want: you could pass in a service locator, or perhaps a
    service itself. With the new 'from' element it is now common to pass a
    Hibernate session as a global, to allow 'from' to pull data from a named
    Hibernate query.</p><p>One example may be an instance of a Email service. In your
    integration code that is calling the rule engine, you get your
    emailService object, and then set it in the working memory. In the DRL,
    you declare that you have a global of type EmailService, and give it a
    name "email". Then in your rule consequences, you can use things like
    email.sendSMS(number, message).</p><p>Globals are not designed to share data between rules and they should
    never be used for that purpose. Rules always reason and react to the
    working memory state, so if you want to "share" data between rules, assert
    the data to the working memory.</p><p>It is strongly discouraged to set (or change) a global value from
    inside your rules. We recommend to you always set the value from your
    application using the working memory interface.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2964"></a>6.4.&nbsp;Function</h2></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><em class="replaceable"><code>(updated to Drools 4.0)</code></em></p></div><div class="figure"><a name="d0e2971"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/function.png" align="middle" alt="function"></div></div><p class="title"><b>Figure&nbsp;6.7.&nbsp;function</b></p></div><br class="figure-break"><p>Functions are a way to put semantic code in your rule source file, as
  opposed to in normal java classes. They can't do anything more then what you
  can do with helper classes (in fact, the compiler generates the helper class
  for you behind the scenes). The main advantage of using functions in a rule
  is that you can keep the logic all in one place, and you can change the
  functions as needed (this can be a good and bad thing). Functions are most
  useful for invoking actions on the consequence ("then") part of a rule,
  especially if that particular action is used over and over (perhaps with
  only differing parameters for each rule - for example the contents of an
  email message).</p><p>A typical function declaration looks like:</p><pre class="programlisting">function String hello(String name) {
    return "Hello "+name+"!";
}
</pre><p>Note that the "function" keyword is used, even though its not really
  part of java. Parameters to the function are just like a normal method (and
  you don't have to have parameters if they are not needed). Return type is
  just like a normal method.</p><p>An alternative to the use of a function, could be to use a static
  method in a helper class: Foo.hello(). Drools 4.0 supports the use of
  function imports, so all you would need to do is:</p><pre class="programlisting">import function my.package.Foo.hello</pre><p>In both cases above, to use the function, just call it by its name in
  the consequence or inside a semantic code block. Example:</p><pre class="programlisting">rule "using a static function"
when 
    eval( true )
then
    System.out.println( hello( "Bob" ) );
end
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2995"></a>6.5.&nbsp;Rule</h2></div></div></div><div class="figure"><a name="d0e2998"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/rule.png" align="middle" alt="rule"></div></div><p class="title"><b>Figure&nbsp;6.8.&nbsp;rule</b></p></div><br class="figure-break"><p>A rule specifies that "when" a particular set of conditions occur,
  specified in the Left Hand Side (LHS), then do this, which is specified as a
  list of actions in the Right Hand Side (RHS). A common question from users
  is "why use when instead of if". "when" was chosen over "if" because "if" is
  normally part of a procedural execution flow, where at a specific point in
  time it checks the condition. Where as "when" indicates it's not tied to a
  specific evaluation sequence or point in time, at any time during the life
  time of the engine "when" this occurs, do that. Rule</p><p>A rule must have a name, and be a unique name for the rule package. If
  you define a rule twice in the same DRL it produce an error while loading.
  If you add a DRL that has includes a rule name already in the package, it
  will replace the previous rule. If a rule name is to have spaces, then it
  will need to be in double quotes (its best to always use double
  quotes).</p><p>Attributes are optional, and are described below (they are best kept
  as one per line).</p><p>The LHS of the rule follows the "when" keyword (ideally on a new
  line), similarly the RHS follows the "then" keyword (ideally on a newline).
  The rule is terminated by the keyword "end". Rules cannot be nested of
  course.</p><div class="example"><a name="d0e3014"></a><p class="title"><b>Example&nbsp;6.2.&nbsp;Rule Syntax Overview Example</b></p><div class="example-contents"><pre class="programlisting">rule "&lt;name&gt;"
    &lt;attribute&gt;*
when
    &lt;conditional element&gt;*
then
    &lt;action&gt;*
end</pre></div></div><br class="example-break"><div class="example"><a name="d0e3019"></a><p class="title"><b>Example&nbsp;6.3.&nbsp;A rule example</b></p><div class="example-contents"><pre class="programlisting">rule "Approve if not rejected"
  salience -100 
  agenda-group "approval"
    when
        not Rejection() 
        p : Policy(approved == false, policyState:status)
        exists Driver(age &gt; 25)
        Process(status == policyState)
    then
        log("APPROVED: due to no objections."); 
        p.setApproved(true);
end</pre></div></div><br class="example-break"><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3024"></a>6.5.1.&nbsp;Rule Attributes</h3></div></div></div><p>Rule attributes provide a declarative way to influence the behavior
    of the rule, some are quite simple, while others are part of complex sub
    systems; such as ruleflow. To get the most from Drools you should make
    sure you have a proper understanding of each attribute.</p><div class="figure"><a name="d0e3029"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/rule_attributes.png" align="middle" alt="rule attributes"></div></div><p class="title"><b>Figure&nbsp;6.9.&nbsp;rule attributes</b></p></div><br class="figure-break"><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3037"></a>6.5.1.1.&nbsp;no-loop</h4></div></div></div><p>default value : false</p><p>type : Boolean</p><p>When the Rule's consequence modifies a fact it may cause the Rule
      to activate again, causing recursion. Setting no-loop to true means the
      attempt to create the Activation for the current set of data will be
      ignored.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3046"></a>6.5.1.2.&nbsp;lock-on-active</h4></div></div></div><p>default value : false</p><p>type : Boolean</p><p>when a ruleflow-group becomes active or an agenda-group receives
      the focus any rules that ahve lock-on-active set to try cannot place
      activations onto the agenda, the rules are matched and the resulting
      activations discarded. This is a stronger version of no-loop. It's
      idealy for calculation rules where you have a number of rules that will
      modify a fact and you don't want any rule re-matching and firing. In
      summary fire these currently active rules and only these rules, no
      matter how the data changes, do not allow any more activations for the
      rules with the attribute set to true. When the ruleflow-group is no
      longer active or agenda-group loses the focus those rules with
      lock-on-active set to true can once again add activations onto the
      agenda.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3055"></a>6.5.1.3.&nbsp;salience</h4></div></div></div><p>default value : 0</p><p>type : integer</p><p>Each rule has a salience attribute that can be assigned an Integer
      number, defaults to zero, the Integer and can be negative or positive.
      Salience is a form of priority where rules with higher salience values
      are given higher priority when ordered in the Activation queue.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3064"></a>6.5.1.4.&nbsp;agenda-group</h4></div></div></div><p>default value : MAIN</p><p>type : String</p><p>Agenda group's allow the user to partition the Agenda providing
      more execution control. Only rules in the focus group are allowed to
      fire.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3073"></a>6.5.1.5.&nbsp;auto-focus</h4></div></div></div><p>default value false</p><p>type : Boolean</p><p>When a rule is activated if the <code class="literal">auto-focus value is true
      and the Rule's </code> <code class="literal">agenda-group</code> does not have
      focus then it is given focus, allowing the rule to potentially
      fire.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3088"></a>6.5.1.6.&nbsp;activation-group</h4></div></div></div><p>default value : N/A</p><p>type : String</p><p>Rules that belong to the same named activation-group will only
      fire exclusively. In other words, the first rule in an activation-group
      to fire will cancel the other rules activations (stop them from firing).
      The Activation group attribute is any string, as long as the string is
      identical for all the rules you need to be in the one group.</p><p>NOTE: this used to be called Xor group, but technically its not
      quite an Xor, but you may hear people mention Xor group, just swap that
      term in your mind with activation-group.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3099"></a>6.5.1.7.&nbsp;dialect</h4></div></div></div><p>default value : as specified by the package</p><p>type : String</p><p>possible values: "java" or "mvel"</p><p>The dialect species the language to be used for any code
      expressions in the LHS or the RHS code block. Currently two dialects are
      available, Java and MVEL. While the dialect can be specified at the
      package level, this attribute allows the package definition to be
      overridden.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3110"></a>6.5.1.8.&nbsp;date-effective</h4></div></div></div><p>default value : N/A</p><p>type : String, which contains a Date/Time definition</p><p>A rule can only activate if the current date and time is after
      date-effective attribute.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3119"></a>6.5.1.9.&nbsp;date-exptires</h4></div></div></div><p>default value : N/A</p><p>type : String, which contains a Date/Time definition</p><p>A rule cannot activate if the current date and time is after
      date-expires attribute.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3128"></a>6.5.1.10.&nbsp;duration</h4></div></div></div><p>default value : no default value</p><p>type : long</p><p>The duration dictates that the rule will fire after a specified
      duration, if it is still true.</p></div><div class="example"><a name="d0e3137"></a><p class="title"><b>Example&nbsp;6.4.&nbsp;Some attribute examples</b></p><div class="example-contents"><pre class="programlisting">rule "my rule"
  salience 42
  agenda-group "number 1"
    when ...
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RuleLanguage-ConditionalElements"></a>6.5.2.&nbsp;Left Hand Side (when) Conditional Elements</h3></div></div></div><p>The Left Hand Side (LHS) is a common name for the conditional part
    of the rule. It consists of zero or more Conditional Elements. If the LHS
    is left empty it is re-written as eval(true), which means the rule is
    always true, and will be activated with a new Working Memory session is
    created.</p><div class="figure"><a name="d0e3147"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/lhs.png" align="middle" alt="Left Hand Side"></div></div><p class="title"><b>Figure&nbsp;6.10.&nbsp;Left Hand Side</b></p></div><br class="figure-break"><div class="example"><a name="d0e3155"></a><p class="title"><b>Example&nbsp;6.5.&nbsp;Rule Syntax Overview Example</b></p><div class="example-contents"><pre class="programlisting">rule "no CEs"
when
then
    &lt;action&gt;*
end</pre><p>Is internally re-written as:</p><pre class="programlisting">rule "no CEs"
when
    eval( true )
then
    &lt;action&gt;*
end</pre></div></div><br class="example-break"><p>Conditional elements work on one or more Patterns (which are
    described bellow). The most common one is "and" which is implicit when you
    have multiple Patterns in the LHS of a rule that are not connected in
    anyway. Note that an 'and' cannot have a leading declaration binding like
    'or' - this is obvious when you think about it. A declaration can only
    reference a single Fact, when the 'and' is satisfied it matches more than
    one fact - which fact would the declaration bind to?</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3166"></a>6.5.2.1.&nbsp;Pattern</h4></div></div></div><p>The Pattern element is the most important Conditional Element. The
      entity relationship diagram below provides an overview of the various
      parts that make up the Pattern's constraints and how they work together;
      each is then covered in more detail with rail road diagrams and
      examples.</p><div class="figure"><a name="d0e3171"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/patternER.png" align="middle" alt="Pattern Entity Relationship Diagram"></div></div><p class="title"><b>Figure&nbsp;6.11.&nbsp;Pattern Entity Relationship Diagram</b></p></div><br class="figure-break"><p>At the top of the ER diagram you can see that the pattern consists
      of zero or more constraints and has an optional pattern binding. The
      rail road diagram below shows the syntax for this.</p><div class="figure"><a name="d0e3181"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/pattern.png" align="middle" alt="Pattern"></div></div><p class="title"><b>Figure&nbsp;6.12.&nbsp;Pattern</b></p></div><br class="figure-break"><p>At the simplest, with no constraints, it simply matches against a
      type, in the following case the type is "Cheese". This means the pattern
      will match against all Cheese objects in the Working Memory.</p><div class="example"><a name="d0e3191"></a><p class="title"><b>Example&nbsp;6.6.&nbsp;Pattern</b></p><div class="example-contents"><pre class="programlisting">Cheese( )</pre></div></div><br class="example-break"><p>To be able to refer to the matched object use a pattern binding
      variable such as '$c'. While this example variable is prefixed with a $
      symbol, it is optional, but can be useful in complex rules as it helps
      to more easily differentiation between variables and fields.</p><div class="example"><a name="d0e3198"></a><p class="title"><b>Example&nbsp;6.7.&nbsp;Pattern</b></p><div class="example-contents"><pre class="programlisting">$c : Cheese( )</pre></div></div><br class="example-break"><p>Inside of the Pattern parenthesis is where all the action happens.
      A constraint can be either a Field Constraint, Inline Eval (called a
      predicate in 3.0) or a Constraint Group. Constraints can be separated by
      the following symbols ',', '&amp;&amp;' or '||'.</p><div class="figure"><a name="d0e3205"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/constraints.png" align="middle" alt="Constraints"></div></div><p class="title"><b>Figure&nbsp;6.13.&nbsp;Constraints</b></p></div><br class="figure-break"><div class="figure"><a name="d0e3213"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/constraint.png" align="middle" alt="Constraint"></div></div><p class="title"><b>Figure&nbsp;6.14.&nbsp;Constraint</b></p></div><br class="figure-break"><div class="figure"><a name="d0e3221"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/constraintGroup.png" align="middle" alt="Group Constraint"></div></div><p class="title"><b>Figure&nbsp;6.15.&nbsp;Group Constraint</b></p></div><br class="figure-break"><p>The ',' (comma) character is used to separate constraint groups.
      It has an implicit 'and' connective semantics.</p><div class="example"><a name="d0e3231"></a><p class="title"><b>Example&nbsp;6.8.&nbsp;Constraint Group connective ','</b></p><div class="example-contents"><pre class="programlisting"># Cheese type is stilton and price &lt; 10 and age is mature.
Cheese( type == "stilton", price &lt; 10, age == "mature" )</pre></div></div><p><br class="example-break">The above example has 3 constraint groups, each with a
      single constraint:</p><div class="itemizedlist"><ul type="disc"><li><p>group 1: type is stilton -&gt; type == "stilton"</p></li><li><p>group 2: price is less than 10 -&gt; price &lt; 10</p></li><li><p>group 3: age is mature -&gt; age == "mature"</p></li></ul></div><p>The '&amp;&amp;' (and) and '||' (or) constraint connectives allow
      constraint groups to have multiple constraints. Example:</p><div class="example"><a name="d0e3249"></a><p class="title"><b>Example&nbsp;6.9.&nbsp;&amp;&amp; and || Constraint Connectives</b></p><div class="example-contents"><pre class="programlisting">Cheese( type == "stilton" &amp;&amp; price &lt; 10, age == "mature" ) // Cheese type is "stilton" and price &lt; 10, and age is mature
Cheese( type == "stilton" || price &lt; 10, age == "mature" ) // Cheese type is "stilton" or price &lt; 10, and age is mature</pre></div></div><br class="example-break"><p>The above example has two constraint groups. The first has 2
      constraints and the second has one constraint.</p><p>The connectives are evaluated in the following order, from first
      to last:</p><div class="orderedlist"><ol type="1"><li><p>&amp;&amp;</p></li><li><p>||</p></li><li><p>,</p></li></ol></div><p>It is possible to change the evaluation priority by using
      parenthesis, as in any logic or mathematical expression. Example:</p><div class="example"><a name="d0e3271"></a><p class="title"><b>Example&nbsp;6.10.&nbsp;Using parenthesis to change evaluation priority</b></p><div class="example-contents"><pre class="programlisting"># Cheese type is stilton and ( price is less than 20 or age is mature ).
Cheese( type == "stilton" &amp;&amp; ( price &lt; 20 || age == "mature" ) ) </pre></div></div><p><br class="example-break">In the above example, the use of parenthesis makes the ||
      connective be evaluated before the &amp;&amp; connective.</p><p>Also, it is important to note that besides having the same
      semantics, the connectives '&amp;&amp;' and ',' are resolved with
      different priorities and ',' cannot be embedded in a composite
      constraint expression.</p><div class="example"><a name="d0e3279"></a><p class="title"><b>Example&nbsp;6.11.&nbsp;Not Equivalent connectives</b></p><div class="example-contents"><pre class="programlisting">Cheese( ( type == "stilton", price &lt; 10 ) || age == "mature" ) // invalid as ',' cannot be embedded in an expression
Cheese( ( type == "stilton" &amp;&amp; price &lt; 10 ) || age == "mature") // valid as '&amp;&amp;' can be embedded in an expression</pre></div></div><br class="example-break"><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3284"></a>6.5.2.1.1.&nbsp;Field Constraints</h5></div></div></div><p>A Field constraint specifies a restriction to be used on a field
        name; the field name can have an optional variable binding.</p><div class="figure"><a name="d0e3289"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/fieldConstraint.png" align="middle" alt="fieldConstraint"></div></div><p class="title"><b>Figure&nbsp;6.16.&nbsp;fieldConstraint</b></p></div><br class="figure-break"><p>There are three types of restrictions; Single Value Restriction,
        Compound Value Restriction and Multi Restriction.</p><div class="figure"><a name="d0e3299"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/restriction.png" align="middle" alt="restriction"></div></div><p class="title"><b>Figure&nbsp;6.17.&nbsp;restriction</b></p></div><br class="figure-break"><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3307"></a>6.5.2.1.1.1.&nbsp;JavaBeans as facts</h6></div></div></div><p>A field is an accessible method on the object. If your model
          objects follow the java bean pattern, then fields are exposed using
          "getXXX" or "isXXX" methods (these are methods that take no
          arguments, and return something). You can access fields either by
          using the bean-name convention (so "getType" can be accessed as
          "type") - we use the standard jdk Introspector class to do this
          mapping.</p><p>For example, referring to our Cheese class, the following :
          Cheese(type == ...) uses the getType() method on the a cheese
          instance. If a field name cannot be found it will resort to calling
          the name as a no argument method; "toString()" on the Object for
          instance can be used with Cheese(toString == ..) - you use the full
          name of the method with correct capitalization, but not brackets. Do
          please make sure that you are accessing methods that take no
          parameters, and are in-fact "accessors" (as in, they don't change
          the state of the object in a way that may effect the rules -
          remember that the rule engine effectively caches the results of its
          matching in between invocations to make it faster).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3314"></a>6.5.2.1.1.2.&nbsp;Values</h6></div></div></div><p>The field constraints can take a number of values; including
          literal, qualifiedIdentifier (enum), variable and
          returnValue.</p><div class="figure"><a name="d0e3319"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/literal.png" align="middle" alt="literal"></div></div><p class="title"><b>Figure&nbsp;6.18.&nbsp;literal</b></p></div><br class="figure-break"><div class="figure"><a name="d0e3327"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/qualifiedIdentifier.png" align="middle" alt="qualifiedIdentifier"></div></div><p class="title"><b>Figure&nbsp;6.19.&nbsp;qualifiedIdentifier</b></p></div><br class="figure-break"><div class="figure"><a name="d0e3335"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/identifier.png" align="middle" alt="variable"></div></div><p class="title"><b>Figure&nbsp;6.20.&nbsp;variable</b></p></div><br class="figure-break"><div class="figure"><a name="d0e3343"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/returnValue.png" align="middle" alt="returnValue"></div></div><p class="title"><b>Figure&nbsp;6.21.&nbsp;returnValue</b></p></div><br class="figure-break"><p>You can do checks against fields that are or maybe null, using
          == and != as you would expect, and the literal "null" keyword, like:
          Cheese(type != null). If a field is null the evaluator will not
          throw an exception and will only return true if the value is a null
          check. Coercion is always attempted if the field and the value are
          of different types; exceptions will be thrown if bad coercions are
          attempted. i.e. if "ten" is provided as a string in a number
          evaluator, where as "10" would coerce to a numeric 10. Coercion is
          always in favor of the field type and not the value type.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3353"></a>6.5.2.1.1.3.&nbsp;Single Value Restriction</h6></div></div></div><div class="figure"><a name="d0e3356"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/singleValueRestriction.png" align="middle" alt="singleValueRestriction"></div></div><p class="title"><b>Figure&nbsp;6.22.&nbsp;singleValueRestriction</b></p></div><br class="figure-break"><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3364"></a>6.5.2.1.1.3.1.&nbsp;Operators</h6></div></div></div><div class="figure"><a name="d0e3367"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/operator.png" align="middle" alt="Operators"></div></div><p class="title"><b>Figure&nbsp;6.23.&nbsp;Operators</b></p></div><br class="figure-break"><p>Valid operators are dependent on the field type. Generally
            they are self explanatory based on the type of data: for instance,
            for date fields, "&lt;" means "before" and so on. "Matches" is
            only applicable to string fields, "contains" and "not contains" is
            only applicable to Collection type fields. These operators can be
            used with any value and coercion to the correct value for the
            evaluator and filed will be attempted, as mention in the "Values"
            section.</p><div class="simplesect" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3377"></a>Matches Operator</h6></div></div></div><p>Matches a field against any valid Java <a class="indexterm" name="d0e3382"></a>Regular Expression. Typically that regexp is a
              String, but variables that resolve to a valid regexp are also
              allowed. It is important to note that <span class="emphasis"><em>different from
              java</em></span>, if you write a String regexp directly on the
              source file, <span class="emphasis"><em>you don't need to escape '\'</em></span>.
              Example:</p><div class="example"><a name="d0e3392"></a><p class="title"><b>Example&nbsp;6.12.&nbsp;Regular Expression Constraint</b></p><div class="example-contents"><pre class="programlisting">Cheese( type matches "(Buffalo)?\S*Mozerella" )</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3397"></a>Not Matches Operator</h6></div></div></div><p>Any valid Java <a class="indexterm" name="d0e3402"></a>Regular Expression can be used to match String
              fields. Returns true when the match is false. Typically that
              regexp is a String, but variables that resolve to a valid regexp
              are also allowed.It is important to note that
              <span class="emphasis"><em>different from java</em></span>, if you write a String
              regexp directly on the source file, <span class="emphasis"><em>you don't need to
              escape '\'</em></span>. Example:</p><div class="example"><a name="d0e3412"></a><p class="title"><b>Example&nbsp;6.13.&nbsp;Regular Expression Constraint</b></p><div class="example-contents"><pre class="programlisting">Cheese( type not matches "(Buffulo)?\S*Mozerella" )</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3417"></a>Contains Operator</h6></div></div></div><p><code class="literal">'contains'</code> is used to check if a
              field's <a class="indexterm" name="d0e3424"></a>Collection or array contains the specified
              value.</p><div class="example"><a name="d0e3428"></a><p class="title"><b>Example&nbsp;6.14.&nbsp;Contains with Collections</b></p><div class="example-contents"><pre class="programlisting">CheeseCounter( cheeses contains "stilton" ) // contains with a String literal
CheeseCounter( cheeses contains $var ) // contains with a variable</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3433"></a>not contains</h6></div></div></div><p><code class="literal">'not contains'</code> is used to check if a
              field's <a class="indexterm" name="d0e3440"></a>Collection or array does not contains an
              object.</p><div class="example"><a name="d0e3444"></a><p class="title"><b>Example&nbsp;6.15.&nbsp;Literal Constraints with Collections</b></p><div class="example-contents"><pre class="programlisting">CheeseCounter( cheeses not contains "cheddar" ) // not contains with a String literal
CheeseCounter( cheeses not contains $var ) // not contains with a variable</pre><div class="blockquote"><blockquote class="blockquote"><p><span class="bold"><strong>NOTE: </strong></span>for backward
                  compatibility, the '<span class="bold"><strong>excludes</strong></span>' operator is supported as a
                  synonym for '<span class="bold"><strong>not
                  contains</strong></span>'.</p></blockquote></div></div></div><br class="example-break"></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3460"></a>memberOf</h6></div></div></div><p><code class="literal">'memberOf' is used to check if a field is a
              member of a collection or array; that collection must be be a
              variable.</code></p><div class="example"><a name="d0e3466"></a><p class="title"><b>Example&nbsp;6.16.&nbsp;Literal Constraints with Collections</b></p><div class="example-contents"><pre class="programlisting">CheeseCounter( cheese memberOf $matureCheeses )</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3471"></a>not memberOf</h6></div></div></div><p><code class="literal">'not memberOf' is used to check if a field is not
              a member of a collection or array; that collection must be be a
              variable.</code></p><div class="example"><a name="d0e3477"></a><p class="title"><b>Example&nbsp;6.17.&nbsp;Literal Constraints with Collections</b></p><div class="example-contents"><pre class="programlisting">CheeseCounter( cheese not memberOf $matureCheeses )</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3482"></a>soundslike</h6></div></div></div><p><code class="literal">Similar to 'matches', but checks if a word has
              almost the same sound as the given value. Uses the 'Soundex'
              algorithm
              (http://en.wikipedia.org/wiki/Soundex)</code></p><div class="example"><a name="d0e3488"></a><p class="title"><b>Example&nbsp;6.18.&nbsp;Text with soundslike (Sounds Like)</b></p><div class="example-contents"><pre class="programlisting">Cheese( name soundslike 'foobar' )</pre><p>This will match a cheese with a name of "fubar"</p></div></div><br class="example-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3495"></a>6.5.2.1.1.3.2.&nbsp;Literal Restrictions</h6></div></div></div><p>Literal restrictions are the simplest form of restrictions
            and evaluate a field against a specified literal; numeric, date,
            string or boolean.</p><div class="figure"><a name="d0e3500"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/literalRestriction.png" align="middle" alt="literalRestriction"></div></div><p class="title"><b>Figure&nbsp;6.24.&nbsp;literalRestriction</b></p></div><br class="figure-break"><p>Literal Restrictions using the '==' operator, provide for
            faster execution as we can index using hashing to improve
            performance;</p><div class="simplesect" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3510"></a>Numeric</h6></div></div></div><p>All standard java numeric primitives are supported.</p><div class="example"><a name="d0e3515"></a><p class="title"><b>Example&nbsp;6.19.&nbsp;Numeric Literal Restriction</b></p><div class="example-contents"><pre class="programlisting">Cheese( quantity == 5 )</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3520"></a>Date</h6></div></div></div><p>The date format "dd-mmm-yyyy" is supported by default. You
              can customize this by providing an alternative date format mask
              as a System property ("drools.dateformat" is the name of the
              property). If more control is required, use the inline-eval
              constraint.</p><div class="example"><a name="d0e3525"></a><p class="title"><b>Example&nbsp;6.20.&nbsp;Date Literal Restriction</b></p><div class="example-contents"><pre class="programlisting">Cheese( bestBefore &lt; "27-Oct-2007" )</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3530"></a>String</h6></div></div></div><p>Any valid Java String is allowed.</p><div class="example"><a name="d0e3535"></a><p class="title"><b>Example&nbsp;6.21.&nbsp;String Literal Restriction</b></p><div class="example-contents"><pre class="programlisting">Cheese( type == "stilton" )</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3540"></a>Boolean</h6></div></div></div><p>only true or false can be used. 0 and 1 are not
              recognized, nor is <code class="literal">Cheese ( smelly )</code> is
              allowed</p><div class="example"><a name="d0e3548"></a><p class="title"><b>Example&nbsp;6.22.&nbsp;Boolean Literal Restriction</b></p><div class="example-contents"><pre class="programlisting">Cheese( smelly == true )</pre></div></div><br class="example-break"></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3553"></a>Qualified Identifier</h6></div></div></div><p>Enums can be used as well, both jdk1.4 and jdk5 style
              enums are supported - for the later you must be executing on a
              jdk5 environment.</p><div class="example"><a name="d0e3558"></a><p class="title"><b>Example&nbsp;6.23.&nbsp;Boolean Literal Restriction</b></p><div class="example-contents"><pre class="programlisting">Cheese( smelly == SomeClass.TRUE )</pre></div></div><br class="example-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3563"></a>6.5.2.1.1.3.3.&nbsp;Bound Variable Restriction</h6></div></div></div><div class="figure"><a name="d0e3566"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/variableRestriction.png" align="middle" alt="variableRestriction"></div></div><p class="title"><b>Figure&nbsp;6.25.&nbsp;variableRestriction</b></p></div><br class="figure-break"><p>Variables can be bound to Facts and their Fields and then
            used in subsequent Field Constraints. A bound variable is called a
            <a class="indexterm" name="d0e3576"></a>Declaration. Valid operators are determined by the
            type of the field being constrained; coercion will be attempted
            where possible. Bound Variable Restrictions using '==' operator,
            provide for very fast execution as we can index using hashing to
            improve performance.</p><div class="example"><a name="d0e3580"></a><p class="title"><b>Example&nbsp;6.24.&nbsp;Bound Field using '==' operator</b></p><div class="example-contents"><pre class="programlisting">Person( likes : favouriteCheese )
Cheese( type == likes )</pre><p>'likes' is our variable, our Declaration, that is bound to
              the favouriteCheese field for any matching Person instance and
              is used to constrain the type of Cheese in the following
              Pattern. Any valid java variable name can be used, including
              '$'; which you will often see used to help differentiate
              declarations from fields. The example below shows a declaration
              bound to the Patterns Object Type instance itself and used with
              a 'contains' operator, note the optional use of '$' this
              time.</p></div></div><br class="example-break"><div class="example"><a name="d0e3587"></a><p class="title"><b>Example&nbsp;6.25.&nbsp;Bound Fact using 'contains' operator</b></p><div class="example-contents"><pre class="programlisting">$stilton : Cheese( type == "stilton" )
Cheesery( cheeses contains $stilton )</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3592"></a>6.5.2.1.1.3.4.&nbsp;Return Value Restriction</h6></div></div></div><div class="figure"><a name="d0e3595"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/returnValueRestriction.png" align="middle" alt="returnValueRestriction"></div></div><p class="title"><b>Figure&nbsp;6.26.&nbsp;returnValueRestriction</b></p></div><br class="figure-break"><p>A <a class="indexterm" name="d0e3605"></a>Return Value restriction can use any valid Java
            primitive or object. Avoid using any Drools keywords as
            Declaration identifiers. Functions used in a Return Value
            Restriction must return time constant results. Previously bound
            declarations can be used in the expression.</p><div class="example"><a name="d0e3609"></a><p class="title"><b>Example&nbsp;6.26.&nbsp;Return Value Restriction</b></p><div class="example-contents"><pre class="programlisting">Person( girlAge : age, sex == "F" )
Person( age == ( girlAge + 2) ), sex == 'M' )
</pre></div></div><br class="example-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3614"></a>6.5.2.1.1.4.&nbsp;Compound Value Restriction</h6></div></div></div><p>The compound value restriction is used where there is more
          than one possible value, currently only the 'in' and 'not in'
          evaluators support this. The operator takes a parenthesis enclosed
          comma separated list of values, which can be a variable, literal,
          return value or qualified identifier. The 'in' and 'not in'
          evaluators are actually sugar and are rewritten as a multi
          restriction list of != and == restrictions.</p><div class="figure"><a name="d0e3619"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/compoundValueRestriction.png" align="middle" alt="compoundValueRestriction"></div></div><p class="title"><b>Figure&nbsp;6.27.&nbsp;compoundValueRestriction</b></p></div><br class="figure-break"><p></p><div class="example"><a name="d0e3628"></a><p class="title"><b>Example&nbsp;6.27.&nbsp;Compound Restriction using 'in'</b></p><div class="example-contents"><pre class="programlisting">Person( $cheese : favouriteCheese )
Cheese( type in ( "stilton", "cheddar", $cheese )
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e3633"></a>6.5.2.1.1.5.&nbsp;Multi Restriction</h6></div></div></div><p>Multi restriction allows you to place more than one
          restriction on a field using the '&amp;&amp;' or '||' restriction
          connectives. Grouping via parenthesis is also allowed; which adds a
          recursive nature to this restriction.</p><div class="figure"><a name="d0e3638"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/multiRestriction.png" align="middle" alt="multiRestriction"></div></div><p class="title"><b>Figure&nbsp;6.28.&nbsp;multiRestriction</b></p></div><br class="figure-break"><div class="figure"><a name="d0e3646"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/restrictionGroup.png" align="middle" alt="restrictionGroup"></div></div><p class="title"><b>Figure&nbsp;6.29.&nbsp;restrictionGroup</b></p></div><br class="figure-break"><p></p><div class="example"><a name="d0e3655"></a><p class="title"><b>Example&nbsp;6.28.&nbsp;Multi Restriction</b></p><div class="example-contents"><pre class="programlisting">Person( age &gt; 30 &amp;&amp; &lt; 40 ) // simple multi restriction using a single &amp;&amp;
Person( age ( (&gt; 30 &amp;&amp; &lt; 40) || (&gt; 20 &amp;&amp; &lt; 25) ) ) // more complex multi restriction using groupings of multi restrictions
Person( age &gt; 30 &amp;&amp; &lt; 40 || location == "london" ) // mixing muti restrictions with constraint connectives</pre></div></div><br class="example-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3660"></a>6.5.2.1.2.&nbsp;Inline Eval Constraints</h5></div></div></div><div class="figure"><a name="d0e3663"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/inlineEvalConstraint.png" align="middle" alt="Inline Eval Expression"></div></div><p class="title"><b>Figure&nbsp;6.30.&nbsp;Inline Eval Expression</b></p></div><br class="figure-break"><p>A <a class="indexterm" name="d0e3673"></a>inline-eval constraint can use any valid dialect
        expression as long as it is evaluated to a primitive boolean - avoid
        using any Drools keywords as Declaration identifiers. the expression
        must be time constant. Any previous bound variable, from the current
        or previous pattern, can be used; autovivification is also used to
        auto create field binding variables. When an identifier is found that
        is not a current variable the builder looks to see if the identifier
        is a field on the current object type, if it is, the field is auto
        created as a variable of the same name; this is autovivification of
        field variables inside of inline evals.</p><p>This example will find all pairs of male/femal people where the
        male is 2 years older than the female; the boyAge variable is auto
        created as part of the autovivification process.</p><div class="example"><a name="d0e3679"></a><p class="title"><b>Example&nbsp;6.29.&nbsp;Return Value operator</b></p><div class="example-contents"><pre class="programlisting">Person( girlAge : age, sex = "F" )
Person( eval( girlAge == boyAge + 2 ), sex = 'M' )
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3684"></a>6.5.2.1.3.&nbsp;Nested Accessors</h5></div></div></div><p>Drools does allow for nested accessors in in the field
        constraints using the MVEL accessor graph notation. Field constraints
        involving nested accessors are actually re-written as an MVEL dialect
        inline-eval. Care should be taken when using nested accessors as the
        Working Memory is not aware of any of the nested values, and do not
        know when they change; they should be considered immutable while any
        of their parent references are inserted into the Working Memory. If
        you wish to modify a nested value you should remove he parent objects
        first and re-assert afterwards. If you only have a single parent at
        the root of the graph, when in the MVEL dialect, you can use the
        'modify' keyword and its block setters to write the nested accessor
        assignments while retracting and inserting the the root parent object
        as required. Nested accessors can be used either side of the operator
        symbol.</p><div class="example"><a name="d0e3689"></a><p class="title"><b>Example&nbsp;6.30.&nbsp;Nested Accessors</b></p><div class="example-contents"><pre class="programlisting">$p : Person( ) 
Pet( owner == $p, age &gt; $p.children[0].age ) // Find a pet who is older than their owners first born child</pre><p>is internally rewriten as an MVEL inline eval:</p><pre class="programlisting">$p : Person( ) 
Pet( owner == $p, eval( age &gt; $p.children[0].age ) ) // Find a pet who is older than their owners first born child</pre></div></div><br class="example-break"><p class="remark"><i><span class="remark">NOTE: nested accessors have a much greater performance cost
        than direct field access, so use them carefully.</span></i></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3700"></a>6.5.2.2.&nbsp;'and'</h4></div></div></div><p>The 'and' Conditional Element is used to group together other
      Conditional Elements. The root element of the LHS is an implicit prefix
      And and doesn't need to be specified. Drools supports both prefix and
      infix; although prefix is the preferred option as grouping is implicit
      which avoids confusion.</p><div class="figure"><a name="d0e3705"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/prefixAnd.png" align="middle" alt="prefixAnd"></div></div><p class="title"><b>Figure&nbsp;6.31.&nbsp;prefixAnd</b></p></div><br class="figure-break"><p></p><div class="example"><a name="d0e3714"></a><p class="title"><b>Example&nbsp;6.31.&nbsp;prefixAnd</b></p><div class="example-contents"><pre class="programlisting">(and Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType ) )
</pre></div></div><br class="example-break"><div class="example"><a name="d0e3719"></a><p class="title"><b>Example&nbsp;6.32.&nbsp;implicit root prefixAnd</b></p><div class="example-contents"><pre class="programlisting">when
     Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType )</pre></div></div><br class="example-break"><p>Infix 'and' is supported along with explicit grouping with
      parenthesis, should it be needed. The '&amp;&amp;' symbol, as an
      alternative to 'and', is deprecated although it is still supported in
      the syntax for legacy support reasons.</p><div class="figure"><a name="d0e3726"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/infixAnd.png" align="middle" alt="infixAnd"></div></div><p class="title"><b>Figure&nbsp;6.32.&nbsp;infixAnd</b></p></div><br class="figure-break"><div class="example"><a name="d0e3734"></a><p class="title"><b>Example&nbsp;6.33.&nbsp;infixAnd</b></p><div class="example-contents"><pre class="programlisting">Cheese( cheeseType : type ) and Person( favouriteCheese == cheeseType ) //infixAnd
(Cheese( cheeseType : type ) and (Person( favouriteCheese == cheeseType ) or Person( favouriteCheese == cheeseType  ) ) //infixAnd with grouping</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3739"></a>6.5.2.3.&nbsp;'or'</h4></div></div></div><p>The 'or' Conditional Element is used to group together other
      Conditional Elements. Drools supports both prefix and infix; although
      prefix is the preferred option as grouping is implicit which avoids
      confusion. The behavior of the 'or' Conditional Element is different
      than the '||' connective for constraints and restrictions in field
      constraints. The engine actually has no understanding of 'or'
      Conditional Elements, instead via a number of different logic
      transformations the rule is re-written as a number of subrules; the rule
      now has a single 'or' as the root node and a subrule per logical
      outcome. Each subrule can activate and fire like any normal rule, there
      is no special behavior or interactions between the subrules - this can
      be most confusing to new rule authors.</p><div class="figure"><a name="d0e3744"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/prefixOr.png" align="middle" alt="prefixOr"></div></div><p class="title"><b>Figure&nbsp;6.33.&nbsp;prefixOr</b></p></div><br class="figure-break"><div class="example"><a name="d0e3752"></a><p class="title"><b>Example&nbsp;6.34.&nbsp;prefixOr</b></p><div class="example-contents"><pre class="programlisting">(or Person( sex == "f", age &gt; 60 )
    Person( sex == "m", age &gt; 65 )
</pre></div></div><br class="example-break"><p>Infix 'or' is supported along with explicit grouping with
      parenthesis, should it be needed. The '||' symbol, as an alternative to
      'or', is deprecated although it is still supported in the syntax for
      legacy support reasons.</p><div class="figure"><a name="d0e3759"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/infixOr.png" align="middle" alt="infixOr"></div></div><p class="title"><b>Figure&nbsp;6.34.&nbsp;infixOr</b></p></div><br class="figure-break"><div class="example"><a name="d0e3767"></a><p class="title"><b>Example&nbsp;6.35.&nbsp;infixAnd</b></p><div class="example-contents"><pre class="programlisting">Cheese( cheeseType : type ) or Person( favouriteCheese == cheeseType ) //infixOr
(Cheese( cheeseType : type ) or (Person( favouriteCheese == cheeseType ) and Person( favouriteCheese == cheeseType  ) ) //infixOr with grouping</pre></div></div><br class="example-break"><p>The 'or' Conditional Element also allows for optional pattern
      binding; which means each resulting subrule will bind it's pattern to
      the pattern binding.</p><div class="example"><a name="d0e3774"></a><p class="title"><b>Example&nbsp;6.36.&nbsp;or with binding</b></p><div class="example-contents"><pre class="programlisting">pensioner : (or Person( sex == "f", age &gt; 60 ) 
                Person( sex == "m", age &gt; 65 ) )</pre><p>Explicit binding on each Pattern is also allowed.</p><pre class="programlisting">(or pensioner : Person( sex == "f", age &gt; 60 ) 
    pensioner : Person( sex == "m", age &gt; 65 ) )</pre></div></div><br class="example-break"><p>The 'or' conditional element results in multiple rule generation,
      called sub rules, for each possible logically outcome. The example above
      would result in the internal generation of two rules. These two rules
      work independently within the Working Memory, which means both can
      match, activate and fire - there is no shortcutting.</p><p>The best way to think of the OR conditional element is as a
      shortcut for generating 2 additional rules. When you think of it that
      way, its clear that for a single rule there could be multiple
      activations if both sides of the OR conditional element are true.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3787"></a>6.5.2.4.&nbsp;'eval'</h4></div></div></div><div class="figure"><a name="d0e3790"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/eval.png" align="middle" alt="eval"></div></div><p class="title"><b>Figure&nbsp;6.35.&nbsp;eval</b></p></div><br class="figure-break"><p>Eval is essentially a catch all which allows any semantic code
      (that returns a primitive boolean) to be executed. This can refer to
      variables that were bound in the LHS of the rule, and functions in the
      rule package. Over use of eval reduces the declaratives of your rules
      and can result in a poor performing engine. While 'evals' can be used
      anywhere in the Pattern the best practice is to add it as the last
      conditional element in the LHS of a rule.</p><p>Evals cannot be indexed and thus are not as optimal as using Field
      Constraints. However this makes them ideal for being used when functions
      return values that change over time, which is not allowed within Field
      Constraints.</p><p>For folks who are familiar with Drools 2.x lineage, the old Drools
      parameter and condition tags are equivalent to binding a variable to an
      appropriate type, and then using it in an eval node.</p><div class="example"><a name="d0e3804"></a><p class="title"><b>Example&nbsp;6.37.&nbsp;eval</b></p><div class="example-contents"><pre class="programlisting">p1 : Parameter() 
p2 : Parameter()
eval( p1.getList().containsKey(p2.getItem()) )
eval( isValid(p1, p2) ) //this is how you call a function in the LHS - a function called "isValid"</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3809"></a>6.5.2.5.&nbsp;'not'</h4></div></div></div><div class="figure"><a name="d0e3812"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/not.png" align="middle" alt="not"></div></div><p class="title"><b>Figure&nbsp;6.36.&nbsp;not</b></p></div><br class="figure-break"><p>'not' is first order logic's Non-Existential Quantifier and checks
      for the non existence of something in the Working Memory. Think of 'not'
      as meaning "there must be none of...".</p><p>A 'not' statement must be followed by parentheses around the CEs
      that it applies to. In the simplest case of a single pattern (like
      below) you may optionally omit the parentheses.</p><div class="example"><a name="d0e3824"></a><p class="title"><b>Example&nbsp;6.38.&nbsp;No Busses</b></p><div class="example-contents"><pre class="programlisting">not Bus()</pre></div></div><br class="example-break"><div class="example"><a name="d0e3829"></a><p class="title"><b>Example&nbsp;6.39.&nbsp;No red Busses</b></p><div class="example-contents"><pre class="programlisting">not Bus(color == "red") //brackets are optional for this simple pattern
not ( Bus(color == "red", number == 42) ) //brackets are optional for this simple case
not ( Bus(color == "red") and Bus(color == "blue")) // not with nested 'and' infix used here as ony two patterns 
                                                      (but brackets are required).</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3834"></a>6.5.2.6.&nbsp;'exists'</h4></div></div></div><div class="figure"><a name="d0e3837"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/exists.png" align="middle" alt="exists"></div></div><p class="title"><b>Figure&nbsp;6.37.&nbsp;exists</b></p></div><br class="figure-break"><p>'exists' is first order logic's Existential Quantifier and checks
      for the existence of something in the Working Memory. Think of exist as
      meaning "at least one..". It is different from just having the Pattern
      on its own; which is more like saying "for each one of...". if you use
      exist with a Pattern, then the rule will only activate once regardless
      of how much data there is in working memory that matches that
      condition.</p><p>An 'exist' statement must be followed by parentheses around the
      CEs that it applies to. In the simplest case of a single pattern (like
      below) you may optionally omit the parentheses.</p><div class="example"><a name="d0e3849"></a><p class="title"><b>Example&nbsp;6.40.&nbsp;Atleast one Bus</b></p><div class="example-contents"><pre class="programlisting">exists Bus()</pre></div></div><br class="example-break"><div class="example"><a name="d0e3854"></a><p class="title"><b>Example&nbsp;6.41.&nbsp;Atleast one red Bus</b></p><div class="example-contents"><pre class="programlisting">exists Bus(color == "red")
exists ( Bus(color == "red", number == 42) ) //brackets are optional
exists ( Bus(color == "red") and Bus(color == "blue")) // exists with nested 'and' infix used here as ony two patterns</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3859"></a>6.5.2.7.&nbsp;'forall'</h4></div></div></div><div class="figure"><a name="d0e3862"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/forall.png" align="middle" alt="forall"></div></div><p class="title"><b>Figure&nbsp;6.38.&nbsp;forall</b></p></div><br class="figure-break"><p>The <span class="bold"><strong>forall</strong></span> Conditional Element
      completes the First Order Logic support in Drools. The <span class="bold"><strong>forall</strong></span> Conditional Element will evaluate to true
      when all facts that match the first pattern match all the remaining
      patterns. Example:</p><pre class="programlisting">rule "All english buses are red"
when
    forall( $bus : Bus( type == 'english') 
                   Bus( this == $bus, color = 'red' ) )
then
    # all english buses are red
end
</pre><p>In the above rule, we "select" all Bus object whose type is
      "english". Then, for each fact that matches this pattern we evaluate the
      following patterns and if they match, the forall CE will evaluate to
      true.</p><p>To state that all facts of a given type in the working memory must
      match a set of constraints, forall can be written with a single pattern
      for simplicity. Example</p><div class="example"><a name="d0e3885"></a><p class="title"><b>Example&nbsp;6.42.&nbsp;Single Pattern Forall</b></p><div class="example-contents"><pre class="programlisting">rule "All Buses are Red"
when
    forall( Bus( color == 'red' ) )
then
    # all asserted Bus facts are red
end
</pre></div></div><p><br class="example-break"> The above is exactly the same as writing:</p><p>Another example of multi-pattern forall:</p><div class="example"><a name="d0e3893"></a><p class="title"><b>Example&nbsp;6.43.&nbsp;Multi-Pattern Forall</b></p><div class="example-contents"><pre class="programlisting">rule "all employees have health and dental care programs"
when
    forall( $emp : Employee()
            HealthCare( employee == $emp )
            DentalCare( employee == $emp )
          )
then
    # all employees have health and dental care
end
</pre></div></div><p><br class="example-break"></p><p>Forall can be nested inside other CEs for complete expressiveness.
      For instance, <span class="bold"><strong>forall</strong></span> can be used inside
      a <span class="bold"><strong>not</strong></span> CE, note that only single
      patterns have optional parenthesis, so with a nested forall parenthesis
      must be used :</p><div class="example"><a name="d0e3906"></a><p class="title"><b>Example&nbsp;6.44.&nbsp;Combining Forall with Not CE</b></p><div class="example-contents"><pre class="programlisting">rule "not all employees have health and dental care"
when 
    not ( forall( $emp : Employee()
                HealthCare( employee == $emp )
                DentalCare( employee == $emp ) ) 
        )
then
    # not all employees have health and dental care
end
</pre></div></div><p><br class="example-break"></p><p>As a side note, forall Conditional Element is equivalent to
      writing:</p><pre class="programlisting">not( <em class="replaceable"><code>&lt;first pattern&gt;</code></em> and not ( and <em class="replaceable"><code>&lt;remaining patterns&gt;</code></em> ) )</pre><p>Also, it is important to note that <span class="bold"><strong>forall is
      a scope delimiter</strong></span>, so it can use any previously bound
      variable, but no variable bound inside it will be available to use
      outside of it.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3926"></a>6.5.2.8.&nbsp;From</h4></div></div></div><div class="figure"><a name="d0e3929"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/from.png" align="middle" alt="from"></div></div><p class="title"><b>Figure&nbsp;6.39.&nbsp;from</b></p></div><br class="figure-break"><p>The <span class="bold"><strong>from</strong></span> Conditional Element
      allows users to specify a source for patterns to reason over. This
      allows the engine to reason over data not in the Working Memory. This
      could be a sub-field on a bound variable or the results of a method
      call. It is a powerful construction that allows out of the box
      integration with other application components and frameworks. One common
      example is the integration with data retrieved on-demand from databases
      using hibernate named queries.</p><p>The expression used to define the object source is any expression
      that follows regular MVEL syntax. I.e., it allows you to easily use
      object property navigation, execute method calls and access maps and
      collections elements.</p><p>Here is a simple example of reasoning and binding on another
      pattern sub-field:</p><pre class="programlisting">rule "validate zipcode"
when
    Person( $personAddress : address ) 
    Address( zipcode == "23920W") from $personAddress 
then
    # zip code is ok
end
</pre><p>With all the flexibility from the new expressiveness in the Drools
      engine you can slice and dice this problem many ways. This is the same
      but shows how you can use a graph notation with the 'from':</p><pre class="programlisting">rule "validate zipcode"
when
    $p : Person( ) 
    $a : Address( zipcode == "23920W") from $p.address 
then
    # zip code is ok
end
</pre><p>Previous examples were reasoning over a single pattern. The
      <span class="bold"><strong>from</strong></span> CE also support object sources
      that return a collection of objects. In that case, <span class="bold"><strong>from</strong></span> will iterate over all objects in the
      collection and try to match each of them individually. For instance, if
      we want a rule that applies 10% discount to each item in an order, we
      could do:</p><pre class="programlisting">rule "apply 10% discount to all items over US$ 100,00 in an order"
when
    $order : Order()
    $item  : OrderItem( value &gt; 100 ) from $order.items
then
    # apply discount to $item
end
</pre><p>The above example will cause the rule to fire once for each item
      whose value is greater than 100 for each given order.</p><p>The next example shows how we can reason over the results of a
      hibernate query. The Restaurant pattern will reason over and bind with
      each result in turn:</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3968"></a>6.5.2.9.&nbsp;'collect'</h4></div></div></div><div class="figure"><a name="d0e3971"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/collect.png" align="middle" alt="collect"></div></div><p class="title"><b>Figure&nbsp;6.40.&nbsp;collect</b></p></div><br class="figure-break"><p>The <span class="bold"><strong>collect</strong></span> Conditional Element
      allows rules to reason over collection of objects collected from the
      given source or from the working memory. In first oder logic terms this
      is Cardinality Quantifier. A simple example:</p><pre class="programlisting">import java.util.ArrayList

rule "Raise priority if system has more than 3 pending alarms"
when
    $system : System()
    $alarms : ArrayList( size &gt;= 3 )
              from collect( Alarm( system == $system, status == 'pending' ) )
then
    # Raise priority, because system $system has
    # 3 or more alarms pending. The pending alarms
    # are $alarms.
end
</pre><p>In the above example, the rule will look for all pending alarms in
      the working memory for each given system and group them in ArrayLists.
      If 3 or more alarms are found for a given system, the rule will
      fire.</p><p>The <span class="bold"><strong>collect</strong></span> CE result pattern can
      be any concrete class that implements tha java.util.Collection interface
      and provides a default no-arg public constructor. I.e., you can use
      default java collections like ArrayList, LinkedList, HashSet, etc, or
      your own class, as long as it implements the java.util.Collection
      interface and provide a default no-arg public constructor.</p><p>Both source and result patterns can be constrained as any other
      pattern.</p><p>Variables bound before the <span class="bold"><strong>collect</strong></span> CE are in the scope of both source and
      result patterns and as so, you can use them to constrain both your
      source and result patterns. Although, the <span class="emphasis"><em>collect( ...
      )</em></span> is a scope delimiter for bindings, meaning that any binding
      made inside of it, is not available for use outside of it.</p><p>Collect accepts nested <span class="bold"><strong>from</strong></span>
      elements, so the following example is a valid use of <span class="bold"><strong>collect</strong></span>:</p><pre class="programlisting">import java.util.LinkedList;

rule "Send a message to all mothers"
when
    $town : Town( name == 'Paris' )
    $mothers : LinkedList() 
               from collect( Person( gender == 'F', children &gt; 0 ) 
                             from $town.getPeople() 
                           )
then
    # send a message to all mothers
end
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4013"></a>6.5.2.10.&nbsp;'accumulate'</h4></div></div></div><div class="figure"><a name="d0e4016"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/accumulate.png" align="middle" alt="accumulate"></div></div><p class="title"><b>Figure&nbsp;6.41.&nbsp;accumulate</b></p></div><br class="figure-break"><p>The <span class="bold"><strong>accumulate</strong></span> Conditional
      Element is a more flexible and powerful form of <span class="bold"><strong>collect</strong></span> Conditional Element, in the sense that it
      can be used to do what <span class="bold"><strong>collect</strong></span> CE does
      and also do things that <span class="bold"><strong>collect</strong></span> CE is
      not capable to do. Basically what it does is it allows a rule to iterate
      over a collection of objects, executing custom actions for each of the
      elements, and at the end return a result object.</p><p>The general syntax of the <span class="bold"><strong>accumulate</strong></span> CE is:</p><pre class="programlisting"><em class="replaceable"><code>&lt;result pattern&gt;</code></em> from accumulate( <em class="replaceable"><code>&lt;source pattern&gt;</code></em>,
                                  init( <em class="replaceable"><code>&lt;init code&gt;</code></em> ),
                                  action( <em class="replaceable"><code>&lt;action code&gt;</code></em> ),
                                  reverse( <em class="replaceable"><code>&lt;reverse code&gt;</code></em> ),
                                  result( <em class="replaceable"><code>&lt;result expression&gt;</code></em> ) )
</pre><p>The meaning of each of the elements is the following:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>&lt;source pattern&gt;</strong></span>: the
          source pattern is a regular pattern that the engine will try to
          match against each of the source objects.</p></li><li><p><span class="bold"><strong>&lt;init code&gt;</strong></span>: this is a
          semantic block of code in the selected dialect that will be executed
          once for each tuple, before iterating over the source
          objects.</p></li><li><p><span class="bold"><strong>&lt;action code&gt;</strong></span>: this is
          a semantic block of code in the selected dialect that will be
          executed for each of the source objects.</p></li><li><p><span class="bold"><strong>&lt;reverse code&gt;</strong></span>: this is
          an optional semantic block of code in the selected dialect that if
          present will be executed for each source object that no longer
          matches the source pattern. The objective of this code block is to
          "undo" any calculation done in the &lt;action code&gt; block, so
          that the engine can do decremental calculation when a source object
          is modified or retracted, hugely improving performance of these
          operations.</p></li><li><p><span class="bold"><strong>&lt;result expression&gt;</strong></span>:
          this is a semantic expression in the selected dialect that is
          executed after all source objects are iterated.</p></li><li><p><span class="bold"><strong>&lt;result pattern&gt;</strong></span>: this
          is a regular pattern that the engine tries to match against the
          object returned from the &lt;result expression&gt;. If it matches,
          the <span class="bold"><strong>accumulate</strong></span> conditional element
          evaluates to <span class="bold"><strong>true</strong></span> and the engine
          proceeds with the evaluation of the next CE in the rule. If it does
          not matches, the <span class="bold"><strong>accumulate</strong></span> CE
          evaluates to <span class="bold"><strong>false</strong></span> and the engine
          stops evaluating CEs for that rule.</p></li></ul></div><p>It is easier to understand if we look at an example:</p><pre class="programlisting">rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              init( double total = 0; ),
                              action( total += $value; ),
                              reverse( total -= $value; ),
                              result( total ) )
then
    # apply discount to $order
end
</pre><p>In the above example, for each Order() in the working memory, the
      engine will execute the <span class="bold"><strong>init code</strong></span>
      initializing the total variable to zero. Then it will iterate over all
      OrderItem() objects for that order, executing the <span class="bold"><strong>action</strong></span> for each one (in the example, it will sum
      the value of all items into the total variable). After iterating over
      all OrderItem, it will return the value corresponding to the <span class="bold"><strong>result expression</strong></span> (in the above example, the
      value of the total variable). Finally, the engine will try to match the
      result with the Number() pattern and if the double value is greater than
      100, the rule will fire.</p><p>The example used java as the semantic dialect, and as such, note
      that the usage of ';' is mandatory in the init, action and reverse code
      blocks. The result is an expression and as such, it does not admit ';'.
      If the user uses any other dialect, he must comply to that dialect
      specific syntax.</p><p>As mentioned before, the <span class="bold"><strong>reverse
      code</strong></span> is optional, but it is strongly recommended that the
      user writes it in order to benefit from the <span class="emphasis"><em>improved
      performance on update and retracts</em></span>.</p><p>The <span class="bold"><strong>accumulate</strong></span> CE can be used to
      execute any action on source objects. The following example instantiates
      and populates a custom object:</p><pre class="programlisting">rule "Accumulate using custom objects"
when
    $person   : Person( $likes : likes )
    $cheesery : Cheesery( totalAmount &gt; 100 )
                from accumulate( $cheese : Cheese( type == $likes ),
                                 init( Cheesery cheesery = new Cheesery(); ),
                                 action( cheesery.addCheese( $cheese ); ),
                                 reverse( cheesery.removeCheese( $cheese ); ),
                                 result( cheesery ) );
then
    // do something
end</pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e4139"></a>6.5.2.10.1.&nbsp;Accumulate Functions</h5></div></div></div><p>The accumulate CE is a very powerful CE, but it gets real
        declarative and easy to use when using predefined functions that are
        known as Accumulate Functions. They work exactly like accumulate, but
        instead of explicitly writing custom code in every accumulate CE, the
        user can use predefined code for common operations.</p><p>For instance, the rule to apply discount on orders written in
        the previous section, could be written in the following way, using
        Accumulate Functions:</p><pre class="programlisting">rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              sum( $value ) )
then
    # apply discount to $order
end
</pre><p>In the above example, sum is an AccumulateFunction and will sum
        the $value of all OrderItems and return the result.</p><p>Drools 4.0 ships with the following built in accumulate
        functions:</p><div class="itemizedlist"><ul type="disc"><li><p>average</p></li><li><p>min</p></li><li><p>max</p></li><li><p>count</p></li><li><p>sum</p></li></ul></div><p>These common functions accept any expression as input. For
        instance, if someone wants to calculate the average profit on all
        items of an order, a rule could be written using the average
        function:</p><pre class="programlisting">rule "Average profit"
when
    $order : Order()
    $profit : Number() 
              from accumulate( OrderItem( order == $order, $cost : cost, $price : price )
                               average( 1 - $cost / $price ) )
then
    # average profit for $order is $profit
end
</pre><p>Accumulate Functions are all pluggable. That means that if
        needed, custom, domain specific functions can easily be added to the
        engine and rules can start to use them without any restrictions. To
        implement a new Accumulate Functions all one needs to do is to create
        a java class that implements the
        org.drools.base.acumulators.AccumulateFunction interface and add a
        line to the configuration file or set a system property to let the
        engine know about the new function. As an example of an Accumulate
        Function implementation, the following is the implementation of the
        "average" function:</p><pre class="programlisting">/*
 * Copyright 2007 JBoss Inc
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created on Jun 21, 2007
 */
package org.drools.base.accumulators;


/**
 * An implementation of an accumulator capable of calculating average values
 * 
 * @author etirelli
 *
 */
public class AverageAccumulateFunction implements AccumulateFunction {

    protected static class AverageData {
        public int    count = 0;
        public double total = 0;
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#createContext()
     */
    public Object createContext() {
        return new AverageData();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#init(java.lang.Object)
     */
    public void init(Object context) throws Exception {
        AverageData data = (AverageData) context;
        data.count = 0;
        data.total = 0;
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#accumulate(java.lang.Object, java.lang.Object)
     */
    public void accumulate(Object context,
                           Object value) {
        AverageData data = (AverageData) context;
        data.count++;
        data.total += ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#reverse(java.lang.Object, java.lang.Object)
     */
    public void reverse(Object context,
                        Object value) throws Exception {
        AverageData data = (AverageData) context;
        data.count--;
        data.total -= ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#getResult(java.lang.Object)
     */
    public Object getResult(Object context) throws Exception {
        AverageData data = (AverageData) context;
        return new Double( data.count == 0 ? 0 : data.total / data.count );
    }

    /* (non-Javadoc)
     * @see org.drools.base.accumulators.AccumulateFunction#supportsReverse()
     */
    public boolean supportsReverse() {
        return true;
    }

}
</pre><p>The code for the function is very simple, as we could expect, as
        all the "dirty" integration work is done by the engine. Finally, to
        plug the function into the engine, we added it to the configuration
        file:</p><pre class="programlisting">drools.accumulate.function.average = org.drools.base.accumulators.AverageAccumulateFunction
</pre><p>Where "drools.accumulate.function." is a prefix that must always
        be used, "average" is how the function will be used in the rule file,
        and "org.drools.base.accumulators.AverageAccumulateFunction" is the
        fully qualified name of the class that implements the function
        behavior.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4182"></a>6.5.3.&nbsp;The Right Hand Side (then)</h3></div></div></div><p>The Right Hand Side (RHS) is a common name for the consequence or
    action part of the rule; this part should contain a list of actions to be
    executed. It is bad practice to use imperative or conditional code in the
    RHS of a rule; as a rule should be atomic in nature - "when this, then do
    this", not "when this, maybe do this". The RHS part of a rule should also
    be kept small, thus keeping it declarative and readable. If you find you
    need imperative and/or conditional code in the RHS, then maybe you should
    be breaking that rule down into multiple rules. The main purpose of the
    RHS is to insert, retractor modify working memory data. To assist with
    there there are a few convenience methods you can use to modify working
    memory; without having to first reference a working memory
    instance.</p><p>"update(object, handle);" will tell the engine that an object has
    changed (one that has been bound to something on the LHS) and rules may
    need to be reconsidered.</p><p>"update(object);"  can also be used, here the KnowledgeHelper will
    lookup the facthandle for you, via an identity check, for the passed object.</p><p>"insert(new Something());" will place a new object of your creation
    in working memory.</p><p>"insertLogical(new Something());" is similar to insert, but the
    object will be automatically retracted when there are no more facts to
    support the truth of the currently firing rule.</p><p>"retract(handle);" removes an object from working memory.</p><p>These convenience methods are basically macros that provide short
    cuts to the KnowldgeHelper instance (refer to the KnowledgeHelper
    interface for more advanced operations). The KnowledgeHelper interface is
    made available to the RHS code block as a variable called "drools". If you
    provide "Property Change Listeners" to your java beans that you are
    inserting into the engine, you can avoid the need to call "update" when
    the object changes.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4199"></a>6.5.4.&nbsp;A note on auto boxing/unboxing and primitive types</h3></div></div></div><p>Drools attempts to preserve numbers in their primitive or object
    wrapper form, so a variable bound to an int primitive when used in a code
    block or expression will no longer need manual unboxing; unlike Drools 3.0
    where all primitives was autoboxed, requiring manual unboxing. A variable
    bound to an object wrapper will remain as an object; the existing jdk1.5
    and jdk5 rules to handling auto boxing/unboxing apply in this case. When
    evaluating field constraints the system attempts to coerce one of the
    values into a comparable format; so a primitive is comparable to an object
    wrapper.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4204"></a>6.6.&nbsp;Query</h2></div></div></div><div class="figure"><a name="d0e4207"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/query.png" align="middle" alt="query"></div></div><p class="title"><b>Figure&nbsp;6.42.&nbsp;query</b></p></div><br class="figure-break"><p>A query contains the structure of the LHS of a rule only (you don't
  specify "when" or "then"). It is simply a way to query the working memory
  for facts that match the conditions stated. A query has an optional set of
  parameters, that can also be optionally typed, if type is not given then
  Object type is assumed and the engine will attempt to co-erce the values as
  needed.</p><p>To return the results use WorkingMemory.getQueryResults("name") -
  where "name" is query name. Query names are global to the RuleBase, so do
  not add queries of the same name to different packages for the same Rule
  Base. This contains a list of query results, which allow you to to get to
  the objects that matched the query.</p><p>This example creates a simple query for all the people over the age of
  30</p><div class="example"><a name="d0e4221"></a><p class="title"><b>Example&nbsp;6.45.&nbsp;Query People over the age of 30</b></p><div class="example-contents"><pre class="programlisting">query "people over the age of 30" 
    person : Person( age &gt; 30 )
end</pre></div></div><br class="example-break"><div class="example"><a name="d0e4226"></a><p class="title"><b>Example&nbsp;6.46.&nbsp;Query People over the age of X, and who live in y</b></p><div class="example-contents"><pre class="programlisting">query "people over the age of X"  (int x, String y)
    person : Person( age &gt; x, location == y )
end</pre></div></div><br class="example-break"><p>We iterate over the returned QueryResults using a standard 'for' loop.
  Each row returns a QueryResult which we can use to access each of the
  columns in the Tuple. Those columns can be access by bound declaration name
  or index position.</p><div class="example"><a name="d0e4233"></a><p class="title"><b>Example&nbsp;6.47.&nbsp;Query People over the age of 30</b></p><div class="example-contents"><pre class="programlisting">QueryResults results = workingMemory.getQueryResults( "people over the age of 30" );
System.out.println( "we have " + results.size() + " people over the age  of 30" );

System.out.println( "These people are are over 30:" );

for ( Iterator it = results.iterator; it.hasNext(); ) {
    QueryResult result = ( QueryResult ) it.next();
    Person person = ( Person ) result.get( "person" );
    System.out.println( person.getName() + "\n" );
}</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4238"></a>6.7.&nbsp;Domain Specific Languages</h2></div></div></div><p>As mentioned previously, <a class="indexterm" name="d0e4243"></a>(or DSLs) are a way of extending the rule language to your
  problem domain. They are wired in to the rule language for you, and can make
  use of all the underlying rule language and engine features.</p><p>DSLs are used both in the IDE, as well as the web based BRMS. Of
  course as rules are text, you can use them even without this tooling.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4249"></a>6.7.1.&nbsp;When to use a DSL</h3></div></div></div><p>DSLs can serve as a layer of separation between rule authoring (and
    rule authors) and the domain objects that the engine operates on. DSLs can
    also act as "templates" of conditions or actions that are used over and
    over in your rules, perhaps only with parameters changing each time. If
    your rules need to be read and validated by less technical folk, (such as
    Business Analysts) the DSLs are definitely for you. If the conditions or
    consequences of your rules follow similar patterns which you can express
    in a template. You wish to hide away your implementation details, and
    focus on the business rule. You want to provide a controlled means of
    editing rules based on pre-defined templates.</p><p>DSLs have no impact on the rules at runtime, they are just a
    parse/compile time feature.</p><p>Note that Drools 4 DSLs are quite different from Drools 2 XML based
    DSLs. It is still possible to do Drools 2 style XML languages - if you
    require this, then take a look at the Drools 4 XML rule language, and
    consider using XSLT to map from your XML language to the Drools 4 XML
    language.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4258"></a>6.7.2.&nbsp;Editing and managing a DSL</h3></div></div></div><p>A DSL's configuration like most things is stored in plain text. If
    you use the IDE, you get a nice graphical editor (with some validation),
    but the format of the file is quite simple, and is basically a properties
    file.</p><p>Note that since Drools 4.0, DSLs have become more powerful in
    allowing you to customise almost any part of the language, including
    keywords. Regular expressions can also be used to match words/sentences if
    needed (this is provided for enhanced localisation). However, not all
    features are supported by all the tools (although you can use them, the
    content assistance just may not be 100% accurate in certain cases).</p><div class="example"><a name="d0e4265"></a><p class="title"><b>Example&nbsp;6.48.&nbsp;Example <a class="indexterm" name="d0e4268"></a> mapping</b></p><div class="example-contents"><pre class="programlisting">[when]This is {something}=Something(something=={something})</pre></div></div><br class="example-break"><p>Referring to the above example, the [when] refers to the scope of
    the expression: ie does it belong on the LHS or the RHS of a rule. The
    part after the [scope] is the expression that you use in the rule
    (typically a natural language expression, but it doesn't have to be). The
    part on the right of the "=" is the mapping into the rule language (of
    course the form of this depends on if you are talking about the RHS or the
    LHS - if its the LHS, then its the normal LHS syntax, if its the RHS then
    its fragments of java code for instance).</p><p>The parser will take the expression you specify, and extract the
    values that match where the {something} (named Tokens) appear in the
    input. The values that match the tokens are then interpolated with the
    corresponding {something} (named Tokens) on the right hand side of the
    mapping (the target expression that the rule engine actually uses).</p><p>Note also that the "sentences" above can be regular expressions.
    This means the parser will match the sentence fragements that match the
    expressions. This means you can use (for instance) the '?' to indicate the
    character before it is optional (think of each sentence as a regular
    expression pattern - this means if you want to use regex characters - you
    will need to escape them with a '\' of course.</p><p>It is important to note that the DSL expressions are processed one
    line at a time. This means that in the above example, all the text after
    "There is " to the end of the line will be included as the value for
    "{something}" when it is interpolated into the target string. This may not
    be exactly what you want, as you may want to "chain" together different
    DSL expressions to generate a target expression. The best way around this
    is to make sure that the {tokens} are enclosed with characters or words.
    This means that the parser will scan along the sentence, and pluck out the
    value BETWEEN the characters (in the example below they are
    double-quotes). Note that the characters that surround the token are not
    included in when interpolating, just the contents between them (rather
    then all the way to the end of the line, as would otherwise be the
    case).</p><p>As a rule of thumb, use quotes for textual data that a rule editor
    may want to enter. You can also wrap words around the {tokens} to make
    sure you enclose the data you want to capture (see other example).</p><div class="example"><a name="d0e4284"></a><p class="title"><b>Example&nbsp;6.49.&nbsp;Example with quotes</b></p><div class="example-contents"><pre class="programlisting">[when]This is "{something}" and "{another}"=Something(something=="{something}", another=="{another}")
[when]This is {also} valid=Another(something=="{also}")</pre></div></div><br class="example-break"><p>It is a good idea to try and avoid punctuation in your DSL
    expressions where possible, other then quotes and the like - keep it
    simple it things will be easier. Using a DSL can make debugging slightly
    harder when you are first building rules, but it can make the maintenance
    easier (and of course the readability of the rules).</p><p>The "{" and "}" characters should only be used on the left hand side
    of the mapping (the expression) to mark tokens. On the right hand side you
    can use "{" and "}" on their own if needed - such as </p><pre class="programlisting">if (foo) {
    doSomething(); }</pre><p> as well as with the token names as shown
    above.</p><p>Don't forget that if you are capturing strings from users, you will
    also need the quotes on the right hand side of the mapping, just like a
    normal rule, as the result of the mapping must be a valid expression in
    the rule language.</p><div class="example"><a name="d0e4298"></a><p class="title"><b>Example&nbsp;6.50.&nbsp;Some more examples</b></p><div class="example-contents"><pre class="programlisting">#This is a comment to be ignored.
[when]There is a Person with name of "{name}"=Person(name=="{name}")
[when]Person is at least {age} years old and lives in "{location}"=Person(age &gt; {age}, location=="{location}")
[then]Log "{message}"=System.out.println("{message}");
[when]And = and</pre></div></div><br class="example-break"><p>Referring to the above examples, this would render the following
    input as shown below: </p><div class="example"><a name="d0e4305"></a><p class="title"><b>Example&nbsp;6.51.&nbsp;Some examples as processed</b></p><div class="example-contents"><pre class="programlisting">There is a Person with name of "kitty" ---&gt; Person(name="kitty")
Person is at least 42 years old and lives in "atlanta" ---&gt; Person(age &gt; 42, location="atlanta")
Log "boo" ---&gt; System.out.println("boo");
There is a Person with name of "bob" and Person is at least 30 years old and lives in "atlanta" 
          ---&gt; Person(name="kitty") and Person(age &gt; 30, location="atlanta")</pre></div></div><p><br class="example-break"></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4310"></a>6.7.3.&nbsp;Using a DSL in your rules</h3></div></div></div><p>A good way to get started if you are new to Rules (and DSLs) is just
    write the rules as you normally would against your object model. You can
    unit test as you go (like a good agile citizen!). Once you feel
    comfortable, you can look at extracting a domain language to express what
    you are doing in the rules. Note that once you have started using the
    "expander" keyword, you will get errors if the parser does not recognize
    expressions you have in there - you need to move everything to the DSL. As
    a way around this, you can prefix each line with "&gt;" and it will tell
    the parser to take that line literally, and not try and expand it (this is
    handy also if you are debugging why something isn't working).</p><p>Also, it is better to rename the extension of your rules file from
    ".drl" to ".dslr" when you start using DSLs, as that will allow the IDE to
    correctly recognize and work with your rules file.</p><p>As you work through building up your DSL, you will find that the DSL
    configuration stabilizes pretty quickly, and that as you add new rules and
    edit rules you are reusing the same DSL expressions over and over. The aim
    is to make things as fluent as possible.</p><p>To use the DSL when you want to compile and run the rules, you will
    need to pass the DSL configuration source along with the rule source.
    </p><pre class="programlisting">PackageBuilder builder = new PackageBuilder();
builder.addPackageFromDrl( source, dsl );
//source is a reader for the rule source, dsl is a reader for the DSL configuration
</pre><p> You will also need to specify the expander by name in the
    rule source file: </p><pre class="programlisting">expander your-expander.dsl
</pre><p>Typically you keep the DSL in the same directory as the rule,
    but this is not required if you are using the above API (you only need to
    pass a reader). Otherwise everything is just the same.</p><p>You can chain DSL expressions together on one line, as long as it is
    clear to the parser what the {tokens} are (otherwise you risk reading in
    too much text until the end of the line). The DSL expressions are
    processed according to the mapping file, top to bottom in order. You can
    also have the resulting rule expressions span lines - this means that you
    can do things like:</p><div class="example"><a name="d0e4329"></a><p class="title"><b>Example&nbsp;6.52.&nbsp;</b></p><div class="example-contents"><pre class="programlisting">There is a person called Bob who is happy
  Or
There is a person called Mike who is sad
</pre></div></div><br class="example-break"><p>Of course this assumes that "Or" is mapped to the "or" conditional
    element (which is a sensible thing to do).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4334"></a>6.7.4.&nbsp;Adding constraints to facts</h3></div></div></div><p>A common requirement when writing rule conditions is to be able to
    add many constraints to fact declarations. A fact may have many (dozens)
    of fields, all of which could be used or not used at various times. To
    come up with every combination as separate DSL statements would in many
    cases not be feasible.</p><p>The DSL facility allows you to achieve this however, with a simple
    convention. If your DSL expression starts with a "-", then it will be
    assumed to be a field constraint, which will be added to the declaration
    that is above it (one per line).</p><p>This is easier to explain with an example. Lets take look at Cheese
    class, with the following fields: type, price, age, country. We can
    express some LHS condition in normal DRL like the following
    </p><pre class="programlisting">Cheese(age &lt; 5, price == 20, type=="stilton", country=="ch")</pre><p>
    If you know ahead of time that you will use all the fields, all the time,
    it is easy to do a mapping using the above techniques. However, chances
    are that you will have many fields, and many combinations. If this is the
    case, you can setup your mappings like so: </p><pre class="programlisting">[when]There is a Cheese with=Cheese()
[when]- age is less than {age}=age&lt;{age}
[when]- type is '{type}'=type=='{type}'
[when]- country equal to '{country}'=country=='{country}'</pre><p><span class="bold"><strong>IMPORTANT:</strong></span> It is NOT possible to
    use the "-" feature after an <span class="bold"><strong>accumulate</strong></span>
    statement to add constraints to the accumulate pattern. This limitation
    will be removed in the future.</p><p>You can then write rules with conditions like the following:
    </p><pre class="programlisting">There is a Cheese with
        - age is less than 42
        - type is 'stilton'</pre><p> The parser will pick up the "-"
    lines (they have to be on their own line) and add them as constraints to
    the declaration above. So in this specific case, using the above mappings,
    is the equivalent to doing (in DRL): </p><pre class="programlisting">Cheese(age&lt;42, type=='stilton')</pre><p>
    The parser will do all the work for you, meaning you just define mappings
    for individual constraints, and can combine them how you like (if you are
    using context assistant, if you press "-" followed by CTRL+space it will
    conveniently provide you with a filtered list of field constraints to
    choose from.</p><p>To take this further, after alter the DSL to have
    [when][org.drools.Cheese]- age is less than {age} ... (and similar to all
    the items in the example above).</p><p>The extra [org.drools.Cheese] indicates that the sentence only
    applies for the main constraint sentence above it (in this case "There is
    a Cheese with"). For example, if you have a class called "Cheese" - then
    if you are adding contraints to the rule (by typing "-" and waiting for
    content assistance) then it will know that only items marked as having an
    object-scope of "com.yourcompany.Something" are valid, and suggest only
    them. This is entirely optional (you can leave out that section if needed
    - OR it can be left blank).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4367"></a>6.7.5.&nbsp;How it works</h3></div></div></div><p>DSLs kick in when the rule is parsed. The DSL configuration is read
    and supplied to the parser, so the parser can "expand" the DSL expressions
    into the real rule language expressions.</p><p>When the parser is processing the rules, it will check if an
    "expander" representing a DSL is enabled, if it is, it will try to expand
    the expression based on the context of where it is the rule. If an
    expression can not be expanded, then an error will be added to the
    results, and the line number recorded (this insures against typos when
    editing the rules with a DSL). At present, the DSL expander is fairly
    space sensitive, but this will be made more tolerant in future releases
    (including tolerance for a wide range of punctuation).</p><p>The expansion itself works by trying to match a line against the
    expression in the DSL configuration. The values that correspond to the
    token place holders are stored in a map based on the name of the token,
    and then interpolated to the target mapping. The values that match the
    token placeholders are extracted by either searching until the end of the
    line, or until a character or word after the token place holder is
    matched. The "{" and "}" are not included in the values that are
    extracted, they are only used to demarcate the tokens - you should not use
    these characters in the DSL expression (but you can in the target).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4376"></a>6.7.6.&nbsp;Creating a DSL from scratch</h3></div></div></div><p>DSLs can be aid with capturing rules if the rules are well known,
    just not in any technically usable format (ie. sitting around in people
    brains). Until we are able to have those little sockets in our necks like
    in the Matrix, our means of getting stuff into computers is still the old
    fashioned way.</p><p>Rules engines require a object or data model to operate on - in many
    cases you may know this up front. In other cases the model will be
    discovered with the rules. In any case, rules generally work better with
    simpler flatter object models. In some cases, this may mean having a rule
    object model which is a subset of the main applications model (perhaps
    mapped from it). Object models can often have complex relationships and
    hierarchies in them - for rules you will want to simplify and flatten the
    model where possible, and let the rule engine infer relationships (as it
    provides future flexibility). As stated previously, DSLs can have an
    advantage of providing some insulation between the object model and the
    rule language.</p><p>Coming up with a DSL is a collaborative approach for both technical
    and domain experts. Historically there was a role called "knowledge
    engineer" which is someone skilled in both the rule technology, and in
    capturing rules. Over a short period of time, your DSL should stabilize,
    which means that changes to rules are done entirely using the DSL. A
    suggested approach if you are starting from scratch is the following
    workflow: </p><div class="itemizedlist"><ul type="disc"><li><p>Capture rules as loose "if then" statements - this is really
          to get an idea of size and complexity (possibly in a text
          document).</p></li><li><p>Look for recurring statements in the rules captured. Also look
          for the rule objects/fields (and match them up with what may already
          be known of the object model).</p></li><li><p>Create a new DSL, and start adding statements from the above
          steps. Provide the "holes" for data to be edited (as many statements
          will be similar, with only some data changing).</p></li><li><p>Use the above DSL, and try to write the rules just like that
          appear in the "if then" statements from the first and second steps.
          Iterate this process until patterns appear and things stabilize. At
          this stage, you are not so worried about the rule language
          underneath, just the DSL.</p></li><li><p>At this stage you will need to look at the Objects, and the
          Fields that are needed for the rules, reconcile this with the
          datamodel so far.</p></li><li><p>Map the DSL statements to the rule language, based on the
          object model. Then repeat the process. Obviously this is best done
          in small steps, to make sure that things are on the right
          track.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4404"></a>6.7.7.&nbsp;Scope and keywords</h3></div></div></div><p>If you are editing the DSL with the GUI, or as text, you will notice
    there is a [scope] item at the start of each mapping line. This indicates
    if the sentence/word applies to the LHS, RHS or is a keyword. Valid values
    for this are [condition], [consequence] and [keyword] (with [when] and
    [then] being the same as [condition] and [consequence] respectively). When
    [keyword] is used, it means you can map any keyword of the language like
    "rule" or "end" to something else. Generally this is only used when you
    want to have a non English rule language (and you would ideally map it to
    a single word).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4409"></a>6.7.8.&nbsp;DSLs in the BRMS and IDE</h3></div></div></div><p>You can use DSLs in the BRMS in both guided editor rules, and
    textual rules that use a dsl. (In fact, the same applies to the
    IDE).</p><p>In the guided editor - the DSLs generally have to be simpler - what
    you are doing is defining little "forms" to capture data from users in
    text fields (ie as you pick a DSL expression - it will add an item to the
    GUI which only allows you enter data in the {token} parts of a DSL
    expression). You can not use sophisticated regular expressions to match
    text. However, in textual rules (which have a .dslr extension in the IDE)
    you are free to use the full power as needed.</p><p>In the BRMS - when you build a package the DSLs are already included
    and all the work is done for you. In the IDE (or in any IDE) - you will
    either need to use the drools-ant task, or otherwise use the code shown in
    sections above.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4418"></a>6.8.&nbsp;Rule Flow</h2></div></div></div><div class="figure"><a name="d0e4421"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/RuleFlow.png" align="middle" alt="Ruleflow"></div></div><p class="title"><b>Figure&nbsp;6.43.&nbsp;Ruleflow</b></p></div><br class="figure-break"><p>Drools already provides some functionality to define the order in
  which rules should be executed, like salience, activation groups, etc. When
  dealing with (possibly a lot of) large rule-sets, managing the order in
  which rules are evaluated might become complex. Ruleflow allows you to
  specify the order in which rule sets should be evaluated by using a flow
  chart. This allows you to define which rule sets should be evaluated in
  sequence or in parallel, to specify conditions under which rule sets should
  be evaluated, etc. This chapter contains a few ruleflow examples.</p><p>A rule flow is a graphical description of a sequence of steps that the
  rule engine needs to take, where the order is important. The ruleflow can
  also deal with conditional branching, parallelism, synchonization, etc.</p><p>To use a ruleflow to describe the order in which rules should be
  evaluatied, you should first group rules into rulefow-groups using the ruleflow-group
  rule attribute ("options" in the GUI).  Then you should create a ruleflow 
  graph (which is a flow chart) that graphically describe the order in which the rules
  should be considered (by specifying the order in which the ruleflow-groups should
  be evaluated).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4433"></a>6.8.1.&nbsp;Assigning rules to a ruleflow group</h3></div></div></div><pre class="programlisting">
  rule 'YourRule'
     ruleflow-group 'group1'
     when
      ...
     then
      ...
    end  
  </pre><p>This rule will then be placed in the ruleflow-group called "group1".</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4440"></a>6.8.2.&nbsp;A simple ruleflow</h3></div></div></div><div class="figure"><a name="d0e4443"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/RuleFlowSimple.png" align="middle" alt="Ruleflow"></div></div><p class="title"><b>Figure&nbsp;6.44.&nbsp;Ruleflow</b></p></div><br class="figure-break"><p>The above rule flow specifies that the rules in the group "Check Order" must be
    executed before the rules in the group "Process Order". This means that only
    rules which are marked as having a ruleflow-group of "Check Order" will be
    considered first, and then "Process Order". That's about it. You could
    achieve similar results with either using salience (setting priorities, but this
    is harder to maintain, and makes the time-relationship implicit in the
    rules), or agenda groups. However, using a ruleflow makes the order of
    processing explicit, almost like a meta-rule, and makes managing more complex
    situations a lot easier.  The various elements that can be used inside a ruleflow
    will be explained in more detail later.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4451"></a>6.8.3.&nbsp;How to build a rule flow</h3></div></div></div><p>Ruleflows can only be created by using the graphical ruleflow editor which is
    part of the Drools plugin for Eclipse.  Once you have set up a Drools project (check
    the IDE chapter if you do not know how to do this), you can start adding ruleflows.
    When in a project, use "control+N" to launch the new wizard, or right-click the directory
    you would like to put your ruleflow in and select "New ... Other ...":</p><div class="figure"><a name="d0e4456"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/RFNewWizard.png" align="middle" alt="Ruleflow"></div></div><p class="title"><b>Figure&nbsp;6.45.&nbsp;Ruleflow</b></p></div><br class="figure-break"><p>Choose the section on "Drools" and then pick "RuleFlow file".
    This will create a new .rf file.</p><p>Next you will see the graphical ruleflow editor. Now would be a good time to
    switch to the "Drools perspective" (if you haven't done so already) - this will tweak the UI so
    it is optimal for rules. Then ensure that you can see the "properties"
    panel down the bottom of the eclipse window, as it will be necessary to fill in the different
    properties of the elements in your ruleflow.  If you cannot see the properties view, open it using
    the Menu Window - Show View - Other ..., and under the General folder select the Properties view.</p><div class="figure"><a name="d0e4466"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/RFNameGroups.png" align="middle" alt="Groups"></div></div><p class="title"><b>Figure&nbsp;6.46.&nbsp;Groups</b></p></div><br class="figure-break"><p>The RuleFlow editor consists of a palette, a canvas and an outline view.  To add
    new elements to the canvas, select the element you would like to create in the palette
    and then add them to the canvas by clicking on the preferred location.  For example, 
    click on the RuleFlowGroup icon in the Component Pallette of the GUI
    - you can then draw a few rule flow groups. Clicking on an element in your ruleflow 
    allows you to set the properties of that element.</p><p>Click on a ruleflow group, and you should see the following:</p><div class="figure"><a name="d0e4476"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/RFGroupProperties.png" align="middle" alt="Group properties"></div></div><p class="title"><b>Figure&nbsp;6.47.&nbsp;Group properties</b></p></div><br class="figure-break"><p>You can see here you set the visible name, but you also need to set
    the actual group name that is used in the rules.</p><p>Next step is to join the groups together (if its a simple sequence
    of steps) - you use this by using "create connection" from the component
    palette. You should also create an "End" node (also from the component
    palette).</p><p>In practice, if you are using ruleflow, you will most likely be
    doing more then setting a simple sequence of groups to progress though.
    You are more likely modeling branches of processing. In this case you use
    "Split" and "Join" items from the component pallette. You use connections
    to connect from the start to ruleflow groups, or to Splits, and from
    splits to groups, joins etc. (i.e. basically like a simple flow chart that
    models your processing). You can work entirely graphically until you get
    the graph approximately right.</p><div class="figure"><a name="d0e4488"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/RFComplex.png" align="middle" alt="Complex ruleflow"></div></div><p class="title"><b>Figure&nbsp;6.48.&nbsp;Complex ruleflow</b></p></div><br class="figure-break"><p>The above flow is a more complex example. This example is an
    insurance claim processing rule flow. A description: Initially the claim
    data validation rules are processed (these check for data integrity and
    consistency, that all the information is there). Next there is a decision
    "split" - based on a condition which the rule flow checks (the value of
    the claim), it will either move on to an "auto-settlement" group, or to
    another "split", which checks if there was a fatality in the claim. If
    there was a fatality then it determines if the "regular" of fatality
    specific rules will take effect. And so on. What you can see from this is
    based on a few conditions in the rule flow the steps that the processing
    takes can be very different. Note that all the rules can be in one package
    - making maintenance easy. You can separate out the flow control from the
    actual rules.</p><div class="figure"><a name="d0e4496"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/RFSplitType.png" align="middle" alt="Split types"></div></div><p class="title"><b>Figure&nbsp;6.49.&nbsp;Split types</b></p></div><br class="figure-break"><p>Split types (referring to the above): When you click on a split, you
    will see the above properties panel. You then have to choose the type:
    AND, OR, and XOR. The interesting ones are OR and XOR: if you choose OR,
    then any of the "outputs" of the split can happen (ie processing can
    proceed in parallel down more then one path). If you chose XOR, then it
    will be only one path.</p><p>If you choose OR or XOR, then in the row that has constraints, you
    will see a button on the right hand side that has "..." - click on this,
    and you will see the constraint editor. From this constraint editor, you
    set the conditions which the split will use to decide which "output path"
    will be chosen.</p><div class="figure"><a name="d0e4506"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/RFEditConstraints.png" align="middle" alt="Edit constraints"></div></div><p class="title"><b>Figure&nbsp;6.50.&nbsp;Edit constraints</b></p></div><br class="figure-break"><p>Choose the output path you want to set the constraints for (eg
    Autosettlement), and then you should see the following constraint
    editor:</p><div class="figure"><a name="d0e4514"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/RFConstraintEditor.png" align="middle" alt="Constraint editor"></div></div><p class="title"><b>Figure&nbsp;6.51.&nbsp;Constraint editor</b></p></div><br class="figure-break"><p>This is a text editor where the constraints (which are like the
    condition part of a rule) are entered. These constraints operate on facts
    in the working memory (eg. in the above example, it is checking for claims
    with a value of less than 250). Should this condition be true, then the
    path specified by it will be followed.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4522"></a>6.8.4.&nbsp;Using a rule flow in your application</h3></div></div></div><p>Once you have a valid ruleflow (you can check its valid by pressing
    the green "tick" icon in the IDE), you can add a rule flow to a package
    just like a drl.  However, the IDE creates two versions of your ruleflow: one containing
    the ruleflow definition (*.rfm) and one containing additional graphical information (*.rf).
    When adding a ruleflow to a package, you should make sure that you are adding the
    .rfm file to your ruleflow (and not the .rf file).
    </p><pre class="programlisting">
Reader rfm = ... (rule flow reader, select your .RFM file here)
packageBuilder.addRuleFlow(rfm);
    </pre><p>
    </p><p>Alternatively, you can upload the .rf file to the BRMS (as a
    ruleflow asset) and it will automatically be included in packages that are
    deployed from it.</p><p>Ruleflows are only executed if you explicitly state that they should be
    executed.  This is because you could potentially define a lot of ruleflows in 
    your package and the engine has no way to know when you would like to start
    each of these.  To activate a particular ruleflow, you will
    need to start the process by calling the startProcess method on the working memory.
    For example, if you want to start a particular workflow after you have asserted your
    facts into the working memory, use: 
    </p><pre class="programlisting">workingMemory.startProcess("ID_From_your_Ruleflow_properties");</pre><p>
    (The ruleflow id can be specified in the properties view when you click the background canvas of your ruleflow).
    And then call fireAllRules(). This will start executing rules, taking the order specified in the ruleflow into account.
    Thats it !</p><p> You can also start a ruleflow process from within a rule consequence using
    </p><pre class="programlisting">drools.getWorkingMemory().startProcess("ID_From_your_Ruleflow_properties");</pre><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4542"></a>6.8.5.&nbsp;Different types of nodes in a ruleflow</h3></div></div></div><p>A ruleflow is a flow chart where different types of nodes are linked using connections.  It has the following properties: a (unique) id, a (display) name and a version.  You can also specify how the connections are visualized on the canvas using the connection layout property: 
      </p><div class="orderedlist"><ol type="1"><li><p>manual always draws your connections as lines going straight from their start to end point (with the possibility to use intermediate break points)
          </p></li><li><p>shortest path is similar, but it tries to go around any obstacles is might encounter between the start and end point (to avoid lines crossing nodes)
          </p></li><li><p>manhatten draws connections by only using horizontal and vertical lines
          </p></li></ol></div><p>
    </p><div class="figure"><a name="d0e4558"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Rule_Language/ruleflow_nodes.png" align="middle" alt="The different types of ruleflow nodes"></div></div><p class="title"><b>Figure&nbsp;6.52.&nbsp;The different types of ruleflow nodes</b></p></div><br class="figure-break"><p>Currently, ruleflow supports eight types of nodes:
    </p><div class="orderedlist"><ol type="1"><li><p>Start: the start of the ruleflow.  A ruleflow should have exactly one start node.  The start node cannot have incoming cnnections and should have one outgoing connection.  It contains one property "name" which is the display name of the node.  Whenever ruleflow process is started, the ruleflow will start executing here and automatically continue to the first node linked to this start node</p></li><li><p>End: the end of the ruleflow.  A ruleflow should have one or more end nodes.  The end node should have one incoming connection and cannot have outgoing connections.  It contains one property "name" which is the display name of the node.  When an end node is reached in the ruleflow, the ruleflow is terminated (including other remaining active nodes when parallelism is used).</p></li><li><p>RuleFlowGroup: represents a set of rules.  A RuleFlowGroup node should have one incoming connection and one outgoing connection.  It contains a property "name" which is the display name of the node, and the property ruleflow-group which is used to specify the name of the ruleflow-group that represents the set of rules of this RuleFlowGroup node.  When a RuleFlowGroup node is reached in the ruleflow, the engine will start executing rules that are part of the corresponding ruleflow-group.  Execution will automatically continue to the next node if there are no more active rules in this ruleflow-group.  This means that, during the execution of a ruleflow-group, it is possible that new activations belonging to the currently active ruleflow-group are added to the agenda due to changes made to the facts by the other rules. Note that the ruleflow will immediately continue with the next node if it encounters a ruleflow-group where there are no active rules at that point.</p></li><li><p>Split: allows you to create branches in your ruleflow.  A split node should have one incoming connection and two or more outgoing connections.  It contains a property "name" which is the display name of the node.  There are three types of splits currently supported:
          </p><div class="orderedlist"><ol type="a"><li><p>AND means that the control flow will continue in all outgoing connections simultaneously
            </p></li><li><p>XOR means that exactly one of the outgoing connections will be chosen.  Connections are chosen by evaluating the constraints that are linked to each of the outgoing connections.  Constraints are specified using the same syntax as the left-had side of a rule. The constraint with the lowest priority number that evaluates to true is selected.  Note that you should make sure that at least one of the outgoing connections will evaluate to true at runtime, or the ruleflow will throw an exception at runtime if it cannot find an outgoing connection.  For example, you could use a connection which is always true with a high priority number to specify what should happen if none of the other connections can be taken.
             </p></li><li><p>OR means that all outgoing connections whose condition evaluates to true are selected.  Conditions are similar to the XOR split, except that the priorities are not taken into account.  Note that you should make sure that at least one of the outgoing connections will evaluate to true at runtime, or the ruleflow will throw an exception at runtime if it cannot find an outgoing connection.
             </p></li></ol></div><p>

        </p></li><li><p>Join: allows you to synchronize multiple branches.  A join node should have two or more incoming connections and one outgoing connection.  It contains a property "name" which is the display name of the node.  There are two types of splits currently supported:
          </p><div class="orderedlist"><ol type="a"><li><p>AND means that is will wait until all incoming branches are completed before continuing
            </p></li><li><p>XOR means that it continues if one of its incoming branches has been completed
             </p></li></ol></div><p>
        </p></li><li><p>Milestone: represents a wait state.  A milestone should have one incoming connection and one outgoing connection.  It contains a property "name" which is the display name of the node, and the property "constraint" which specifies how long the ruleflow should wait in this state before continuing.  For example, a milestone constraint in an order entry application might specify that the ruleflow should wait until (a fact in the working memory specifies that) no more errors are found in the given order.  Constraints are specified using the same syntax as the left-had side of a rule.   When a Milestone node is reached in the ruleflow, the engine will check the associated constraint.  If the constraint evaluates to true directly, the flow will continue imediately.  Otherwise, the flow will continue if the constraint is satisfied later on, for example when a facts in the working memory is inserted, updated or removed.</p></li><li><p>Subflow: represents the invocation of another ruleflow from withing this ruleflow.  A subflow node should have one incoming connection and one outgoing connection.  It contains a property "name" which is the display name of the node, and the property "processId" which specifies the id of the process that should be executed.  When a Subflow node is reached in the ruleflow, the engine will start the process with the given id.  The subflow node will only continue if that subflow process has terminated its execution.  Note that the subflow process is started as an independent process, which means that the subflow process will not be terminated if this process reaches an end node.</p></li><li><p>Action: represents an action that should be executed in this ruleflow.  An action node should have one incoming connection and one outgoing connection.  It contains a property "name" which is the display name of the node, and the property "action" which specifies the action that should be executed.  When an action node is reached in the ruleflow, it will execute the action and continue with the next node.  An action should be specified as a piece of (valid) MVEL code.</p></li></ol></div><p>
    </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4611"></a>6.9.&nbsp;XML Rule Language</h2></div></div></div><p>As an option, Drools also supports a "native" <a class="indexterm" name="d0e4616"></a> rule language as an alternative to DRL. This allows you to
  capture and manage your rules as XML data. Just like the non-XML DRL format,
  the XML format is parsed into the internal "AST" representation - as fast as
  possible (using a SAX parser). There is no external transformation step
  required. All the features are available with XML that are available to
  DRL.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4620"></a>6.9.1.&nbsp;When to use XML</h3></div></div></div><p>There are several scenarios that XML is desirable. However, we
    recommend that it is not a default choice, as XML is not readily human
    readable (unless you like headaches) and can create visually bloated
    rules.</p><p>If you do want to edit XML by hand, use a good schema aware editor
    that provides nice hierarchical views of the XML, ideally visually
    (commercial tools like XMLSpy, Oxygen etc are good, but cost money, but
    then so do headache tablets).</p><p>Other scenarios where you may want to use the XML format are if you
    have a tool that generates rules from some input (programmatically
    generated rules), or perhaps interchange from another rule language, or
    from another tool that emits XML (using XSLT you can easily transform
    between XML formats). Note you can always generate normal DRL as
    well.</p><p>Alternatively you may be embedding drools in a product that already
    uses XML for configuration, so you would like the rules to be in an XML
    format. You may be creating your own rule language on XML - note that you
    can always use the AST objects directly to create your own rule language
    as well (the options are many, due to the open architecture).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4631"></a>6.9.2.&nbsp;The XML format</h3></div></div></div><p>A full W3C standards (XMLSchema) compliant XSD is provided that
    describes the XML language, which will not be repeated here verbatim. A
    summary of the language follows.</p><div class="example"><a name="d0e4636"></a><p class="title"><b>Example&nbsp;6.53.&nbsp;Example <a class="indexterm" name="d0e4639"></a></b></p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;package name="com.sample"
         xmlns="http://drools.org/drools-4.0"
         xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"
         xs:schemaLocation="http://drools.org/drools-4.0 drools-4.0.xsd"&gt;

&lt;import name="java.util.HashMap" /&gt;
&lt;import name="org.drools.*" /&gt;

&lt;global identifier="x" type="com.sample.X" /&gt;
&lt;global identifier="yada" type="com.sample.Yada" /&gt;

&lt;function return-type="void" name="myFunc"&gt;
    &lt;parameter identifier="foo" type="Bar" /&gt;
    &lt;parameter identifier="bada" type="Bing" /&gt;

    &lt;body&gt;
     System.out.println("hello world");
    &lt;/body&gt;
&lt;/function&gt;

&lt;rule name="simple_rule"&gt;
&lt;rule-attribute name="salience" value="10" /&gt;
&lt;rule-attribute name="no-loop" value="true" /&gt;
&lt;rule-attribute name="agenda-group" value="agenda-group" /&gt;
&lt;rule-attribute name="activation-group" value="activation-group" /&gt;

&lt;lhs&gt;
		&lt;pattern identifier="foo2" object-type="Bar" &gt;
            &lt;or-constraint-connective&gt;
                &lt;and-constraint-connective&gt;
                    &lt;field-constraint field-name="a"&gt;
                        &lt;or-restriction-connective&gt;
                            &lt;and-restriction-connective&gt;
                                &lt;literal-restriction evaluator="&gt;" value="60" /&gt;
                                &lt;literal-restriction evaluator="&lt;" value="70" /&gt;
                            &lt;/and-restriction-connective&gt;
                            &lt;and-restriction-connective&gt;
                                &lt;literal-restriction evaluator="&lt;" value="50" /&gt;
                                &lt;literal-restriction evaluator="&gt;" value="55" /&gt;
                            &lt;/and-restriction-connective&gt;
                        &lt;/or-restriction-connective&gt;
                    &lt;/field-constraint&gt;

                    &lt;field-constraint field-name="a3"&gt;
                        &lt;literal-restriction evaluator="==" value="black" /&gt;
                    &lt;/field-constraint&gt;
                &lt;/and-constraint-connective&gt;

                &lt;and-constraint-connective&gt;
                    &lt;field-constraint field-name="a"&gt;
                        &lt;literal-restriction evaluator="==" value="40" /&gt;
                    &lt;/field-constraint&gt;

                    &lt;field-constraint field-name="a3"&gt;
                        &lt;literal-restriction evaluator="==" value="pink" /&gt;
                    &lt;/field-constraint&gt;
                &lt;/and-constraint-connective&gt;

                &lt;and-constraint-connective&gt;
                    &lt;field-constraint field-name="a"&gt;
                        &lt;literal-restriction evaluator="==" value="12"/&gt;
                    &lt;/field-constraint&gt;

                    &lt;field-constraint field-name="a3"&gt;
                        &lt;or-restriction-connective&gt;
                            &lt;literal-restriction evaluator="==" value="yellow"/&gt;
                            &lt;literal-restriction evaluator="==" value="blue" /&gt;
                        &lt;/or-restriction-connective&gt;
                    &lt;/field-constraint&gt;
                &lt;/and-constraint-connective&gt;
            &lt;/or-constraint-connective&gt;
        &lt;/pattern&gt;

        &lt;not&gt;
            &lt;pattern object-type="Person"&gt;
                &lt;field-constraint field-name="likes"&gt;
                    &lt;variable-restriction evaluator="==" identifier="type"/&gt;
                &lt;/field-constraint&gt;
            &lt;/pattern&gt;

            &lt;exists&gt;
                &lt;pattern object-type="Person"&gt;
                    &lt;field-constraint field-name="likes"&gt;
                        &lt;variable-restriction evaluator="==" identifier="type"/&gt;
                    &lt;/field-constraint&gt;
                &lt;/pattern&gt;                
            &lt;/exists&gt;
        &lt;/not&gt;

        &lt;or-conditional-element&gt;
            &lt;pattern identifier="foo3" object-type="Bar" &gt;
                &lt;field-constraint field-name="a"&gt;
                    &lt;or-restriction-connective&gt;
                        &lt;literal-restriction evaluator="==" value="3" /&gt;
                        &lt;literal-restriction evaluator="==" value="4" /&gt;
                    &lt;/or-restriction-connective&gt;
                &lt;/field-constraint&gt;
                &lt;field-constraint field-name="a3"&gt;
                    &lt;literal-restriction evaluator="==" value="hello" /&gt;
                &lt;/field-constraint&gt;
                &lt;field-constraint field-name="a4"&gt;
                    &lt;literal-restriction evaluator="==" value="null" /&gt;
                &lt;/field-constraint&gt;
            &lt;/pattern&gt;

            &lt;pattern identifier="foo4" object-type="Bar" &gt;
                &lt;field-binding field-name="a" identifier="a4" /&gt;
                &lt;field-constraint field-name="a"&gt;
                    &lt;literal-restriction evaluator="!=" value="4" /&gt;
                    &lt;literal-restriction evaluator="!=" value="5" /&gt;
                &lt;/field-constraint&gt;
            &lt;/pattern&gt;
        &lt;/or-conditional-element&gt;

        &lt;pattern identifier="foo5" object-type="Bar" &gt;
            &lt;field-constraint field-name="b"&gt;
                &lt;or-restriction-connective&gt;
                    &lt;return-value-restriction evaluator="==" &gt;a4 + 1&lt;/return-value-restriction&gt;
                    &lt;variable-restriction evaluator="&gt;" identifier="a4" /&gt;
                    &lt;qualified-identifier-restriction evaluator="=="&gt;
                        org.drools.Bar.BAR_ENUM_VALUE
                    &lt;/qualified-identifier-restriction&gt;
                &lt;/or-restriction-connective&gt;
            &lt;/field-constraint&gt;            
        &lt;/pattern&gt;

        &lt;pattern identifier="foo6" object-type="Bar" &gt;
            &lt;field-binding field-name="a" identifier="a4" /&gt;
            &lt;field-constraint field-name="b"&gt;
                &lt;literal-restriction evaluator="==" value="6" /&gt;
            &lt;/field-constraint&gt;
        &lt;/pattern&gt;
  &lt;/lhs&gt;
 &lt;rhs&gt;
    if ( a == b ) {
      assert( foo3 );
    } else {
      retract( foo4 );
    }
    System.out.println( a4 );
   &lt;/rhs&gt;
&lt;/rule&gt;

&lt;/package&gt;
	
</pre></div></div><br class="example-break"><p>Referring to the above example: Notice the key parts, the
    declaration for the Drools 4, schema, imports, globals, functions, and the
    rules. Most of the elements are self explanatory if you have some
    understanding of the Drools 4 features.</p><p>Imports: import the types you wish to use in the rule.</p><p>Globals: These are global objects that can be referred to in the
    rules.</p><p>Functions: this is a declaration of functions to be used in the
    rules. You have to specify return types, a unique name and parameters, in
    the body goes a snippet of code.</p><p>Rule: see below.</p><div class="example"><a name="d0e4654"></a><p class="title"><b>Example&nbsp;6.54.&nbsp;Detail of rule element</b></p><div class="example-contents"><pre class="programlisting">&lt;rule name="simple_rule"&gt;
&lt;rule-attribute name="salience" value="10" /&gt;
&lt;rule-attribute name="no-loop" value="true" /&gt;
&lt;rule-attribute name="agenda-group" value="agenda-group" /&gt;
&lt;rule-attribute name="activation-group" value="activation-group" /&gt;

&lt;lhs&gt;
    &lt;pattern identifier="cheese" object-type="Cheese"&gt;
        &lt;from&gt;
            &lt;accumulate&gt;
                &lt;pattern object-type="Person"&gt;&lt;/pattern&gt;
                &lt;init&gt;
                    int total = 0;
                &lt;/init&gt;
                &lt;action&gt;
                    total += $cheese.getPrice();
                &lt;/action&gt;
                &lt;result&gt;
                    new Integer( total ) );
                &lt;/result&gt;
            &lt;/accumulate&gt;
        &lt;/from&gt;
    &lt;/pattern&gt;

    &lt;pattern identifier="max" object-type="Number"&gt;
        &lt;from&gt;
            &lt;accumulate&gt;
                &lt;pattern identifier="cheese" object-type="Cheese"&gt;&lt;/pattern&gt;
                &lt;external-function evaluator="max" expression="$price"/&gt;
            &lt;/accumulate&gt;
        &lt;/from&gt;
    &lt;/pattern&gt;
&lt;/lhs&gt;
&lt;rhs&gt;
    list1.add( $cheese );
&lt;/rhs&gt;
&lt;/rule&gt;
	</pre></div></div><br class="example-break"><p>Referring to the above rule detail:</p><p>The rule has a LHS and RHS (conditions and consequence) sections.
    The RHS is simple, it is just a block of semantic code that will be
    executed when the rule is activated. The LHS is slightly more complicated,
    certainly more so then past versions.</p><p>A key element of the LHS is the Pattern element. This allows you to
    specify a type (class) and perhaps bind a variable to an instance of that
    class. Nested under the pattern object are constraints and conditional
	elements that have to be met. The Predicate and Return Value constraints 
	allow java expressions to be embedded.</p><p>That leaves the conditional elements, not, exists, and, or etc. They
    work like their DRL counterparts. Elements that are nested under and an
    "and" element are logically "anded" together. Likewise with "or" (and you
    can nest things further). "Exists" and "Not" work around Patterns, to check
    for the existence or non existence of a fact meeting its
    constraints.</p><p>The Eval element allows the execution of a valid snippet of java
    code - as long as it evaluates to a boolean (do not end it with a
    semi-colon, as it is just a fragment) - this can include calling a
    function. The Eval is less efficient then then columns, as the rule engine
    has to evaluate it each time, but it is a "catch all" feature for when you
    can express what you need to do with Column constraints.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4670"></a>6.9.3.&nbsp;Legacy Drools 2.x XML rule format</h3></div></div></div><p>The Drools 2.x legacy XML format is no longer supported by Drools XML parser</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4675"></a>6.9.4.&nbsp;Automatic transforming between formats (XML and DRL)</h3></div></div></div><p>Drools comes with some utility classes to transform between formats.
    This works by parsing the rules from the source format into the AST, and
    then "dumping" out to the appropriate target format. This allows you, for
    example, to write rules in DRL, and when needed, export to XML if
    necessary at some point in the future.</p><p>The classes to look at if you need to do this are: </p><pre class="programlisting">XmlDumper - for exporting XML.
DrlDumper - for exporting DRL.
DrlParser - reading DRL.
XmlPackageReader - reading XML.
</pre><p> Using combinations of the above, you can convert between any
    format (including round trip). Note that DSLs will not be preserved (from
    DRLs that are using a DSL) - but they will be able to be converted.</p></div><p>Feel free to make use of XSLT to provide all sorts of possibilities
  for XML, XSLT and its ilk are what make XML powerful.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e4688"></a>Chapter&nbsp;7.&nbsp;Deployment and Testing</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4691"></a>7.1.&nbsp;Deployment options</h2></div></div></div><p>Once you have rules integrated in your application (or ideally before)
  you will need to plan how to deploy rules along with your application.
  Typically rules are used to allow changes to application business logic
  without re-deploying the whole application. This means that the rules must
  be provided to the application as data, not as part of the application (eg
  embedded in the classpath).</p><p>The recommended way of deploying depends on how you are managing your
  rules. If you are using the BRMS, you should use the RuleAgent (the detailed
  documentation for this is in the chapter on the BRMS). You can still use the
  RuleAgent even without the BRMS, in which case you will need to use ant (the drools-ant task or
  something custom) to create serialized "Package" objects of your rules.</p><p>As every organization is subtly different, and different deployment
  patterns will be needed. Many organizations have (or should have)
  configuration management processes for changes to production systems. It is
  best to think of rules as "data" rather then software in that regard.
  However, as rules can contain a considerable amount of powerful logic,
  proper procedures should be used in testing and verifying rule changes, and
  approving changes before exposing them to the world. If you need to "roll
  your own" deployment, or have specific deployment needs, the information is
  provided in this chapter for your reference, but for the most part, people
  should be able to deploy either as the agent, or in the classpath.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4700"></a>7.1.1.&nbsp;Deployment using the RuleAgent</h3></div></div></div><p>The easiest and most automated way to deploy rules is to use the
    RuleAgent. This is described in detail in the BRMS user guide. In short,
    the rule agent requires that you build binary packages of rules outside of
    "your" application (ie the application that is using rules).</p><p>The upside of this is that your application only needs to include
    drools-core.jar - no other dependencies (of course you need the classes
    that form the model that the rules use as well !). It also means the agent
    can be configured to automatically monitor for rule changes - directly to
    the BRMS, or from a file/directory.</p><p>To use the rule agent in your application use the following
    code:</p><pre class="programlisting">RuleAgent agent = RuleAgent.newRuleAgent("/MyRules.properties");     
RuleBase rb = agent.getRuleBase(); 
rb.newStatefulSession.... 
//now assert your facts into the session and away you go !
</pre><p>The MyRules.properties is a configuration file which (in the above
    case) should be on the root of your classpath:</p><pre class="programlisting">##
## RuleAgent configuration file example
##



dir=/my/dir
url=http://some.url/here http://some.url/here
localCacheDir=/foo/bar/cache
poll=30


name=MyConfig</pre><p>In the above config, the agent will look for binary package files in
    /my/dir, and also at the specified URLs. It will pick up any changes for
    these packages and apply them to the rulebase.</p><p>If you are using the BRMS, you can use the url feature. You can use
    "file" or "dir" if the packages need to be manually migrated to your
    production servers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4719"></a>7.1.2.&nbsp;Deployment using drl source</h3></div></div></div><p>In some cases people may wish to deploy drl source. In that case all
    the drools-compiler dependencies will need to be on the classpath for your
    application. You can then load drl from file, classpath, or a database
    (for example) and compile as needed. The trick, as always, is knowing when
    rules change (this is also called "in process" deployment as described
    below).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4724"></a>7.1.3.&nbsp;Deploying rules in your classpath</h3></div></div></div><p>If you have rules which do not change separate to your application,
    you can put packaged into your classpath. This can be done either as
    source (in which case the drl can be compiled, and the rulebase cached the
    first time it is needed) or else you can pre-compile packages, and just
    include the binary packages in the classpath.</p><p>Keep in mind with this approach to make a rule change, you will both
    need to deploy your app (and if its a server - restart the
    application).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4731"></a>7.1.4.&nbsp;Deployable objects, RuleBase, Package etc.</h3></div></div></div><p>In the simplest possible scenario, you would compile and construct a
    rulebase inside your application (from drl source), and then cache that
    rulebase. That rulebase can be shared across threads, spawning new working
    memories to process transactions (working memories are then discarded).
    This is essentially the stateless mode. To update the rulebase, a new
    rulebase is loaded, and then swapped out with the cached rulebase (any
    existing threads that happen to be using the old rulebase will continue to
    use it until they are finished, in which case it will eventually be
    garbage collected).</p><p>There are many more sophisticated approaches to the above - Drools
    rule engine is very dynamic, meaning pretty much all the components can be
    swapped out on the fly (rules, packages) even when there are *existing*
    working memories in use. For instance rules can be retracted from a
    rulebase which has many in-use working memories - the RETE network will
    then be adjusted to remove that rule without having to assert all the
    facts again. Long running working memories are useful for complex
    applications where the rule engine builds up knowledge over time to assist
    with decision making for instance - it is in these cases that the
    dynamic-ness of the engine can really shine.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4738"></a>7.1.4.1.&nbsp;DRL and PackageDescr</h4></div></div></div><p>One option is to deploy the rules in source form. This leaves the
      runtime engine (which must include the compiler components) to compile
      the rules, and build the rule base. A similar approach is to deploy the
      "PackageDescr" object, which means that the rules are pre-parsed (for
      syntactic errors) but not compiled into the binary form. Use the
      PackageBuilder class to achieve this. You can of course use the XML form
      for the rules if needed.</p><pre class="programlisting">PackageDescr, PackageBuilder, RuleBaseLoader</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4745"></a>7.1.4.2.&nbsp;Package</h4></div></div></div><p>This option is the most flexible. In this case, Packages are built
      from DRL source using PackageBuilder - but it is the binary Package
      objects that are actually deployed. Packages can be merged together.
      That means a package containing perhaps a single new rule, or a change
      to an existing rule, can be built on its own, and then merged in with an
      existing package in an existing RuleBase. The rulebase can then notify
      existing working memories that a new rule exists (as the RuleBase keeps
      "weak" links back to the Working Memory instances that it spawned). The
      rulebase keeps a list of Packages, and to merge into a package, you will
      need to know which package you need to merge into (as obviously, only
      rules from the same package name can be merged together).</p><p>Package objects themselves are serializable, hence they can be
      sent over a network, or bound to JNDI, Session etc.</p><pre class="programlisting">PackageBuilder, RuleBase, org.drools.rule.Package</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4754"></a>7.1.4.3.&nbsp;RuleBase</h4></div></div></div><p>Compiled Packages are added to rulebases. RuleBases are
      serializable, so they can be a binary deployment unit themselves. This
      can be a useful option for when rulebases are updated as a whole - for
      short lived working memories. If existing working memories need to have
      rules changed on the fly, then it is best to deploy Package objects.
      Also beware that rulebases take more processing effort to serialize (may
      be an issue for some large rulebases).</p><pre class="programlisting">RuleBase, RuleBaseLoader</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4761"></a>7.1.4.4.&nbsp;Serializing</h4></div></div></div><p>Practically all of the rulebase related objects in Drools are
      serializable. For a working memory to be serializable, all of your
      objects must of course be serializable. So it is always possible to
      deploy remotely, and "bind" rule assets to JNDI as a means of using them
      in a container environment.</p></div><p>Please note that when using package builder, you may want to check
    the hasError() flag before continuing deploying your rules (if there are
    errors, you can get them from the package builder - rather then letting it
    fail later on when you try to deploy).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4768"></a>7.1.5.&nbsp;Deployment patterns</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4771"></a>7.1.5.1.&nbsp;In process rule building</h4></div></div></div><p>In this case, rules are provided to the runtime system in source
      form. The runtime system contains the drools-compiler component to build
      the rules. This is the simplest approach.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4776"></a>7.1.5.2.&nbsp;Out of process rule building</h4></div></div></div><p>In this case, rules are build into their binary process outside of
      the runtime system (for example in a deployment server). The chief
      advantage of deploying from an outside process is that the runtime
      system can have minimal dependencies (just one jar). It also means that
      any errors to do with compiling are well contained and and known before
      deployment to the running system is attempted.</p><p>Use the PackageBuilder class out of process, and then use
      getPackage() to get the Package object. You can then (for example)
      serialize the Package object to a file (using standard java
      serialization). The runtime system, which only needs drools-core, can
      then load the file using
      RuleBaseFactory.newRuleBase().addPackage(deserialized package
      object).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4783"></a>7.1.5.3.&nbsp;Some deployment scenarios</h4></div></div></div><p>This section contains some suggested deployment scenarios, of
      course you can use a variety of technologies as alternatives to the ones
      in the diagram.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e4788"></a>7.1.5.3.1.&nbsp;Pull style</h5></div></div></div><p>This pattern is what is used by the RuleAgent, by
        default.</p><p>In this scenario, rules are pulled from the rule repository into
        the runtime system. The repository can be as simple as a file system,
        or a database. The trigger to pull the rules could be a timed task (to
        check for changes) or a request to the runtime system (perhaps via a
        JMX interface). This is possibly the more common scenario.</p></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Deployment/DeploymentPatterns1.png"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e4799"></a>7.1.5.3.2.&nbsp;Push style</h5></div></div></div><p>In this scenario, the rule deployment process/repository
        "pushes" rules into the runtime system (either in source or binary
        form, as described above). This gives more control as to when the new
        rules take effect.</p></div><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Deployment/DeploymentPatterns2.png"></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4808"></a>7.1.6.&nbsp;Web Services</h3></div></div></div><p>A possible deployment pattern for rules are to expose the rules as a
    web service. There a many ways to achieve this, but possibly the simplest
    way at present do achieve it is to use an interface-first process: Define
    the "facts" classes/templates that the rules will use in terms of XML
    Schema - and then use binding technologies to generate binding objects for
    the rules to actually operate against. A reverse possibility is to use a
    XSD/WSDL generator to generate XML bindings for classes that are hand
    built (which the rules work against). It is expected in a future version
    there will be an automated tool to expose rules as web services (and
    possibly use XSDs as facts for the rules to operate on).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4813"></a>7.1.7.&nbsp;Future considerations</h3></div></div></div><p>A future release of Drools will contain a rule repository (server)
    component that will directly support the above patterns, and more.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4818"></a>7.2.&nbsp;Testing</h2></div></div></div><p>In recent years, practices such as Test Driven Development have become
  increasingly mainstream, as the value and quality that these techniques
  bring to software development has been realized. In a sense, rules are code
  (although at a high level), and a lot of the same principles apply.</p><p>You can provide tests as a means to specify rule behavior before
  rules are even written. Further to this, tests are even more important in
  environments where rules change frequently. Tests can provide a baseline of
  confidence that the rule changes are consistent with what is specified in
  the tests. Of course, the rules may change in such a way as the tests are
  now wrong (or perhaps new tests need to be written to cover the new rule
  behavior). As in TDD practices, tests should be run often, and in a rule
  driven environment, this means that they should be run every time the rules
  change (even though the software may be static).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4825"></a>7.2.1.&nbsp;Testing frameworks</h3></div></div></div><p>For developers, clearly JUnit (or TestNG) are popular tools for
    testing code, and these can also apply to rules. Keep in mind that rule
    changes may happen out of sync with code changes, so you should be
    prepared to keep these unit tests up to date with rules (may not be
    possible in all environments). Also, the best idea is to target testing
    some core features of the rule sets that are not as likely to change over
    time.</p><p>Obviously, for rule tests, other non source code driven frameworks
    would be preferable to test rules in some environments. The following
    section outlines a rule testing component add on.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4832"></a>7.2.2.&nbsp;FIT for Rules - a rule testing framework</h3></div></div></div><p>As a separate add-on, there is a testing framework available that is
    built on FIT (Framework for Integrated Testing). This allows rule test
    suites (functional) to be capture in Word documents, or Excel spreadsheets
    (in fact any tool that can save as HTML). It utilizes a tabular layout to
    capture input data, and make assertions over the rules of a rulesets
    execution for the given facts. As the tests are stored in documents, the
    scenarios and requirements can be (optionally) kept in the same
    documents, providing a single point of truth for rule behavior.</p><p>Also, as the test documents are not code, they can be updated
    frequently, and kept with the rules, used to validate rule changes etc. As
    the input format is fairly simple to people familiar with the domain of
    the rules, it also facilitates "scenario testing" where different
    scenarios can be tried out with the rules - all external to the
    application that the rules are used in. These scenarios can then be kept
    as tests to increase confidence that a rule change is consistent with the
    users understanding.</p><p>This testing framework is built on FIT and JSR-94, and is kept as a
    separate project to JBoss Rules. Due to it being built on FIT, it requires
    a different license (but is still open source). You can download and read
    more about this tool from this web page: <a class="ulink" href="http://fit-for-rules.sourceforge.net/" target="_top">
        <em class="citetitle">Fit for rules</em>
      </a> http://fit-for-rules.sourceforge.net/</p><p>The following screen captures show the fit for rules framework in
    action.</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Deployment/Testing1.png"></div></div><p>Using Fit for rules, you capture test data, pass it to the rule
    engine and then verify the results (with documentation woven in with the
    test). It is expected that in future, the Drools Server tools will provide
    a similar integrated framework for testing (green means good ! red means a
    failure - with the expected values placed in the cell). Refer to
    http://fit.c2.com for more information on the FIT framework itself.</p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Deployment/Testing2.png"></div></div><p>More information and downloads from <a class="ulink" href="http://fit-for-rules.sourceforge.net/" target="_top">
        <em class="citetitle">Here</em>
      </a></p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e4866"></a>Chapter&nbsp;8.&nbsp;The Java Rule Engine API</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4869"></a>8.1.&nbsp;Introduction</h2></div></div></div><p>Drools provides an implementation of the Java Rule Engine API (known
  as JSR94), which allows for support of multiple rule engines from a single
  API. JSR94 does not deal in anyway with the rule language itself. W3C is
  working on the <a class="ulink" href="http://www.w3.org/TR/2006/WD-rif-ucr-20060323/" target="_top">Rule Interchange Format
  (RIF)</a> and the OMG has started to work on a standard based on <a class="ulink" href="http://ruleml.org/" target="_top">RuleML</a>, recently Haley Systems has also
  proposed a rule language standard called RML.</p><p>It should be remembered that the JSR94 standard represents the "least
  common denominator" in features across rule engines - this means there is
  less functionality in the JSR94 api than in the standard Drools api. So by
  using JSR94 you are restricting yourself in taking advantage of using the
  full capabilities of the Drools Rule Engine. It is necessary to expose
  further functionality, like globals and support for drl, dsl and xml via
  properties maps due to the very basic feature set of JSR94 - this introduces
  non portable functionality. Further to this, as JSR94 does not provide a
  rule language, you are only solving a small fraction of the complexity of
  switching rule engines with very little gain. So while we support JSR94, for
  those that insist on using it, we strongly recommend you program against the
  Drools API.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4884"></a>8.2.&nbsp;How To Use</h2></div></div></div><p>There are two parts to working with JSR94. The first part is the
  administrative api that deals with building and register RuleExecutionSets,
  the second part is runtime session execution of those
  RuleExecutionSets.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4889"></a>8.2.1.&nbsp;Building and Registering RuleExecutionSets</h3></div></div></div><p>The RuleServiceProviderManager manages the registration and
    retrieval of RuleServiceProviders. The Drools RuleServiceProvider
    implementation is automatically registered via a static block when the
    class is loaded using Class.forName; in much the same way as JDBC
    drivers.</p><div class="example"><a name="d0e4895"></a><p class="title"><b>Example&nbsp;8.1.&nbsp;Automatic RuleServiceProvider Registration</b></p><div class="example-contents"><pre class="programlisting">// RuleServiceProviderImpl is registered to "http://drools.org/" via a static initialization block
Class.forName("org.drools.jsr94.rules.RuleServiceProviderImpl");

// Get the rule service provider from the provider manager.
RuleServiceProvider ruleServiceProvider = RuleServiceProviderManager.getRuleServiceProvider("http://drools.org/");</pre></div></div><p><br class="example-break">The RuleServiceProvider provides access to the RuleRuntime and
    RuleAdministration APIs. The RuleAdministration provides an administration
    API for the management of RuleExecutionSets, making it possible to
    register a RuleExecutionSet that can then be retrieved via the
    RuleRuntime.</p><p>First you need to create a RuleExecutionSet before it can be
    registered; RuleAdministrator provides factory methods to return an empty
    LocalRuleExecutionSetProvider or RuleExecutionSetProvider. The
    LocalRuleExecutionSetProvider should be used to load a RuleExecutionSets
    from local sources that are not serializable, like Streams. The
    RuleExecutionSetProvider can be used to load RuleExecutionSets from
    serializable sources, like DOM Elements or Packages. Both the
    "ruleAdministrator.getLocalRuleExecutionSetProvider( null );" and the
    "ruleAdministrator.getRuleExecutionSetProvider( null );" take null as a
    parameter, as the properties map for these methods is not currently
    used.</p><div class="example"><a name="d0e4903"></a><p class="title"><b>Example&nbsp;8.2.&nbsp;Registering a LocalRuleExecutionSet with the RuleAdministration
      API</b></p><div class="example-contents"><pre class="programlisting">// Get the RuleAdministration 
RuleAdministration ruleAdministrator = ruleServiceProvider.getRuleAdministrator();
LocalRuleExecutionSetProvider ruleExecutionSetProvider = ruleAdministrator.getLocalRuleExecutionSetProvider( null );

// Create a Reader for the drl
URL drlUrl = new URL("http://mydomain.org/sources/myrules.drl");
Reader drlReader = new InputStreamReader(  drlUrl.openStream()  );

// Create the RuleExecutionSet for the drl
RuleExecutionSet ruleExecutionSet = ruleExecutionSetProvider.createRuleExecutionSet( drlReader, null );
</pre></div></div><br class="example-break"><p>"ruleExecutionSetProvider.createRuleExecutionSet( reader, null )" in
    the above example takes a null parameter for the properties map; however it
    can actually be used to provide configuration for the incoming source.
    When null is passed the default is used to load the input as a drl.
    Allowed keys for a map are "source" and "dsl". "source" takes "drl" or
    "xml" as its value; set "source" to "drl" to load a drl or to "xml" to
    load an xml source; xml will ignore any "dsl" key/value settings. The
    "dsl" key can take a Reader or a String (the contents of the dsl) as a
    value.</p><div class="example"><a name="d0e4910"></a><p class="title"><b>Example&nbsp;8.3.&nbsp;Specifying a DSL when registering a LocalRuleExecutionSet</b></p><div class="example-contents"><pre class="programlisting">// Get the RuleAdministration 
RuleAdministration ruleAdministrator = ruleServiceProvider.getRuleAdministrator();
LocalRuleExecutionSetProvider ruleExecutionSetProvider = ruleAdministrator.getLocalRuleExecutionSetProvider( null );

// Create a Reader for the drl
URL drlUrl = new URL("http://mydomain.org/sources/myrules.drl");
Reader drlReader = new InputStreamReader(  drlUrl.openStream()  );

// Create a Reader for the dsl and a put in the properties map
URL dslUrl = new URL("http://mydomain.org/sources/myrules.dsl");
Reader dslReader = new InputStreamReader( dslUrl.openStream()  );
Map properties = new HashMap();
properties.put( "source", "drl" );
properties.put( "dsl", dslReader );

// Create the RuleExecutionSet for the drl and dsl
RuleExecutionSet ruleExecutionSet = ruleExecutionSetProvider.createRuleExecutionSet( reader, properties );
</pre></div></div><br class="example-break"><p>When registering a RuleExecutionSet you must specify the name, to be
    used for its retrieval. There is also a field to pass properties, this is
    currently unused so just pass null.</p><div class="example"><a name="d0e4917"></a><p class="title"><b>Example&nbsp;8.4.&nbsp;Register the RuleExecutionSet</b></p><div class="example-contents"><pre class="programlisting">// Register the RuleExecutionSet with the RuleAdministrator
String uri = ruleExectionSet.getName();
ruleAdministrator.registerRuleExecutionSet(uri, ruleExecutionSet, null);</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4922"></a>8.2.2.&nbsp;Using Stateful and Stateless RuleSessions</h3></div></div></div><p>The Runtime, obtained from the RuleServiceProvider, is used to
    create stateful and stateless rule engine sessions.</p><div class="example"><a name="d0e4927"></a><p class="title"><b>Example&nbsp;8.5.&nbsp;Getting the RuleRuntime</b></p><div class="example-contents"><pre class="programlisting">RuleRuntime ruleRuntime = ruleServiceProvider.getRuleRuntime();</pre></div></div><br class="example-break"><p>To create a rule session you must use one of the two RuleRuntime
    public constants - "RuleRuntime.STATEFUL_SESSION_TYPE" and
    "RuleRuntime.STATELESS_SESSION_TYPE" along with the uri to the
    RuleExecutionSet you wish to instantiate a RuleSession for. The properties
    map can be null, or it can be used to specify globals, as shown in the
    next section. The createRuleSession(....) method returns a RuleSession
    instance which must then be cast to StatefulRuleSession or
    StatelessRuleSession.</p><div class="example"><a name="d0e4934"></a><p class="title"><b>Example&nbsp;8.6.&nbsp;Stateful Rule</b></p><div class="example-contents"><pre class="programlisting">(StatefulRuleSession) session = ruleRuntime.createRuleSession( uri,
                                                               null,
                                                               RuleRuntime.STATEFUL_SESSION_TYPE );
session.addObject( new PurchaseOrder( "lots of cheese" ) );
session.executeRules();</pre></div></div><br class="example-break"><p>The StatelessRuleSession has a very simple API; you can only call
    executeRules(List list) passing a list of objects, and an optional filter,
    the resulting objects are then returned.</p><div class="example"><a name="d0e4941"></a><p class="title"><b>Example&nbsp;8.7.&nbsp;Stateless</b></p><div class="example-contents"><pre class="programlisting">(StatelessRuleSession) session = ruleRuntime.createRuleSession( uri,
                                                                null,
                                                                RuleRuntime.STATELESS_SESSION_TYPE );
List list = new ArrayList();
list.add( new PurchaseOrder( "even more cheese" ) );

List results = new ArrayList();
results = session.executeRules( list );</pre></div></div><br class="example-break"><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4946"></a>8.2.2.1.&nbsp;Globals</h4></div></div></div><p>It is possible to support globals with JSR94, in a none portable
      manner, by using the properties map passed to the RuleSession factory
      method. Globals must be defined in the drl or xml file first, otherwise
      an Exception will be thrown. the key represents the identifier declared
      in the drl or xml and the value is the instance you wish to be used in
      the execution. In the following example the results are collected in an
      java.util.List which is used as global:</p><pre class="programlisting">java.util.List globalList = new java.util.ArrayList( );
java.util.Map map = new java.util.HashMap( );
map.put( "list", globalList ); 
//Open a stateless Session StatelessRuleSession srs = (StatelessRuleSession) runtime.createRuleSession( "SistersRules", map, RuleRuntime.STATELESS_SESSION_TYPE );
...
// Persons added to List
// call executeRules( ) giving a List of Objects as parameter
// There are rules which will put Objects in the List
// fetch the list from the map
List list = (java.util.List) map.get("list");</pre><p>Do not forget to declare the global "list" in your DRL:</p><pre class="programlisting">package SistersRules; 
import org.drools.jsr94.rules.Person; 
global java.util.List list
rule FindSisters 
when 
$person1 : Person ( $name1:name ) 
$person2 : Person ( $name2:name ) 
eval( $person1.hasSister($person2) ) 
then 
list.add($person1.getName() + " and " + $person2.getName() +" are sisters"); 
assert( $person1.getName() + " and " + $person2.getName() +" are sisters"); 
end</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4957"></a>8.3.&nbsp;References</h2></div></div></div><p>If you need more information on JSR 94, please refer to the following
  references </p><div class="orderedlist"><ol type="1"><li><p>Official JCP Specification for Java Rule Engine API (JSR
        94)</p><div class="itemizedlist"><ul type="disc"><li><p><a class="ulink" href="http://www.jcp.org/en/jsr/detail?id=94" target="_top">http://www.jcp.org/en/jsr/detail?id=94</a></p></li></ul></div></li><li><p>The Java Rule Engine API documentation</p><div class="itemizedlist"><ul type="disc"><li><p><a class="ulink" href="http://www.javarules.org/api_doc/api/index.html" target="_top">http://www.javarules.org/api_doc/api/index.html</a></p></li></ul></div></li><li><p>The Logic From The Bottom Line: An Introduction to The Drools
        Project. By N. Alex Rupp, published on TheServiceSide.com in
        2004</p><div class="itemizedlist"><ul type="disc"><li><p><a class="ulink" href="http://www.theserverside.com/articles/article.tss?l=Drools" target="_top">http://www.theserverside.com/articles/article.tss?l=Drools</a></p></li></ul></div></li><li><p>Getting Started With the Java Rule Engine API (JSR 94): Toward
        Rule-Based Applications. By Dr. Qusay H. Mahmoud, published on Sun
        Developer Network in 2005</p><div class="itemizedlist"><ul type="disc"><li><p><a class="ulink" href="http://java.sun.com/developer/technicalArticles/J2SE/JavaRule.html" target="_top">http://java.sun.com/developer/technicalArticles/J2SE/JavaRule.html</a></p></li></ul></div></li><li><p>Jess and the javax.rules API. By Ernest Friedman-Hill, published
        on TheServerSide.com in 2003</p><div class="itemizedlist"><ul type="disc"><li><p><a class="ulink" href="http://www.theserverside.com/articles/article.tss?l=Jess" target="_top">http://www.theserverside.com/articles/article.tss?l=Jess</a></p></li></ul></div></li></ol></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e5003"></a>Chapter&nbsp;9.&nbsp;The BRMS (Business Rule Management System)</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5006"></a>9.1.&nbsp;Introduction</h2></div></div></div><p>This section introduces the BRMS. See the other relevant sections for
  installation, usage and administration.</p><div class="figure"><a name="d0e5011"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/Intro1.png" align="middle" alt="The BRMS in action"></div></div><p class="title"><b>Figure&nbsp;9.1.&nbsp;The BRMS in action</b></p></div><br class="figure-break"><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5017"></a>9.1.1.&nbsp;What is a BRMS?</h3></div></div></div><p>BRMS stands for Business Rules Management System.</p><p>This is the component of JBoss Rules which covers rule management,
    storage, editing and deployment. A Web based user interface is provided so
    this tool can be used by people who don't work in IDEs or text editors,
    but it is intended for a wide audience.</p><p>A BRMS allows people to manage rules in a multi user environment, it
    is a single point of truth for your business rules, allowing change in a
    controlled fashion, with user friendly interfaces.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5026"></a>9.1.1.1.&nbsp;When to use a BRMS</h4></div></div></div><p>You should consider a BRMS if any of the following apply to you:
      You need to manage versions/deployment of rules, you need to let
      multiple users of different skill levels access and edit rules, you
      don't have any existing infrastructure to manage rules, you have lots of
      "business" rules (as opposed to technical rules as part of an
      application). </p><p>A BRMS can be used on its own, or with the IDE tooling (often both
      together). </p><p>A BRMS can be "branded" and made part of your application, or it
      can be a central rule repository.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e5035"></a>9.1.1.1.1.&nbsp;When to not use a BRMS</h5></div></div></div><p>In some situations applications may exist which have
        the rules in a database (for instance as part of an existing application), 
        and no new application is needed to manage the rules. </p><p>Otherwise, perhaps an existing rule management system and user interface
        already exists (and is tailored to your environment already) - in this
        case migrating to the BRMS may not be necessary.</p><p>If you are using rules to solve complex algorithmic problems,
        and the rules are essentially an integral part of the application (and
        don't need to be managed separately to the code).</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5044"></a>9.1.1.2.&nbsp;Who uses a BRMS</h4></div></div></div><p>The main roles of people who would use a BRMS are: Business
      Analyst, Rule expert, Developer, Administrators (rule administrators etc).
      </p><p>The BRMS is designed in such a way as these different roles can be
      accommodated, it can be controlled how much is exposed to different users in a safe fashion.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5051"></a>9.1.2.&nbsp;Features outline</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Multiple types of rule editors (GUI, text)</p></li><li><p>Version control (historical assets)</p></li><li><p>Categorization</p></li><li><p>Build and deploy</p></li><li><p>Store multiple rule "assets" together as a package</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5070"></a>9.2.&nbsp;Administration guide</h2></div></div></div><p>This chapter covers installation and administration issues of the
  BRMS.</p><p>The BRMS is a web application that can run in multiple environments,
  and be configured to suit most situations. There is also some initial setup
  of data, and export/import functions covered.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5077"></a>9.2.1.&nbsp;Installation</h3></div></div></div><p>Installation for most people is very simple. The BRMS application is
    deployed as a .war file, which can be deployed in application servers or
    servlet containers with little or no configuration if you are happy with
    the defaults.</p><p>When you have downloaded the BRMS distribution (which you can get
    from http://labs.jboss.com/jbossrules/downloads), you will find the
    drools-jbrms.war file in the zip file. Copy the WAR file into the
    deployment directory of you app server, and then start your app server. If
    you need to customize some settings, you can first "explode" (unzip) the
    war file, and change any configuration settings, and then either zip it
    up, or deploy it "exploded".</p><p>Once the drools-jbrms.war has been placed in the deployment
    directory, and the application server started, you should navigate to
    http://localhost/drools-jbrms and check that the BRMS appears. (Obviously
    substitute the URL for what your application server is configured
    to).</p><p>Once that shows up, you are deployed and ready to go !</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5088"></a>9.2.1.1.&nbsp;Supported and recommended platforms</h4></div></div></div><p>The BRMS is capable of running in any application server that
      supports Java SE5 (JEE 5 is not required) - this includes servlet
      containers like tomcat.</p><p>It is actively tested on JBoss platforms, and these are
      recommended if you are able to use them, or don't have any existing
      infrastructure. However, it is possible to use any container/app server,
      in some cases with minor configuration tweaks (consult the wiki for
      specific tips).</p><p>The following are a list of recommended platforms (all freely
      available), in all cases, you can substitute newer versions of the same
      and it should work (as time may have passed since this was
      written):</p><div class="itemizedlist"><ul type="disc"><li><p>JBoss Application Server 4.0.5</p><p>This is recommended as a general application server solution,
          if you need to run other applications alongside the BRMS.</p></li><li><p>JBoss Web 1.0.1</p><p>This is an ideal solution if you need a "lighter" server to
          run just the BRMS (perhaps stand alone).</p></li></ul></div><p>You can of course download these from www.jboss.com for every
      operating system.</p><p>Deployment into JBoss platforms: If you are installing a new JBoss
      platform, the WAR can be copied to [app server
      directory]/server/default/deploy. You then start up the server by
      running run.sh or run.bat in the [app server directory/bin]
      directory.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5112"></a>9.2.2.&nbsp;Database configuration</h3></div></div></div><p>The BRMS uses the JCR standard for storing assets (such as rules).
    The default implementation is Apache Jackrabbit
    (http://jackrabbit.apache.org/). This includes an out of the box storage
    engine/database, which you can use as is, or configure to use an existing
    RDBMS if needed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5117"></a>9.2.2.1.&nbsp;Changing the location of the data store</h4></div></div></div><p>When you run the BRMS for the first time (starting up the app
      server), it will create a database in the [app server directory]/bin/
      directory (assuming you used on of the JBoss platforms). There is a
      repository.xml file, and a repository directory that are automatically
      created.</p><p>The location of the data store should be a secure location, that
      is backed up. The default location may not be suitable for this, so the
      easiest way is to set a more suitable location. If you want to change
      this, please make sure you have stopped the BRMS (ie stopped the app
      server or undeployed the application).</p><p>To change the location, unzip the WAR file, and locate the
      components.xml file in the WEB-INF directory. This is a JBoss Seam
      configuration file (Seam is the framework used) which allows various
      parts of the system to be customized. When you have located the
      components.xml file, you should see something like the following:</p><pre class="programlisting">&lt;component name="repositoryConfiguration"&gt;
 &lt;!--
  *** This is for configuring the "home" directory for the repository storage. the directory must exist. ***
     &lt;property name="homeDirectory"&gt;/home/michael/RulesRepository_001&lt;/property&gt;
   --&gt;  

   ...
&lt;/component&gt;
</pre><p>Find the component with a name of "repositoryConfiguration" and
      the property with the name of "homeDirectory".</p><p>If you un comment this (as in the example above it is commented
      out), you can set whatever path you need for the repository data to be
      stored in. You can also use this to move the repository around. In that
      case, when you have set the location in the components.xml you can
      simply move the repository.xml AND the repository directory to the new
      location that you set in the components.xml.</p><p>If there is no repository at the location specified (or in the
      default location) then the BRMS will create a new empty one.</p><p>There are many more options which can be configured in the
      repository.xml, but for the most part, it is not recommended to change
      the defaults.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5136"></a>9.2.2.2.&nbsp;Configuring the BRMS to use an external RDBMS</h4></div></div></div><p>In some cases it may be a requirement that you use an external
      RDBMS, such as Oracle, MySQL, or Microsoft SQL Server as the data store
      - this is permitted. In this case, the easiest thing to do is to start
      up the RDBMS with defaults (or with a suitable home directory as
      specified above) to let it generate the default repository.xml
      scaffolding.</p><p>Locate the repository.xml file that was generated, and open it -
      it will be annotated with comments describing many of the different
      options. From here on, you will need to know a little about Jackrabbit
      Persistence managers:
      http://jackrabbit.apache.org/doc/config.html</p><p>There are a few persistence managers, some are database specific
      (eg Oracle). There is a SimpleDBPersistenceManager which works with any
      database that supports JDBC - you also specify the database type, so it
      uses the specific DDL to create the table structure (all major databases
      are supported).</p><p>The BRMS will create the tables the first time it is started up if
      it is running against a fresh (empty) RDBMS - so its important to note
      that the user credentials supplied have permissions to create tables (at
      least initially, on first run, after that they could be locked
      down).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5147"></a>9.2.2.3.&nbsp;Searching and indexing, Version storage</h4></div></div></div><p>Jackrabbit has a separate storage area for version storage (as
      over time, the number of old versions will increase, yet it should not
      slow down the performance of the main data store). The version storage
      also has its own persistence manage configuration in the repository.xml,
      but for most purposes you can use the same database as the main storage
      (just with a different schema object prefix - ie in your database, all
      the version data will be prefixed with "version_" but otherwise in the
      same tablespace). See the repository.xml for more details of
      this.</p><p>Lucene is used to provide indexing across the semi structured
      data, and across versions. This indexing is generally best stored on a
      filesystem, local to the BRMS (as per the default in the repository.xml)
      - in most cases the default is fine.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5154"></a>9.2.3.&nbsp;Security</h3></div></div></div><p>Please note that giving someone access to the BRMS indicates a level of trust.
    Being able to editing and build rules is providing a great deal of power to a user. Thus you should not open up the BRMS to your entire organisation - but instead to a select few. Use https (http with TLS/SSL) whereever possible (even internally in a companies network this is a good idea). Use this power wisely - this not a "run of the mill" application that provides read/write access to a database, but something much more power. Just imagine you are spider man - with great power comes great responsibility (of course even more so for super man).</p><p>Security is configured by using the components.xml file in the war
    file. To customize this, you will need to unzip the war file, and locate
    the components.xml file which is in the WEB-INF directory.</p><p>The JAAS standard is used as the underlying authentication and
    authorization mechanism, the upshot of which means its very flexable and
    able to integrate into most existing environments.</p><p>Out of the box, the BRMS shows a login screen, but no security
    credentials are enforced - the user name is used, but no password check is
    performed. To enforce authentication, you need to configure it to use an
    appropriate user directory (you may have Active Directory or similar
    already).</p><p>In the components.xml file, you should located a security
    configuration section like the following:</p><pre class="programlisting">&lt;!-- SECURITY CONFIGURATION --&gt;
    
&lt;!-- default (will take any username, useful if you want to keep track of users but not authenticate --&gt;
&lt;security:identity authenticate-method="#{defaultAuthenticator.authenticate}"/&gt;

&lt;!-- NO authentication. This will bypass the login screen when you hit the app. Everyone is "guest" --&gt;
&lt;!-- &lt;security:identity authenticate-method="#{nilAuthenticator.authenticate}"/&gt; --&gt;   </pre><p>As you can see from above, the 2 "out of the box" options are pass
    through - which means any user is allowed in, or bypassed, in which case
    there is no login screen (eg you may be securing access to the app via a
    web server anyway).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5171"></a>9.2.3.1.&nbsp;Using your containers security and LDAP</h4></div></div></div><p>Every application server supports advanced configurations which
      can work with your existing security infrastructure. The case of JBoss
      AS will be shown here as an example.</p><pre class="programlisting">&lt;security:identity authenticate-method="#{authenticator.authenticate}" 
                      jaas-config-name="other"/&gt;</pre><p>This will use the "other" jaas config in JBoss AS. If you look in
      [jboss install dir]/server/default/conf you will see a login-config.xml
      file. This file contains various configs. If you use "other" like the
      one above, then it will look for users.properties and roles.properties
      in the conf directory for usernames and passwords to authenticate
      against (this is fine for a fixed small number of users).</p><p>LDAP is perhaps the most popular choice for larger enterprises, so
      following is an example that works with Active Directory. You can get
      much more information on how to configure JBoss AS for all scenarios
      with LDAP from http://wiki.jboss.org/wiki/Wiki.jsp?page=LdapLoginModule
      and http://wiki.jboss.org/wiki/Wiki.jsp?page=LdapExtLoginModule.</p><pre class="programlisting">&lt;application-policy name="brms"&gt;
    &lt;authentication&gt;
        &lt;login-module code="org.jboss.security.auth.spi.LdapExtLoginModule" flag="required" &gt;
            &lt;!--
                Some AD configurations may require searching against
                the Global Catalog on port 3268 instead of the usual
                port 389.  This is most likely when the AD forest
                includes multiple domains.
            --&gt;
            &lt;module-option name="java.naming.provider.url"&gt;ldap://ldap.jboss.org:389&lt;/module-option&gt;
            &lt;module-option name="bindDN"&gt;JBOSS\someadmin&lt;/module-option&gt;
            &lt;module-option name="bindCredential"&gt;password&lt;/module-option&gt;
            &lt;module-option name="baseCtxDN"&gt;cn=Users,dc=jboss,dc=org&lt;/module-option&gt;
            &lt;module-option name="baseFilter"&gt;(sAMAccountName={0})&lt;/module-option&gt;

            &lt;module-option name="rolesCtxDN"&gt;cn=Users,dc=jboss,dc=org&lt;/module-option&gt;
            &lt;module-option name="roleFilter"&gt;(sAMAccountName={0})&lt;/module-option&gt;
            &lt;module-option name="roleAttributeID"&gt;memberOf&lt;/module-option&gt;
            &lt;module-option name="roleAttributeIsDN"&gt;true&lt;/module-option&gt;
            &lt;module-option name="roleNameAttributeID"&gt;cn&lt;/module-option&gt;

            &lt;module-option name="roleRecursion"&gt;-1&lt;/module-option&gt;
            &lt;module-option name="searchScope"&gt;ONELEVEL_SCOPE&lt;/module-option&gt;
        &lt;/login-module&gt;
    &lt;/authentication&gt;
&lt;/application-policy&gt;</pre><p>To use the above, you would put jaas-config-name="brms" in the
      security:identity tag in the components.xml for the BRMS.</p><p>Similar configuration examples can be found for other directory
      services.</p><p>LDAP isn't the final word, you can use JDBC against a database of
      user name, or you can write your own login module to use any sort of
      weird and wonderful authentication and authorization systems that you
      may have to deal with (that would be an extreme case, but its possible).
      Refer to JBoss AS documentation (or documentation for your existing
      application server).</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5190"></a>9.2.4.&nbsp;Data management</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5193"></a>9.2.4.1.&nbsp;Backups</h4></div></div></div><p>How backups are performed is dependent on what persistence manager
      scheme you are using. Using the default one - then its a matter of
      backing up the repository directory (wherever you have it configured to
      be). Restoring it is simply a matter of copying across the repository
      directory.</p><p>Ideally you will either stop the BRMS application while a file
      backup is being done, or ensure that no one is using it.</p><p>In the case of using an external database (eg Oracle, MySQL), then
      the normal scheme can apply that you would use to backup those database
      (you do back them up, right?). In this case, when restoring, it is also
      a good idea to clear the indexes (delete the directory where the indexes
      are) so they are created fresh from the data (and thus guaranteed to be
      in sync).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5202"></a>9.2.4.2.&nbsp;Asset list customization</h4></div></div></div><p>In a few places in the BRMS there is an asset list: this list can
      be customized by looking for the AssetListTable.properties file. You can
      then set the header names and the "getter" methods that are used to
      populate the columns. eg you could add in getCreator, or
      getExternalSource as extra fields if you were using them.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5207"></a>9.2.4.3.&nbsp;Customised selectors for package building</h4></div></div></div><p>When building packages (from the "Packages" feature) you have the option to specify the name of a "selector". This selector will filter the list of rules that are built into the package. What you enter in the selector text box, is the name of a selector as configured on the server.</p><p>
	To configure a selector, you will need to "explode" the war file for the BRMS, and locate the selectors.properties file (note you can also put your own selectors.properties file in the system classpath if you like). 
	In this file, you will find details on how you can configure a custom selector. The options are to use a drl file, or the name of a class that you have written (and which is available on the classpath). Classes must implement the AssetSelector interface. DRL files can also be used (there is an example one in the selectors.properties file). Each selector you configure has a unique name in this properties file - and this is the name that you can use when building packages. 
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5214"></a>9.2.4.4.&nbsp;Adding your own logos or styles to the BRMS web GUI</h4></div></div></div><p>Everyone loves having their own logo on screen - this is to ensure
      that the people using the application don't forget who they work for or
      what product they are using for more then a nanosecond (the consequences
      of them forgetting are too terrible con contemplate).</p><p>To achieve, this, you can "explode" the deployment war file, and
      locate the JBRMS.html file.</p><pre class="programlisting">
&lt;html&gt;
&lt;head&gt;
  &lt;meta name='gwt:module' content='org.drools.brms.JBRMS'&gt;
  &lt;link rel='stylesheet' href='JBRMS.css'&gt;
  &lt;title&gt;JBoss Business Rules Management System&lt;/title&gt;
     &lt;link rel="shortcut icon" href="images/drools.gif" type="image/gif"&gt;
     &lt;link rel="icon" href="images/drools.gif" type="image/gif"&gt;
 &lt;/head&gt;
 &lt;body&gt;
     &lt;div class="headerBarblue"&gt;&lt;img src="images/jbossrules_hdrlogo.png" width="279" height="70" /&gt;&lt;/d
 &lt;!-- This script is the bootstrap stuff that simply must be there; it is sent down uncompressed --&gt; 
  &lt;script language='javascript' src='gwt.js'&gt;&lt;/script&gt;
  &lt;iframe id='__gwt_historyFrame' style='width:0;height:0;border:0'&gt;&lt;/iframe&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><p> The above is the contents of the JBRMS.html
      file - it is fairly empty (as most of the work is done by the GWT - the
      GUI is built dynamically in the browser). The parts you can customise
      are the style sheet - you can either edit the JBRMS.css (or better yet,
      take a copy, and change the style to be what you need), the "shortcut
      icon" (its what shows in the address bar in the browser etc - also
      change the "icon" link to be the same so it works in IE), and the header
      logo. The rest should be left as is, to allow the GWT components to be
      loaded and attached to the page. This html page is loaded only once by
      the browser when the user accesses the BRMS web GUI.</p><p>The best way to customize is to take a copy of the JBRMS.html -
      and then edit. You can also change the URL by editing the web.xml via
      the normal means. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5227"></a>9.2.4.5.&nbsp;Import and Export</h4></div></div></div><p>A JCR standard export/import feature is available from the Admin
      part of the web interface.</p><p>This will export the entire repository to an XML format as defined
      by the JCR standard.</p><p>In the case of import, it will clear any existing content in the
      database.</p><p>This is not a substitute for backup but can be useful when
      migrating. It is important to note that version history is not exported
      this way, only the current state. Hence it is still recommended that a
      formal backup regime be used at all times on the repository database
      itself.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5238"></a>9.3.&nbsp;Architecture</h2></div></div></div><p>This section covers the innards of the BRMS - it is not necessary to
  use this if you are integrating or an end user of the BRMS application.
  However, JBoss Rules is open source, so build instructions form part of the
  manual.</p><p>You may want to build from source if you want to re-use components, or
  embed the application in your own.</p><div class="figure"><a name="d0e5245"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/Architecture.png" align="middle" alt="Architectural diagram"></div></div><p class="title"><b>Figure&nbsp;9.2.&nbsp;Architectural diagram</b></p></div><br class="figure-break"><p>The above diagram shows the major components of the system and how
  they integrate and are deployed. The Admin guide has more details on the
  parts that are highly configurable (eg database).</p><p>The BRMS is deployed as a war, which provides user interfaces over the
  web, and provides binary packages via URLs (or files). It utilized the
  JSR-170 standard for data storage (JCR). JBoss Seam is used as the component
  framework, and GWT is used as the widget toolkit for constructing the ajax
  based web user interface.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5255"></a>9.3.1.&nbsp;Building from source</h3></div></div></div><p>This section will go over the steps you will need to take to build
    various components. Mostly this is automated, but the manual process is
    described for thoroughness.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5260"></a>9.3.1.1.&nbsp;Modules</h4></div></div></div><p>There are 2 modules: drools-repository (back end) and drools-jbrms
      (front end and rules integration). The drools-jbrms module depends on
      the drools-repository module, as well as other components. The BRMS is
      part of the main build for all of Drools - when you build Drools - you
      will also build the BRMS.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5265"></a>9.3.1.2.&nbsp;Working with Maven 2</h4></div></div></div><p>Maven 2 is used as the build system. To get started, you will need
      to check out the WHOLE of the source tree for JBoss Rules. This includes
      the other modules, and the top level lib and repository directories
      (which are needed by the build). As the BRMS build is part of the main
      drools build.</p><p>Initially, you should go into the root of the jboss-rules checked
      out source tree, and run mvn install to install all the components for
      the inter project dependencies. If the build is broken (no ! say it isn't
      so !) you can use the flag -Dmaven.test.skip=true to prevent failing
      unit tests from preventing the build.</p><p>When you want to build the BRMS - you can go into the
      drools-jbrms directory, and run "mvn package" - this will run the tests,
      and then build a deployable war. The only thing this won't do is rebuild
      the GWT front end (see the next section for details on that). Once you
      have the war file (in the target directory) you should be good to go
      !</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5274"></a>9.3.1.3.&nbsp;Working with GWT</h4></div></div></div><p>The GUI widgets for the web front end are developed with GWT
      (google web toolkit). If you need to make changes to or build the GUI,
      you will need to download GWT separately. Once GWT is downloaded, you
      can modify the build.properties file in the drools-jbrms directory to
      point to where you installed GWT. Once you have this, you can use the
      ant tasks to build the GWT components, as well as launch GWT in
      debug/hosted mode should you desire. If you run the build, it will
      update the webapp directory in the project with the new "compiled"
      artifacts (GWT does not use JSP, only html and javascript at
      runtime).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5279"></a>9.3.1.4.&nbsp;Debugging, Editing and running with Eclipse</h4></div></div></div><p>Each module has a ready to go and up to date eclipse project
      configuration, so you can just import them into your eclipse workspace.
      These projects are generated by maven (mvn eclipse:eclipse to refresh
      them in case they are wrong or outdated). They have been manually
      modified to have project dependencies (means you can step through code
      when debugging).</p><p>Some environment variables are required in eclipse
      (Window-&gt;Preferences-&gt;Java-&gt;Build path-&gt;Classpath
      variables): the M2_REPO, as normal, to point to where maven downloads
      shared dependencies. GWT_HOME should point to where you installed GWT.
      GWT_DEV must point to the platform specific "dev" jar that ships with
      the version of GWT you have.</p><p>How you launch from eclipse: you can launch unit tests, as normal
      (in which case you only need M2_REPO setup - you don't even need to
      download GWT seperately) - OR, you can launch it in "hosted mode" using
      the GWT browser, which is great for debugging (from GUI to back end, you
      can step through code, and make changes on the fly and simply hit
      refresh). There is a JBRMS.launch file in in the drools-jbrms directory.
      This should allow Eclipse to launch the JBRMS in debug mode - open the
      Run dialog (Run-&gt;Run), and then choose "JBRMS" from the list.
      Launching this will open a new window, with the BRMS in debug mode,
      ready to go</p><p>Normally</p><p>Downloading and debugging the BRMS with GWT is optional, and if
      you are only working on non GUI issues, you can skip this step.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5292"></a>9.3.2.&nbsp;Re-usable components</h3></div></div></div><p>The BRMS uses a service interface to separate the GUI from the "back
    end" functionality - in this case the back end both includes the asset
    repository (drools-repository and JCR) as well as the compiler specifics
    to deal with rules. </p><p>The main interface is RepositoryService, which is implemented in
    ServiceImplementation. The GWT ajax front end talks to this interface (via
    the asynchrony callback mechanism that GWT uses). The seam configuration file
    is components.xml (consult Seam documentation, and the components.xml file
    for details).</p><p>This service interface may be re-used by alternative components or
    front ends.</p><p>The GWT user interface may be re-used - as it is GWT there is only
    one html page: JBRMS.html. For those familiar with GWT, each of the
    "features" can be used separate (eg in a portal) - look at the
    JBRMSFeature class and the classes that implement it (they can in theory
    be stand alone).</p><p>Normally the BRMS is intended to be deployed as its own war, however
    you could in theory combine it with your own application (with some care)
    - but it is easier to keep it as a separate war, and will make it easier
    to upgrade to newer releases as they come out.</p><p>The JBRMS.html file can be customized - for example to change logos or embed
    the BRMS in another page. Take a look at the JBRMS.html file for details (its 
    very simple).    
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5307"></a>9.3.3.&nbsp;Versioning and Storage</h3></div></div></div><p>The Admin guide goes over configuration options in some detail, for
    database and filesystems.</p><p>Versions of assets are stored in the database along with the data.
    </p><p>When "snapshots" are created, copies are made of the entire package
    into a separate location in the JCR database. </p><p>For those familiar with jcr and jackrabbit, you can look at the
    *.cnd files in the source for the node type definitions. In a nutshell, a
    package is a "folder" and each asset is a file: an asset can either be
    textual or have a binary attachment.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5318"></a>9.3.4.&nbsp;Contributing</h3></div></div></div><p>Consult the wiki and project home-pages if you are interested in
    contributing. A useful way to contribute is via logging issues or feature
    requests in JIRA. However, if you are creating an issue in JIRA for the
    BRMS, it is important that you choose "drools-brms" as the component in
    the list in JIRA (or else it may get lost !)</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5323"></a>9.4.&nbsp;Quick start guide</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5326"></a>9.4.1.&nbsp;Quick start guide</h3></div></div></div><p>If you are reading this, you must be the impatient type who wants to
    kick the tyres (and light the fires) and have a look around as soon as
    possible. This section will provide a quick end to end tour of the steps
    involved (but does not go through the concepts in detail). This assumes
    you have installed the repository correctly, and are able to access the
    main login screen.</p><div class="figure"><a name="d0e5331"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/BRMSFeatures.png" align="middle" alt="Main feature areas of BRMS"></div></div><p class="title"><b>Figure&nbsp;9.3.&nbsp;Main feature areas of BRMS</b></p></div><br class="figure-break"><p>The above picture shows the main feature areas of the BRMS.</p><div class="itemizedlist"><ul type="disc"><li><p>Info: This is the initial screen, with links to
        resources.</p></li><li><p>Rules: This is the category and business user
        perspective.</p></li><li><p>Package: This is where packages are configured and
        managed.</p></li><li><p>Deployment: this is where deployment snapshots are
        managed.</p></li><li><p>Admin: Administrative functions (categories, statuses, import
        and export)</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5355"></a>9.4.1.1.&nbsp;Supported browser platforms</h4></div></div></div><p>The supported server side platforms are mentioned in the
      installation guide. For browsers - the major ones are supported, this
      includes Firefox (1.5 and up), IE6 and up, Opera, Safari etc. The
      preferred browser for most platforms is firefox, it is widely available
      and free, if you have any choice at all, Firefox is the preferred
      platform, followed by safari on mac.</p></div><p>You can also consult the wiki:
    http://wiki.jboss.org/wiki/Wiki.jsp?page=RulesRepository for some
    tutorials and user tips (it IS a wiki, so you can even contribute your own
    tips and examples and even upload files if you desire !).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5362"></a>9.4.1.2.&nbsp;Initial configuration</h4></div></div></div><p>Some initial setup is required the first time. The first time the
      server starts up, it will create an empty repository, then take the
      following steps:</p><div class="itemizedlist"><ul type="disc"><li><p>Once deployed, go to "http://&lt;your
          server&gt;/drools-jbrms/" (This will show the initial info screen -
          or login screen depending on the configuration).</p></li><li><p>If it is a brand new repository, you will want to go to
          "Admin", and choose "Manage Categories"</p><p>(Add a few categories of your choosing, categories are only
          for classification, not for execution or anything else.)</p></li><li><p>Rules need a fact model (object model) to work off, so next
          you will want to go to the Package management feature. From here you
          can click on the icon to create a new package (give it a meaningful
          name, with no spaces).</p></li><li><p>To upload a model, use a jar which has the fact model (API)
          that you will be using in your rules and your code (go and make one
          now if you need to !). When you are in the model editor screen, you
          can upload a jar file, choose the package name from the list that
          you created in the previous step.</p></li><li><p>Now edit your package configuration (you just created) to
          import the fact types you just uploaded (add import statements), and
          save the changes.</p></li><li><p>At this point, the package is configured and ready to go (you
          generally won't have to go through that step very often).</p><p>(Note that you can also import an existing drl package - it
          will store the rules in the repository as individual assets).</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5390"></a>9.4.1.3.&nbsp;Writing some rules</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Once you have at least one category and one package setup, you
          can author rules.</p></li><li><p>There are multiple rule "formats", but from the BRMS point of
          view, they are all "assets".</p></li><li><p>You create a rule by clicking the icon with the rules logo
          (the head), and from that you enter a name.</p></li><li><p>You will also have to choose one category. Categories provide
          a way of viewing rules that is separate to packages (and you can
          make rules appear in multiple packages) - think of it like
          tagging.</p></li><li><p>Chose the "Business rule (guided editor)" formats.</p></li><li><p>This will open a rule modeler, which is a guided editor. You
          can add and edit conditions and actions based on the model that is
          in use in the current package. Also, any DSL sentence templates
          setup for the package will be available.</p></li><li><p>When you are done with rule editing, you can check in the
          changes (save), or you can validate or "view source" (for the
          effective source).</p></li><li><p>You can also add/remove categories from the rule editor, and
          other attributes such as documentation (if you aren't sure what to
          do, write a document in natural language describing the rule, and
          check it in, that can also serve as a template later)</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5418"></a>9.4.1.4.&nbsp;Finding stuff</h4></div></div></div><p>In terms of navigating, you can either use the Rules feature,
      which shows things grouped by categories, or you can use the Package
      feature, and view by package (and rule type). If you know the name or
      part of the name of an asset, you can also use the "Quick find", start
      typing a rule name and it will return a list of matches as you type (so
      if you have a sensible naming scheme, it will make it very quick to find
      stuff).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5423"></a>9.4.1.5.&nbsp;Deployment</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>After you have edited some rules in a package, you can click
          on the package feature, open the package that you wish, and build
          the whole package.</p></li><li><p>If that succeeds, then you will be able to download a binary
          package file which can be deployed into a runtime system.</p></li><li><p>You can also take a "snapshot" of a package for deployment.
          This freezes the package at that point in time, so any concurrent
          changes to not effect the package. It also makes the package
          available on a URL of the form: "http://&lt;your
          server&gt;/drools-jbrms/org.drools.brms.JBRMS/packages/&lt;packageName&gt;/&lt;snapshotName&gt;"
          (where you can use that URL and downloads will be covered in the
          section on deployment).</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5436"></a>9.4.2.&nbsp;BRMS concepts</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5439"></a>9.4.2.1.&nbsp;Rules are assets</h4></div></div></div><p>As the BRMS can manage many different types of rules (and more),
      they are all classed as "assets". An asset is anything that can be
      stored as a version in the repository. This includes decision tables,
      models, DSLs and more. Sometimes the word "rule" will be used to really
      mean "asset" (ie the things you can do also apply to the other asset
      types). You can think of asset as a lot like a file in a folder. Assets
      are grouped together for viewing, or to make a package for deployment
      etc.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5444"></a>9.4.2.2.&nbsp;Categorisation</h4></div></div></div><div class="figure"><a name="d0e5447"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/CatZoom.png" align="middle" alt="Categories"></div></div><p class="title"><b>Figure&nbsp;9.4.&nbsp;Categories</b></p></div><br class="figure-break"><p>Categories allow rules (assets) to be labeled (or tagged) with any
      number of categories that you define. This means that you can then view
      a list of rules that match a specific category. Rules can belong to any
      number of categories. In the above diagram, you can see this can in
      effect create a folder/explorer like view of assets. The names can be
      anything you want, and are defined by the BRMS administrator (you can
      also remove/add new categories - you can only remove them if they are
      not currently in use).</p><p>Generally categories are created with meaningful name that match
      the area of the business the rule applies to (if the rule applies to
      multiple areas, multiple categories can be attached). Categories can
      also be used to "tag" rules as part of their life-cycle, for example to
      mark as "Draft" or "For Review".</p><div class="figure"><a name="d0e5457"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/CatEdit.png" align="middle" alt="Assets can have multiple categories"></div></div><p class="title"><b>Figure&nbsp;9.5.&nbsp;Assets can have multiple categories</b></p></div><br class="figure-break"><p>The view above shows the category editor/viewer that is seen when
      you open an asset. In this example you can see the asset belongs to 2
      categories, with a "+" button to add additional items (use the trash can
      item to remove them). This means that when either category is used to
      show a list of assets, you will see that asset.</p><p>In the above example, the first Category "Finance" is a "top
      level" category. The second one: "HR/Awards/QAS" is a still a single
      category, but its a nested category: Categories are hierarchical. This
      means there is a category called "HR", which contains a category
      "Awards" (it will in fact have more sub-categories of course), and
      "Awards" has a sub-category of QAS. The screen shows this as
      "HR/Awards/QAS" - its very much like a folder structure you would have
      on your hard disk (the notable exception is of course that rules can
      appear in multiple places).</p><p>When you open an asset to view or edit, it will show a list of
      categories that it currently belongs to If you make a change (remove or
      add a category) you will need to save the asset - this will create a new
      item in the version history. Changing the categories of a rule has no
      effect on its execution.</p><div class="figure"><a name="d0e5469"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/AdminCats.png" align="middle" alt="Creating categories"></div></div><p class="title"><b>Figure&nbsp;9.6.&nbsp;Creating categories</b></p></div><br class="figure-break"><p>The above view shows the administration screen for setting up
      categories (there) are no categories in the system by default. As the
      categories can be hierarchical you chose the "parent" category that you
      want to create a sub-category for. From here categories can also be
      removed (but only if they are not in use by any current versions of
      assets).</p><p>As a general rule, an asset should only belong to 1 or 2
      categories at a time. Categories are critical in cases where you have
      large numbers of rules. The hierarchies do not need to be too deep, but
      should be able to see how this can help you break down rules/assets into
      manageable chunks. Its ok if its not clear at first, you are free to
      change categories as you go.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5479"></a>9.4.2.3.&nbsp;The asset editor</h4></div></div></div><div class="figure"><a name="d0e5482"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/AssetEditor.png" align="middle" alt="The Asset editor view"></div></div><p class="title"><b>Figure&nbsp;9.7.&nbsp;The Asset editor view</b></p></div><br class="figure-break"><p>The above diagram shows the "asset editor" with some annotated
      areas. The asset editor is where all rule changes are made. Below is a
      list which describes the different parts of the editor.</p><div class="itemizedlist"><ul type="disc"><li><p>A</p><p>This is where the "editor widget" lives - exactly what form
          the editor takes depends on the asset or rule type.</p></li><li><p>B</p><p>This is the documentation area - a free text area where
          descriptions of the rule can live. It is encouraged to write a plain
          description in the rule here before editing.</p></li><li><p>C</p><p>These are the actions - for saving, archiving, changing status
          etc. Archiving is the equivalent of deleting an asset.</p></li><li><p>D</p><p>This has the asset name, as well as the list of categories
          that the asset belongs to.</p></li><li><p>E</p><p>This section contains read-only meta data, including when
          changes were made, and by whom.</p><p>"Modified on:" - this is the last modified date.</p><p>"By:" - who made the last change.</p><p>"Note:" - this is the comment made when the asset was last
          updated (ie why a change was made)</p><p>"Version:" - this is a number which is incremented by 1 each
          time a change is checked in (saved).</p><p>"Created on:" - the date and time the asset was
          created.</p><p>"Created by:" - this initial author of the asset.</p><p>"Format:" - the short format name of the type of asset.</p></li><li><p>F</p><p>This shows what package the asset belong to (you can also
          change it from here).</p></li><li><p>G</p><p>This is some more (optional) meta data (taken from the Dublin
          Core meta data standard)</p></li><li><p>H</p><p>This will show the version history list when requested.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5545"></a>9.4.2.4.&nbsp;Rule authoring</h4></div></div></div><p>The BRMS supports a (growing) list of formats of assets (rules).
      Here the key ones are described. Some of these are covered in other
      parts of the manual, and the detail will not be repeated here.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e5550"></a>9.4.2.4.1.&nbsp;Business rules with the guided editor</h5></div></div></div><p>Guided editor style "Business rules": (also known as "BRL
        format"). These rules use the guided GUI which controls and propts
        user input based on knowledge of the object model. This can also be
        augmented with DSL sentences.</p><p>IMPORTANT: to use the BRL guided editor, someone will need to
        have you package configured before hand.</p><p>Also note that there is a guided editor in the Eclipse plug in,
        most of the details in this section can also apply to it.</p><div class="figure"><a name="d0e5559"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/GuidedEditor.png" align="middle" alt="The guided BRL editor"></div></div><p class="title"><b>Figure&nbsp;9.8.&nbsp;The guided BRL editor</b></p></div><br class="figure-break"><p>The above diagram shows the editor in action. The following
        description apply to the letter boxes in the diagram above:</p><p>A: The different parts of a rule. The "WHEN" part is the
        condition, "THEN" action, and "(options)" are optional attributes that
        may effect the operation of the rule.</p><p>B: This shows a pattern which is declaring that the rule is
        looking for a "Driver" fact (the fields are listed below, in this case
        just "age"). Note the green triangle, it will popup a list of options
        to add to the fact declaration: you can add more fields (eg their
        "location"), or you can assign a variable name to the fact (which you
        can use later on if needs be). As well as adding more fields to this
        pattern - you can add "multiple field" constraints - ie constraints
        that span across fields (eg age &gt; 42 or risk &gt; 2). The popup
        dialog shows the options.</p><p>C: The small "-" icons indicate you can remove something - in
        this case it would remove the whole Driver fact declaration. If its
        the one below, it would remove just the age constraint.</p><p>D: The "+" symbols allow you to add more patterns to the
        condition or the action part of the rule, or more attributes. In all
        cases, a popup option box is provided. For the "WHEN" part of the
        rule, you can choose to add a constraint on a fact (it will give you a
        list of facts), or you can use another conditional element, the
        choices which are : "There is no" - which means the fact+constraints
        must not exist, "There exists" - which means that there exists at
        least one match (but there only needs to be one - it will not trigger
        for each match), and "Any of" - which means that any of the patterns
        can match (you then add patterns to these higher level patterns). If
        you just put a fact (like is shown above) then all the patterns are
        combined together so they are all true ("and").</p><p>E: This shows the constraint for the "age" field. (Looking from
        left to right) the green triangle allows you to "assign" a variable
        name to the "age" field, which you may use later on in the rule. Next
        is the list of constraint operations - this list changes depending on
        the data type. After that is the value field - the value field will be
        one of: a) a literal value (eg number, text), b) a "formula" - in
        which case it is an expression which is calculated (this is for
        advanced users) or b) a variable (in which case a list will be
        provided to choose values from). After this there is a horizontal
        arrow icon, this is for "connective constraints" : these are
        constraints which allow you to have alternative values to check a
        field against, for example: "age is less than 42 or age is not equal
        to 39" is possibly this way.</p><p>F: This shows an "action" of the rule, a rule consists of a list
        of actions. In this case, we are asserting/inserting a new fact, which
        is a rejection (with the "reason" field set to an explanation). There
        are quite a few other types of actions you can use: you can modify an
        existing fact (which tells the engine the fact has changed) - or you
        can simply set a field on a fact (in which case the engine doesn't
        know about the change - normally because you are setting a result).
        You can also retract a fact. In most cases the green arrow will give
        you a list of fields you can add so you can change the value. The
        values you enter are "literal" - in the sense that what you type is
        what the value is. If it needs to be a calculation, then add an "=" at
        the start of the value - this will be interpreted as a "formula" (for
        advanced users only) ! and the calculation will be performed (not
        unlike a spreadsheet).</p><p>G: This is where the rule options live. In this case, only
        salience is used which is a numeric value representing the rules
        "priority". This would probably be the most common option to
        use.</p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="d0e5581"></a>9.4.2.4.1.1.&nbsp;User driven drop down lists</h6></div></div></div><div class="figure"><a name="d0e5584"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/EnumDropDown.png" align="middle" alt="Data enumeration showing as a drop down list"></div></div><p class="title"><b>Figure&nbsp;9.9.&nbsp;Data enumeration showing as a drop down list</b></p></div><br class="figure-break"><p>Note that is it possible to limit field values to items in a
          pre configured list. This list is configured as part of the package
          (using a data enumeration to provide values for the drop down list).
          These values can be a fixed list, or (for example) loaded from a
          database. This is useful for codes, and other fields where there are
          set values. It is also possible to have what is displayed on screen,
          in a drop down, be different to the value (or code) used in a rule.
          See the section on data enumerations for how these are
          configured.</p></div><p>Augmenting with DSL sentences: If the package the rule is part
        of has a dsl configuration, when when you add conditions or actions,
        then it will provide a list of "DSL Sentences" which you can choose
        from - when you choose one, it will add a row to the rule - where the
        DSL specifies values come from a user, then a edit box (text) will be
        shown (so it ends up looking a bit like a form). This is optional, and
        there is another DSL editor. Please note that the DSL capabilities in
        this editor are slightly less then the full set of DSL features
        (basically you can do [when] and [then] sections of the DSL only -
        which is no different to drools 3 in effect).</p><p>The following diagram shows the DSL sentences in action in the
        guided editor:</p><div class="figure"><a name="d0e5596"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/GuidedDSL.png" align="middle" alt="DSL in guided editor"></div></div><p class="title"><b>Figure&nbsp;9.10.&nbsp;DSL in guided editor</b></p></div><br class="figure-break"><p>A more complex example:</p><div class="figure"><a name="d0e5604"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/GuidedComplex.png" align="middle" alt="A more complex BRL example"></div></div><p class="title"><b>Figure&nbsp;9.11.&nbsp;A more complex BRL example</b></p></div><br class="figure-break"><p>In the above example, you can see it is using a mixture of
        literal values, and formulas. The second constraint on the "Person"
        fact, is a formula (in this case it is doing a silly calculation on
        the persons age, and checking something against their name - both
        "age" and "name" are fields of the Person fact in this case. In the
        3rd line (which says "age is less than .." - it is also using a
        formula, although, in this case the formula does a calculation and
        returns a value (which is used in the comparison) - in the former
        case, it had to return True or False (in this case, its a value).
        Obvious formulas are basically pieces of code - so this is for
        experienced users only.</p><p>Looking at the "Board" pattern (the second pattern with the
        horizontal grey bar): this uses a top level conditional element
        ("There is no") - this means that the pattern is actually looking for
        the "non existence" of a fact that matches the pattern. Note the "Any
        of:" - this means that EITHER the "type" field constraint is matched,
        or the "name" field is matched (to "myname" in the case above). This
        is what is termed a Multiple field constraint (you can nest these, and
        have it as complex as you like, depending on how much you want the
        next person to hate you: Some paraphrased advice: Write your rules in
        such as way as the person who has to read/maintain them is a
        psychopath, has a gun, and knows where you live).</p><div class="figure"><a name="d0e5614"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/GuidedLHSConstraints.png" align="middle" alt="Adding constraints"></div></div><p class="title"><b>Figure&nbsp;9.12.&nbsp;Adding constraints</b></p></div><br class="figure-break"><p>The above dialog is what you will get when you want to add
        constraints to the Person fact. In the top half are the simple
        options: you can either add a field straight away (a list of fields of
        the Person fact will be shown), or you can add a "Multiple field
        constraint" - of a given type (which is described above). The Advanced
        options: you can add a formula (which resolves to True or False - this
        is like in the example above: "age &lt; (age * 2) ...."). You can also
        assign a Variable name to the Person fact (which means you can then
        access that variable on the action part of the rule, to set a value
        etc).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e5622"></a>9.4.2.4.2.&nbsp;DSL rules</h5></div></div></div><p>DSL rules are textual rules, that use a language configuration
        asset to control how they appear.</p><div class="figure"><a name="d0e5627"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/DSLRule.png" align="middle" alt="DSL rule"></div></div><p class="title"><b>Figure&nbsp;9.13.&nbsp;DSL rule</b></p></div><br class="figure-break"><p>A dsl rule is a single rule. Referring to the picture above, you
        can a text editor. You can use the icons to the right to provide lists
        of conditions and actions to choose from (or else press Control +
        Space at the same time to pop up a list).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e5635"></a>9.4.2.4.3.&nbsp;Spreadsheet decision tables</h5></div></div></div><p>Multiple rules can be stored in a spreadsheet (each row is a
        rule). The details of the spreadsheet are not covered in this chapter
        (as there is a separate chapter for them).</p><div class="figure"><a name="d0e5640"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/DecisionTable.png" align="middle" alt="Spreadsheet decision table"></div></div><p class="title"><b>Figure&nbsp;9.14.&nbsp;Spreadsheet decision table</b></p></div><br class="figure-break"><p>To use a spreadsheet, you upload an xls (and can download the
        current version, as per the picture above). To create a new decision
        table, when you launch the rule wizard, you will get an option to
        create one (after that point, you can upload the xls file).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e5648"></a>9.4.2.4.4.&nbsp;Rule flows</h5></div></div></div><p>Rule flows: Rule flows allow you to visually describe the steps
        taken - so not all rules are evaluated at once, but there is a flow of
        logic. Rule flows are not covered in this chapter on the BRMS, but you
        can use the IDE to graphically draw ruleflows, and upload the .rfm
        file to the BRMS.</p><p>Similar to spreadsheets, you upload/download ruleflow files (the
        eclipse IDE has a graphical editor for them). The details of Rule
        Flows are not discussed here.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e5655"></a>9.4.2.4.5.&nbsp;Technical rules (drl)</h5></div></div></div><p>Technical (drl) rules are stored as text - they can be managed
        in the BRMS. A DRL can either be a whole chunk of rules, or an
        individual rule. if its an individual rule, no package statement or
        imports are required (in fact, you can skip the "rule" statement
        altogether, just use "when" and "then" to mark the condition and
        action sections respectively). Normally you would use the IDE to edit
        raw DRL files, since it has all the advanced tooling and content
        assistance and debugging, however there are times when a rule may have
        to deal with something fairly technical. In any typical package of
        rules, you generally have a been for some "technical rules" - you can
        mix and match all the rule types together of course.</p><div class="figure"><a name="d0e5660"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/DRLRule.png" align="middle" alt="DRL technical rule"></div></div><p class="title"><b>Figure&nbsp;9.15.&nbsp;DRL technical rule</b></p></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e5666"></a>9.4.2.4.6.&nbsp;Functions</h5></div></div></div><p>Functions are another asset type. They are NOT rules, and should
        only be used when necessary. The function editor is a textual editor.
        Functions</p><div class="figure"><a name="d0e5671"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/Function.png" align="middle" alt="Function"></div></div><p class="title"><b>Figure&nbsp;9.16.&nbsp;Function</b></p></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e5677"></a>9.4.2.4.7.&nbsp;Data enumerations (drop down list configurations)</h5></div></div></div><p>Data enumerations are an optional asset type that technical folk
        can configure to provide drop down lists for the guided editor. These
        are stored and edited just like any other asset, and apply to the
        package that they belong to.</p><p>The contents of an enum config are a mapping of Fact.field to a
        list of values to be used in a drop down. That list can either be
        literal, or use a utility class (which you put on the classpath) to
        load a list of strings. The strings are either a value to be shown on
        a drop down, or a mapping from the code value (what ends up used in
        the rule) and a display value (see the example below, using the
        '=').</p><div class="figure"><a name="d0e5684"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/EnumConfig.png" align="middle" alt="Data enumeration"></div></div><p class="title"><b>Figure&nbsp;9.17.&nbsp;Data enumeration</b></p></div><br class="figure-break"></div><p>In the above diagram - the "MM" indicates a value that will be
      used in the rule, yet "Mini Mal" will be displayed in the GUI.</p><p>Getting data lists from external data sources: It is possible to
      have the BRMS call a piece of code which will load a list of Strings. To
      do this, you will need a bit of code that returns a java.util.List (of
      String's) to be on the classpath of the BRMS. Instead of specifying a
      list of values in the BRMS itself - the code can return the list of
      Strings (you can use the "=" inside the strings if you want to use a
      different display value to the rule value, as normal). For example, in
      the 'Person.age' line above, you could change it to: </p><pre class="programlisting">
  'Person.age' : (new com.yourco.DataHelper()).getListOfAges()
</pre><p> This assumes you have a class called "DataHelper" which has
      a method "getListOfAges()" which returns a List of strings (and is on
      the classpath). You can of course mix these "dynamic" enumerations with
      fixed lists. You could for example load from a database using JDBC. The
      data enumerations are loaded the first time you use the guided editor in
      a session. If you have any guided editor sessions open - you will need
      to close and then open the rule to see the change. To check the
      enumeration is loaded - if you go to the Package configuration screen,
      you can "save and validate" the package - this will check it and provide
      any error feedback.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e5697"></a>9.4.2.4.8.&nbsp;Advanced enumaration concepts</h5></div></div></div><p>There are a few other advanced things you can do with data
        enumerations.</p><p>Drop down lists that depend on field values: Lets imagine a
        simple fact model, we have a class called Vehicle, which has 2 fields:
        "engineType" and "fuelType". We want to have a choice for the
        "engineType" of "Petrol" or "Diesel". Now, obviously the choice type
        for fuel must be dependent on the engine type (so for Petrol we have
        ULP and PULP, and for Diesel we have BIO and NORMAL). We can express
        this dependency in an enumeration as:</p><pre class="programlisting">
 'Vehicle.engineType' : ['Petrol', 'Diesel']
 'Vehicle.fuelType[engineType=Petrol]' : ['ULP', 'PULP' ]
 'Vehicle.fuelType[engineType=Diesel]' : ['BIO', 'NORMAL' ]	  
</pre><p>This shows how it is possible to make the choices dependent on
        other field values. Note that once you pick the engineType, the choice
        list for the fuelType will be determined.</p><p>Loading enums programmatically: In some cases, people may want
        to load their enumeration data entirely from external data source
        (such as a relational database). To do this, you can implement a class
        that returns a Map. The key of the map is a string (which is the
        Fact.field name as shown above), and the value is a java.util.List of
        Strings.</p><pre class="programlisting">
public class SampleDataSource2 {

  public Map&lt;String&gt;, List&lt;String&gt;&gt; loadData() {
    Map data = new HashMap();

    List d = new ArrayList();
    d.add("value1");
    d.add("value2");
    data.put("Fact.field", d);

    return data;
 }

}
</pre><p>And in the enumeration in the brms, you put:</p><pre class="programlisting">=(new SampleDataSource2()).loadData()
</pre><p>The "=" tells it to load the data by executing your code.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5718"></a>9.4.2.5.&nbsp;Templates of assets/rules</h4></div></div></div><p>Tip: As you may have many similar rules, you can create rule
      templates, which are simply rules which are kept in an inactive package
      - you can then categories templates accordingly, and copy them as needed
      (choosing a live package as the target package).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5723"></a>9.4.2.6.&nbsp;Status management</h4></div></div></div><p>Each asset (and also package) in the BRMS has a status flag set.
      The values of the status flag are set in the Administration section of
      the BRMS. (you can add your own status names). Similar to Categories,
      Statuses do NOT effect the execution in any way, and are purely
      informational. Unlike categories, assets only have one status AT A
      TIME.</p><p>Using statuses is completely optional. You can use it to manage
      the lifecycle of assets (which you can alternatively do with categories
      if you like).</p><div class="figure"><a name="d0e5730"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/AssetChangeStatus.png" align="middle" alt="Asset status"></div></div><p class="title"><b>Figure&nbsp;9.18.&nbsp;Asset status</b></p></div><br class="figure-break"><p>You can change the status of an individual asset (like in the
      diagram above). Its change takes effect immediately, no separate save is
      needed.</p><div class="figure"><a name="d0e5738"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/PackageChangeStatus.png" align="middle" alt="Asset status"></div></div><p class="title"><b>Figure&nbsp;9.19.&nbsp;Asset status</b></p></div><br class="figure-break"><p>You can change the status of a whole package - this sets the
      status flag on the package itself, but it ALSO changes the statuses on
      ALL the assets that belong to this package in one hit (to be the same as
      what you set the package to).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5746"></a>9.4.2.7.&nbsp;Package management</h4></div></div></div><p>Configuring packages is generally something that is done once, and
      by someone with some experience with rules/models. Generally speaking,
      very few people will need to configure packages, and once they are
      setup, they can be copied over and over if needed. Package configuration
      is most definitely a technical task that requires the appropriate
      expertise.</p><p>All assets live in "packages" in the BRMS - a package is like a
      folder (it also serves as a "namespace"). A home folder for rule assets
      to live in. Rules in particular need to know what the fact model is,
      what the namespace is etc.</p><div class="figure"><a name="d0e5754"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/PackageExplorer.png" align="middle" alt="The package explorer"></div></div><p class="title"><b>Figure&nbsp;9.20.&nbsp;The package explorer</b></p></div><p><br class="figure-break">The above picture shows the package explorer. Clicking on an
      asset type will show a list of matches (for packages with thousands of
      rules, showing the list may take several seconds - hence the importance
      of using categories to help you find your way around).</p><p>So whilst rules (and assets in general) can appear in any number
      of categories, they only live in one package. If you think of the BRMS
      as a file system, then each package is a folder, and the assets live in
      that folder - as one big happy list of files. When you create a
      deployment snapshot of a package, you are effectively copying all the
      assets in that "folder" into another special "folder".</p><p>The package management feature allows you to see a list of
      packages, and then "expand" them, to show lists of each "type" of asset
      (there are many assets, so some of them are grouped together):</p><p>The asset types: </p><div class="itemizedlist"><ul type="disc"><li><p>Business assets: this shows a list of all "business rule"
            types, which include decision tables, business rules etc.
            etc.</p></li><li><p>Technical assets: this is a list of items that would be
            considered technical (eg DRL rules, data enumerations and rule
            flows).</p></li><li><p>Functions: In the BRMS you can also have functions defined
            (optionally of course).</p></li><li><p>DSL: Domain Specific Languages can also be stored as an
            asset. If they exist (generally there is only one), then they will
            be used in the appropriate editor GUIs.</p></li><li><p>Model: A package requires at least one model - for the
            rules.</p></li></ul></div><div class="figure"><a name="d0e5784"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/PackageNewItemTooltip.png" align="middle" alt="Creating new assets"></div></div><p class="title"><b>Figure&nbsp;9.21.&nbsp;Creating new assets</b></p></div><p><br class="figure-break"> From the package explorer you can create new rules, or new
      assets. Some assets you can only create from the package explorer. The
      above picture shows the icons which launch wizards for this purpose. If
      you hover the mouse over them, a tooltip will tell you what they
      do.</p><div class="figure"><a name="d0e5792"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/PackageConfig.png" align="middle" alt="Package configuration"></div></div><p class="title"><b>Figure&nbsp;9.22.&nbsp;Package configuration</b></p></div><p><br class="figure-break">One of the most critical things you need to do is configure
      packages. This is mostly importing the classes used by the rules, and
      globals variables. Once you make a change, you need to save it, and that
      package is then configured and ready to be built. For example, you may
      add a model which has a class called "com.something.Hello", you would
      then add "import com.something.Hello" in your package configuration and
      save the change.</p><div class="figure"><a name="d0e5800"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/PackageBuild.png" align="middle" alt="Package building"></div></div><p class="title"><b>Figure&nbsp;9.23.&nbsp;Package building</b></p></div><p><br class="figure-break">Finally you would "build" a package. Any errors caught are
      then shown at this point. If the build was successful, then you will
      have the option to create a snapshot for deployment. You can also view
      the "drl" that this package results in. WARNING: in cases of large
      numbers of rules, all these operations can take some time.</p><p>It is optional at this stage to enter the name of a "selector" -
      see the admin section for details on how to configure custom selectors
      for your system (if you need them - selecters allow you to filter down
      what you build into a package - if you don't know what they are for, you
      probably don't need to use them).</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e5809"></a>9.4.2.7.1.&nbsp;Importing drl packages</h5></div></div></div><p>It is also possible to create a package by importing an existing
        "drl" file. When you choose to create a new package, you can choose an
        option to upload a .drl file. The BRMS will then attempt to understand
        that drl, break create a package for you. The rules in it will be
        stored as individual assets (but still as drl text content). Note that
        to actually build the package, you will need to upload an appropriate
        model (as a jar) to validate against, as a separate step.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5814"></a>9.4.2.8.&nbsp;Version management</h4></div></div></div><p>Both assets and whole packages of assets are "versioned" in the
      BRMS, but the mechanism is slightly different. Individual assets are
      saved a bit like a version of a file in a source control system.
      However, packages of assets are versioned "on demand" by taking a
      snapshot (typically which is used for deployment). The next section
      talks about deployment management and snapshots.</p><div class="figure"><a name="d0e5819"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/AssetVersionHistory.png" align="middle" alt="Asset versions"></div></div><p class="title"><b>Figure&nbsp;9.24.&nbsp;Asset versions</b></p></div><br class="figure-break"><p>Each time you make a change to an asset, it creates a new item in
      the version history. This is a bit like having an unlimited undo. You
      can look back through the history of an individual asset like the list
      above, and view it (and restore it) from that point in time.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5827"></a>9.4.2.9.&nbsp;Deployment management</h4></div></div></div><p>Snapshots, URLS and binary packages:</p><p>URLs are central to how built packages are provided. The BRMS
      provides packages via URLs (for download and use by the Rule Agent).
      These URLs take the form of:
      http://&lt;server&gt;/drools-jbrms/org.drools.brms.JBRMS/package/&lt;packageName&gt;/&lt;packageVersion&gt;</p><p>&lt;packageName&gt; is the name you gave the package.
      &lt;packageVersion&gt; is either the name of a snapshot, or "LATEST" (if
      its LATEST, then it will be the latest built version from the main
      package, not a snapshot). You can use these in the agent, or you can
      paste them into your browser and it will download them as a file.</p><p>Refer to the section on the Rule Agent for details on how you can
      use these URLs (and binary downloads) in your application, and how rules
      can be updated on the fly.</p><div class="figure"><a name="d0e5838"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/Snapshots.png" align="middle" alt="Deployment snapshots"></div></div><p class="title"><b>Figure&nbsp;9.25.&nbsp;Deployment snapshots</b></p></div><br class="figure-break"><p>The above shows deployment snapshots view. On the left there is a
      list of packages. Clicking on a specific package will show you a list of
      snapshots for that package (if any). From there you can copy, remove or
      view an asset snapshot. Each snapshot is available for download or
      access via a URL for deployment.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5846"></a>9.4.2.10.&nbsp;Navigating and finding rules</h4></div></div></div><p>The two main ways of viewing the repository are by using
      user-driven Categorization (tagging) as outlined above, and the package
      explorer view.</p><p>The category view provides a way to navigate your rules in a way
      that makes sense to your organization.</p><div class="figure"><a name="d0e5853"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/CategoryExplorer.png" align="middle" alt="Category view"></div></div><p class="title"><b>Figure&nbsp;9.26.&nbsp;Category view</b></p></div><br class="figure-break"><p>The above diagram shows categories in action. Generally under each
      category you should have no more then a few dozen rules, if
      possible.</p><p>The alternative and more technical view is to use the package
      explorer. This shows the rules (assets) closer to how they are actually
      stored in the database, and also separates rules into packages (name
      spaces) and their type (format, as rules can be in many different
      formats).</p><div class="figure"><a name="d0e5863"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/PackageExplorer.png" align="middle" alt="Package view"></div></div><p class="title"><b>Figure&nbsp;9.27.&nbsp;Package view</b></p></div><br class="figure-break"><p>The above shows the alternate way of exploring - using
      packages.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5871"></a>9.4.3.&nbsp;The business user perspective</h3></div></div></div><p>You can see from this manual, that some expertise and practice is
    required to use the BRMS. In fact any software system in some sense
    requires that people be "technical" even if it has a nice looking GUI.
    Having said that, in the right hands the BRMS can be setup to provide a
    suitable environment for non technical users.</p><p>The most appropriate rule formats for this use are using the Guided
    editor, Decision tables and DSL rules. You can use some DSL expressions
    also in the guided editor (so it provides "forms" for people to enter
    values).</p><p>You can use categories to isolate rules and assets from non
    technical users. Only assets which have a category assigned will appear in
    the "rules" feature.</p><p>The initial setup of the BRMS will need to be done by a
    developer/technical person who will set the foundations for all the rules.
    They may also create "templates" which are rules which may be copied (they
    would typically live in a "dummy" package, and have a category of
    "template" - this can also help ease the way).</p><p>Deployment should also not be done by non technical users (as
    mentioned previously this happens from the "Package" feature).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5884"></a>9.4.4.&nbsp;Deployment: Integrating rules with your applications</h3></div></div></div><p>Its all very interesting to manage rules, but how to you use or
    "consume" them in your application? This section covers the usage of the
    RuleAgent deployment component that automates most of this for you.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5889"></a>9.4.4.1.&nbsp;The Rule Agent</h4></div></div></div><p>The rule agent is a component which is embedded in the core
      runtime of the rules engine. To use this, you don't need any extra
      components. In fact, if you are using the BRMS, your application should
      only need to include the drools-core dependencies in its classpath
      (drools and mvel jars only), and no other rules specific
      dependencies.</p><p>Note that there is also a drools-ant ant task, so you can build
      rules as part of an ant script (for example in cases where the rules are
      edited in the IDE) without using the BRMS at all - the drools-ant task
      will generate .pkg files the same as the BRMS.</p><p>Once you have "built" your rules in a package in the BRMS (or from
      the ant task), you are ready to use the agent in your target
      application.</p><p>To use the rule agent, you will use a call in your applications
      code like:</p><pre class="programlisting">RuleAgent agent = RuleAgent.newRuleAgent("/MyRules.properties");     
RuleBase rb = agent.getRuleBase(); 
rb.newStatefulSession.... 
//now assert your facts into the session and away you go !
</pre><p>IMPORTANT: You should only have one instance of the RuleAgent per
      rulebase you are using. This means you should (for example) keep the
      agent in a singleton, JNDI (or similar). In practice most people are
      using frameworks like Seam or Spring - in which case they will take care
      of managing this for you (in fact in Seam - it is already integrated -
      you can inject rulebases into Seam components). Note that the RuleBase
      can be used multiple times by multiple threads if needed (no need to
      have multiple copies of it).</p><p>This assumes that there is a MyRules.properties in the root of
      your classpath. You can also pass in a Properties object with the
      parameters set up (the parameters are discussed next).</p><p>The following shows the content of MyRules.properties:</p><pre class="programlisting">##
## RuleAgent configuration file example
##

newInstance=true
file=/foo/bar/boo.pkg /foo/bar/boo2.pkg
dir=/my/dir
url=http://some.url/here http://some.url/here
localCacheDir=/foo/bar/cache
poll=30


name=MyConfig</pre><p>You can only have one type of key in each configuration (eg only
      one "file", "dir" etc - even though you can specify multiple items by
      space separating them). Note also, instead of a discrete properties
      file, you can construct a java.utils.Properties object, and pass it in
      to the RuleBase methods.</p><p>Referring to the above example, the "keys" in the properties
      are:</p><div class="itemizedlist"><ul type="disc"><li><p>newInstance</p><p>Setting this to "true" means that the RuleBase instance will
          be created fresh each time there is a change. this means you need to
          do agent.getRuleBase() to get the new updated rulebase (any existing
          ones in use will be untouched). The default is false, which means
          rulebases are updated "in place" - ie you don't need to keep calling
          getRuleBase() to make sure you have the latest rules (also any
          StatefulSessions will be updated automatically with rule
          changes).</p></li><li><p>file</p><p>This is a space-separated list of files - each file is a
          binary package as exported by the BRMS. You can have one or many.
          The name of the file is not important. Each package must be in its
          own file.</p><p>NOTE: it is also possible to specify .drl files - and it will
          compile it into the package. However, note that for this to work,
          you will need the drools-compiler dependencies in your applications
          classpath (as opposed to just the runtime dependencies).</p><p>Please note that if the path has a space in it, you will need
          to put double quotes around it (as the space is used to separate
          different items, and it will not work otherwise). Generally spaces
          in a path name are best to avoid.</p></li><li><p>dir</p><p>This is similar to file, except that instead of specifying a
          list of files you specify a directory, and it will pick up all the
          files in there (each one is a package) and add them to the rulebase.
          Each package must be in its own file.</p><p>Please note that if the path has a space in it, you will need
          to put double quotes around it (as the space is used to separate
          different items, and it will not work otherwise). Generally spaces
          in a path name are best to avoid.</p></li><li><p>url</p><p>This is a space separated list of URLs to the BRMS which is
          exposing the packages (see below for more details).</p></li><li><p>localCacheDir</p><p>This is used in conjunction with the url above, so that if the
          BRMS is down (the url is not accessible) then if the runtime has to
          start up, it can start up with the last known "good" versions of the
          packages.</p></li><li><p>poll</p><p>This is set to the number of seconds to check for changes to
          the resources (a timer is used).</p></li><li><p>name</p><p>This is used to specify the name of the agent which is used
          when logging events (as typically you would have multiple agents in
          a system).</p></li></ul></div><p>Following shows the deployment screen of the BRMS, which provides
      URLs and downloads of packages.</p><div class="figure"><a name="d0e5958"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-BRMS/SnapshotDeploy.png" align="middle" alt="Snapshot deployment"></div></div><p class="title"><b>Figure&nbsp;9.28.&nbsp;Snapshot deployment</b></p></div><br class="figure-break"><p>You can see the "Package URI" - this is the URL that you would
      copy and paste into the agent .properties file to specify that you want
      this package. It specifies an exact version (in this case to a snapshot)
      - each snapshot has its own URL. If you want the "latest" - then replace
      "NewSnapshot" with "LATEST".</p><p>You can also download a .pkg file from here, which you can drop in
      a directory and use the "file" or "dir" feature of the RuleAgent if
      needed (in some cases people will not want to have the runtime
      automatically contact the BRMS for updates - but that is generally the
      easiest way for many people).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5968"></a>9.4.4.2.&nbsp;Manual deployment</h4></div></div></div><p>This section is only needed for advanced users who are integrating
      deployment into their own mechanism. Normally you should use the rule
      agent.</p><p>For those who do not wish to use the automatic deployment of the
      RuleAgent, "rolling your own" is quite simple. The binary packages
      emitted by the BRMS are serialized Package objects. You can deserialize
      them and add them into any rulebase - essentially that is all you need
      to do.</p><p>From the BRMS, binary packages are provided either from the latest
      version of a package (once you have successfully validated and built a
      package) or from the deployment snapshots. The URLs that the BRMS web
      application exposes provide the binary package via http. You can also
      issue a "HEAD" command to get the last time a package was
      updated.</p></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e5978"></a>Chapter&nbsp;10.&nbsp;Examples</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5981"></a>10.1.&nbsp;Getting the examples</h2></div></div></div><p>Make sure the Drools Eclipse plugin is installed, which needs GEF
  dependency installed first. Then download and extract the drools-examples
  zip file, which includes an already created Eclipse project. Import that
  project into a new Eclipse workspace. The rules all have example classes
  that execute the rules. If you want to try the examples in another project
  (or another IDE) then you will need to setup the dependencies by hand of
  course. Many, but not all of the examples are documented below, enjoy
  :)</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5986"></a>10.1.1.&nbsp;Hello World</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Hello World
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.HelloWorldExample
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> HelloWorld.drl
<span class="bold"><strong>Objective:</strong></span> demonstrate basic rules in use
</pre><p>The "Hello World" example shows a simple example of rules usage, and
    both the MVEL and Java dialects.</p><p>In this example it will be shown how to build rulebases and sessions
    and how to add audit logging and debug outputs, this information is
    ommitted from other examples as it's all very similar. PackageBuilder is
    used to turn a drl source file into Package objects which the RuleBase can
    consume, addPackageFromDrl takes a Reader interface as the parameter.
    Reader can be used to retrieve a source drl file from various locations,
    in this case the drl file is being retrieved from the classpath as an
    InputStream which we turn into a Reader by wrapping it with
    InputStreamReader; but it could come the disk or a url. The use of the
    Reader interface means that Drools does not have to care. In this case we
    only add a single drl source file, but multiple drl files can be added and
    all are merged into a single Package. All drl files added to the
    PackageBuilder must declare themselves in the same package namespace, if
    you wish to build a Package in a different namespace a new instance of
    PackageBuilder must be created; multiple packages of differerent
    namespaces can be added to the same RuleBase. When all the drl files have
    been added we should check the builder for errors; while the RuleBase will
    validate the packge it will only have access to the error information as a
    String, so if you wish to debug the error information you should do it on
    the builder instance. Once we know the builder is error free get the
    Package, instantiate a RuleBase from the RuleBaseFactory and add the
    package.</p><div class="example"><a name="d0e6009"></a><p class="title"><b>Example&nbsp;10.1.&nbsp;HelloWorld example: Creating the RuleBase and Session</b></p><div class="example-contents"><pre class="programlisting">//read in the source
Reader source = new InputStreamReader( HelloWorldExample.class.getResourceAsStream( "HelloWorld.drl" ) );

PackageBuilder builder = new PackageBuilder();

//this wil parse and compile in one step
builder.addPackageFromDrl( source );

// Check the builder for errors
if ( builder.hasErrors() ) {
    System.out.println( builder.getErrors().toString() );
    throw new RuntimeException( "Unable to compile \"HelloWorld.drl\".");
}

//get the compiled package (which is serializable)
Package pkg = builder.getPackage();

//add the package to a rulebase (deploy the rule package).
RuleBase ruleBase = RuleBaseFactory.newRuleBase();
ruleBase.addPackage( pkg );

StatefulSession session = ruleBase.newStatefulSession();</pre></div></div><br class="example-break"><p>Drools has an event model that exposes much of whats happening
    internally, two default debug listeners are supplied
    DebugAgendaEventListener and DebugWorkingMemoryEventListener which print
    out debug event information to the err console, adding listeners to a
    session is trivial and shown below. The WorkingMemoryFileLogger provides
    execution auditing which can be viewed in a graphical viewer; it's
    actually a specialised implementation built on the agenda and working
    memory listeners, when the engine has finished executing
    logger.writeToDisk() must be called.</p><p>Most of the examples use the Audit logging features of Drools to
    record execution flow for later inspection.</p><div class="example"><a name="d0e6018"></a><p class="title"><b>Example&nbsp;10.2.&nbsp;HelloWorld example: Event logging and Auditing</b></p><div class="example-contents"><pre class="programlisting">// setup the debug listeners
session.addEventListener( new DebugAgendaEventListener() );
session.addEventListener( new DebugWorkingMemoryEventListener() );
        
// setup the audit logging
WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger( session );
logger.setFileName( "log/helloworld" );     </pre></div></div><br class="example-break"><p>The single class used in this example is very simple, it has two
    fields: the message, which is a String and the status which can be either
    the int HELLO or the int GOODBYE.</p><div class="example"><a name="d0e6025"></a><p class="title"><b>Example&nbsp;10.3.&nbsp;HelloWorld example: Message Class</b></p><div class="example-contents"><pre class="programlisting">public static class Message {
    public static final int HELLO   = 0;
    public static final int GOODBYE = 1;

    private String          message;
    private int             status; 
    ...
}</pre></div></div><br class="example-break"><p>A single Message object is created with the message "Hello World"
    and status HELLO and then inserted into the engine, at which point
    fireAllRules() is executed. Remember all the network evaluation is done
    during the insert time, by the time the program execution reaches the
    fireAllRules() method it already knows which rules are fully matches and
    able to fire.</p><div class="example"><a name="d0e6032"></a><p class="title"><b>Example&nbsp;10.4.&nbsp;HelloWorld example: Execution</b></p><div class="example-contents"><pre class="programlisting">Message message = new Message();
message.setMessage( "Hello World" );
message.setStatus( Message.HELLO );
session.insert( message );
        
session.fireAllRules();
        
logger.writeToDisk();
      
session.dispose();    </pre></div></div><br class="example-break"><p>To execute the example from Java.</p><div class="orderedlist"><ol type="1"><li><p>Open the class org.drools.examples.FibonacciExample in your
          Eclipse IDE</p></li><li><p>Right-click the class an select "Run as..." -&gt; "Java
          application"</p></li></ol></div><p>If we put a breakpoint on the fireAllRules() method and select the
    session variable we can see that the "Hello World" view is already
    activated and on the Agenda, showing that all the pattern matching work
    was already done during the insert.</p><div class="figure"><a name="d0e6049"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/helloworld_agenda1.png" alt="Hello World : fireAllRules Agenda View"></div></div><p class="title"><b>Figure&nbsp;10.1.&nbsp;Hello World : fireAllRules Agenda View</b></p></div><br class="figure-break"><p>The may application print outs go to to System.out while the debug
    listener print outs go to System.err.</p><div class="example"><a name="d0e6057"></a><p class="title"><b>Example&nbsp;10.5.&nbsp;HelloWorld example: Console.out</b></p><div class="example-contents"><pre class="programlisting">Hello World
Goodbyte cruel world</pre></div></div><br class="example-break"><div class="example"><a name="d0e6062"></a><p class="title"><b>Example&nbsp;10.6.&nbsp;HelloWorld example: Console.err</b></p><div class="example-contents"><pre class="programlisting">==&gt;[ActivationCreated(0): rule=Hello World; 
                          tuple=[fid:1:1:org.drools.examples.HelloWorldExample$Message@17cec96]]
[ObjectInserted: handle=[fid:1:1:org.drools.examples.HelloWorldExample$Message@17cec96]; 
                 object=org.drools.examples.HelloWorldExample$Message@17cec96]
[BeforeActivationFired: rule=Hello World; 
                        tuple=[fid:1:1:org.drools.examples.HelloWorldExample$Message@17cec96]]
==&gt;[ActivationCreated(4): rule=Good Bye; 
                          tuple=[fid:1:2:org.drools.examples.HelloWorldExample$Message@17cec96]]
[ObjectUpdated: handle=[fid:1:2:org.drools.examples.HelloWorldExample$Message@17cec96]; 
                old_object=org.drools.examples.HelloWorldExample$Message@17cec96; 
                new_object=org.drools.examples.HelloWorldExample$Message@17cec96]
[AfterActivationFired(0): rule=Hello World]
[BeforeActivationFired: rule=Good Bye; 
                        tuple=[fid:1:2:org.drools.examples.HelloWorldExample$Message@17cec96]]
[AfterActivationFired(4): rule=Good Bye]  </pre></div></div><br class="example-break"><p>The <span class="bold"><strong>LHS (when)</strong></span> section of the rule
    states that it will be activated for each <span class="emphasis"><em>Message</em></span>
    object inserted into the working memory whose <span class="emphasis"><em>status</em></span>
    is <span class="emphasis"><em>Message.HELLO</em></span>. Besides that, two variable binds
    are created: "<span class="emphasis"><em>message</em></span>" variable is bound to the
    <span class="emphasis"><em>message</em></span> attribute and "<span class="emphasis"><em>m</em></span>"
    variable is bound to the <span class="emphasis"><em>object matched pattern</em></span>
    itself.</p><p>The <span class="bold"><strong>RHS (consequence, then)</strong></span> section
    of the rule is written using the MVEL expression language, as declared by
    the rule's attribute <span class="emphasis"><em>dialect</em></span>. After printing the
    content of the <span class="emphasis"><em>message</em></span> bound variable to the default
    console, the rule changes the values of the <span class="emphasis"><em>message</em></span>
    and <span class="emphasis"><em>status</em></span> attributes of the <span class="emphasis"><em>m</em></span>
    bound variable; using MVEL's 'modify' keyword which allows you to apply a
    block of setters in one statement, with the engine being automatically
    notified of the changes at the end of the block.</p><div class="example"><a name="d0e6113"></a><p class="title"><b>Example&nbsp;10.7.&nbsp;HelloWorld example: rule "Hello World"</b></p><div class="example-contents"><pre class="programlisting">rule "Hello World"
      dialect "mvel"
  when
      m : Message( status == Message.HELLO, message : message )
  then
      System.out.println( message ); 
      modify ( m ) { message = "Goodbyte cruel world",
                     status = Message.GOODBYE };
end</pre></div></div><br class="example-break"><p>We can add a break point into the DRL for when modify is called
    during the execution of the "Hello World" consequence and inspect the
    Agenda view again. Notice this time we "Debug As" a "Drools application"
    and not a "Java application".</p><div class="orderedlist"><ol type="1"><li><p>Open the class org.drools.examples.FibonacciExample in your
          Eclipse IDE</p></li><li><p>Right-click the class an select "Debug as..." -&gt; "Drools
          application"</p></li></ol></div><p>Now we can see that the other rule "Good Bye" which uses
    the java dialect is activated and placed on the agenda.</p><div class="figure"><a name="d0e6129"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/helloworld_agenda2.png" alt="Hello World : rule &#34;Hello World&#34; Agenda View"></div></div><p class="title"><b>Figure&nbsp;10.2.&nbsp;Hello World : rule "Hello World" Agenda View</b></p></div><br class="figure-break"><p>The "Good Bye" rule is similar to the "Hello World" rule but matches
    Message objects whose status is Message.GOODBYE instead, printing its
    message to the default console, it specifies the "java" dialect.</p><div class="example"><a name="d0e6137"></a><p class="title"><b>Example&nbsp;10.8.&nbsp;HelloWorld example: rule "Good Bye"</b></p><div class="example-contents"><pre class="programlisting">rule "Good Bye"
      dialect "java"
  when
      Message( status == Message.GOODBYE, message : message )
  then
      System.out.println( message ); 
end</pre></div></div><br class="example-break"><p>If you remember at the start of this example in the java code we
    created a WorkingMemoryFileLogger and called logger.writeToDisk() at the
    end, this created an audit log file that can be shown in the Audit view.
    We use the audit view in many of the examples to try and understand the
    example execution flow. In the view below we can see the object is
    inserted which creates an activation for the "Hello World" rule, the
    activation is then executed which updated the Message object causing the
    "Good Bye" rule to activate, the "Good Bye" rule then also executes. When
    an event in the Audit view is select it highlights the origin event in
    green, so below the Activation created event is highlighted in greed as
    the origin of the Activation executed event.</p><div class="figure"><a name="d0e6144"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/helloworld_auditview1.png" alt="Hello World : Audit View"></div></div><p class="title"><b>Figure&nbsp;10.3.&nbsp;Hello World : Audit View</b></p></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6150"></a>10.1.2.&nbsp;State Example</h3></div></div></div><p>This example is actually implemented in three different versions to
    demonstrate different ways of implementing the same basic behavior: rules
    forward chaining, i.e., the ability the engine has to evaluate, activate
    and fire rules in sequence, based on changes on the facts in the working
    memory.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6155"></a>10.1.2.1.&nbsp;Understanding the State Example</h4></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> State Example
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.StateExampleUsingSalience
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> StateExampleUsingSalience.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates basic rule use and Conflict Resolution for rule firing priority.</pre><p>Each
      State class has fields for its name and its current state (see
      org.drools.examples.State class). The two possible states for each
      objects are:</p><div class="itemizedlist"><ul type="disc"><li><p>NOTRUN</p></li><li><p>FINISHED</p></li></ul></div><div class="example"><a name="d0e6183"></a><p class="title"><b>Example&nbsp;10.9.&nbsp;State Classs</b></p><div class="example-contents"><pre class="programlisting">public class State {
    public static final int       NOTRUN   = 0;
    public static final int       FINISHED = 1;

    private final PropertyChangeSupport changes  = new PropertyChangeSupport( this );

    private String                name;
    private int                   state;

    ... setters and getters go here...
}</pre></div></div><br class="example-break"><p>Ignore the PropertyChangeSupport for now, that will be explained
      later. In the example we create four State objects with names: A, B, C
      and D. Initially all are set to state NOTRUN, which is default for the
      used constructor. Each instance is asserted in turn into the session and
      then fireAllRules() is called.</p><div class="example"><a name="d0e6190"></a><p class="title"><b>Example&nbsp;10.10.&nbsp;Salience State Example Execution</b></p><div class="example-contents"><pre class="programlisting">State a = new State( "A" );
State b = new State( "B" );
State c = new State( "C" );
final State d = new State( "D" );

// By setting dynamic to TRUE, Drools will use JavaBean
// PropertyChangeListeners so you don't have to call update().
boolean dynamic = true;

session.insert( a,
                dynamic );
session.insert( b,
                dynamic );
session.insert( c,
                dynamic );
session.insert( d,
                dynamic );

session.fireAllRules();
session.dispose(); // Stateful rule session must always be disposed when finished</pre></div></div><br class="example-break"><p>To execute the application:</p><div class="orderedlist"><ol type="1"><li><p>Open the class org.drools.examples.StateExampleUsingSalience
            in your Eclipse IDE</p></li><li><p>Right-click the class an select "Run as..." -&gt; "Java
            application"</p></li></ol></div><p>And you will see the following output in the Eclipse console
      output:</p><div class="example"><a name="d0e6207"></a><p class="title"><b>Example&nbsp;10.11.&nbsp;Salience State Example Console Output</b></p><div class="example-contents"><pre class="programlisting">A finished
B finished
C finished
D finished
</pre></div></div><br class="example-break"><p>There are four rules in total, first a Bootstrap rule fires
      setting A to state FINISHED which then causes B to change to state
      FINISHED. C and D are both dependent on B - causing a conflict which is
      resolved by setting salience values. First lets look at how this was
      executed</p><p>The best way to understand what is happening is to use the "Audit
      Log" feature to graphically see the results of each operation. The Audit
      log was generated when the example was previously run. To view the Audit
      log in Eclipse:</p><div class="orderedlist"><ol type="1"><li><p>If the "Audit View" is not visible, click on:
          "Window"-&gt;"Show View"-&gt;"Other..."-&gt;"Drools"-&gt;"Audit
          View"</p></li><li><p>In the "Audit View" click in the "Open Log" button and select
          the file "&lt;drools-examples-drl-dir&gt;/log/state.log"</p></li></ol></div><p>After that, the "Audit view" will look like the following
      screenshot.</p><div class="figure"><a name="d0e6225"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/state_example_audit1.png" alt="Salience State Example Audit View"></div></div><p class="title"><b>Figure&nbsp;10.4.&nbsp;Salience State Example Audit View</b></p></div><br class="figure-break"><p>Reading the log in the "Audit View", top to down, we see every
      action and the corresponding changes in the working memory. This way we
      see that the assertion of the State "A" object with the "NOTRUN" state
      activates the "Bootstrap" rule, while the assertions of the other state
      objects have no immediate effect.</p><div class="example"><a name="d0e6233"></a><p class="title"><b>Example&nbsp;10.12.&nbsp;Salience State Example: Rule "Bootstrap"</b></p><div class="example-contents"><pre class="programlisting">rule Bootstrap
    when
        a : State(name == "A", state == State.NOTRUN )
    then
        System.out.println(a.getName() + " finished" );
        a.setState( State.FINISHED );
end</pre></div></div><br class="example-break"><p>The execution of "Bootstrap" rule changes the state of "A" to
      "FINISHED", that in turn activates the "A to B" rule.</p><div class="example"><a name="d0e6240"></a><p class="title"><b>Example&nbsp;10.13.&nbsp;Salience State Example: Rule "A to B"</b></p><div class="example-contents"><pre class="programlisting">rule "A to B"
    when
        State(name == "A", state == State.FINISHED )
        b : State(name == "B", state == State.NOTRUN )
    then
        System.out.println(b.getName() + " finished" );
        b.setState( State.FINISHED );
end
</pre></div></div><br class="example-break"><p>The execution of "A to B" rule changes the state of "B" to
      "FINISHED", which activates both rules "B to C" and "B to D", placing
      both Activations onto the Agenda. In this moment the two rules may fire
      and are said to be in conflict. The conflict resolution strategy allows
      the engine's Agenda to decide which rule to fire. As the "B to C" rule
      has a <span class="bold"><strong>higher salience value</strong></span> (10 versus
      the default salience value of 0), it fires first, modifying the "C"
      object to state "FINISHED". The Audit view above shows the modification
      of the State object in the rule "A to B" which results in two
      highlighted activations being in conflict. The Agenda view can also be
      used to investigate the state of the Agenda, debug points can be placed
      in the rules themselves and the Agenda view opened; the screen shot
      below shows the break point in the rule "A to B" and the state of the
      Agenda with the two conflicting rules.</p><div class="figure"><a name="d0e6250"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/state_example_agenda1.png" alt="State Example Agenda View"></div></div><p class="title"><b>Figure&nbsp;10.5.&nbsp;State Example Agenda View</b></p></div><br class="figure-break"><div class="example"><a name="d0e6256"></a><p class="title"><b>Example&nbsp;10.14.&nbsp;Salience State Example: Rule "B to C"</b></p><div class="example-contents"><pre class="programlisting">rule "B to C"
        salience 10
    when
        State(name == "B", state == State.FINISHED )
        c : State(name == "C", state == State.NOTRUN )
    then
        System.out.println(c.getName() + " finished" );
        c.setState( State.FINISHED );
end
</pre></div></div><br class="example-break"><p>The "B to D" rule fires last, modifying the "D" object to state
      "FINISHED".</p><div class="example"><a name="d0e6263"></a><p class="title"><b>Example&nbsp;10.15.&nbsp;Salience State Example: Rule "B to D"</b></p><div class="example-contents"><pre class="programlisting">rule "B to D"
    when
        State(name == "B", state == State.FINISHED )
        d : State(name == "D", state == State.NOTRUN )
    then
        System.out.println(d.getName() + " finished" );
        d.setState( State.FINISHED );
end</pre></div></div><br class="example-break"><p>There are no more rules to execute and so the engine stops.</p><p>Another notable concept in this example is the use of <span class="bold"><strong>dynamic facts</strong></span>, which is the
      PropertyChangeListener part. As mentioned previously in the
      documentation, in order for the engine to see and react to fact's
      properties change, the application must tell the engine that changes
      occurred. This can be done explicitly in the rules, by calling the
      <span class="bold"><strong>update()</strong></span> memory action, or implicitly
      by letting the engine know that the facts implement
      PropertyChangeSupport as defined by the <span class="emphasis"><em>Javabeans
      specification</em></span>. This example demonstrates how to use
      PropertyChangeSupport to avoid the need for explicit update() calls in
      the rules. To make use of this feature, make sure your facts implement
      the PropertyChangeSupport as the org.drools.example.State class does and
      use the following code to insert the facts into the working
      memory:</p><div class="example"><a name="d0e6281"></a><p class="title"><b>Example&nbsp;10.16.&nbsp;Inserting a Dynamic Fact</b></p><div class="example-contents"><pre class="programlisting">// By setting dynamic to TRUE, Drools will use JavaBean
// PropertyChangeListeners so you don't have to call update().
final boolean dynamic = true;

session.insert( fact,
                dynamic );
</pre></div></div><br class="example-break"><p>When using PropertyChangeListeners each setter must implement a
      little extra code to do the notification, here is the state setter for
      thte org.drools.examples.State class:</p><div class="example"><a name="d0e6288"></a><p class="title"><b>Example&nbsp;10.17.&nbsp;Setter Example with PropertyChangeSupport</b></p><div class="example-contents"><pre class="programlisting">public void setState(final int newState) {
    int oldState = this.state;
    this.state = newState;
    this.changes.firePropertyChange( "state",
                                     oldState,
                                     newState );
}</pre></div></div><br class="example-break"><p>There are two other State examples: StateExampleUsingAgendGroup
      and StateExampleWithDynamicRules. Both execute from A to B to C to D, as
      just shown, the StateExampleUsingAgendGroup uses agenda-groups to
      control the rule conflict and which one fires first and
      StateExampleWithDynamicRules shows how an additional rule can be added
      to an already running WorkingMemory with all the existing data applying
      to it at runtime.</p><p>Agenda groups are a way to partition the agenda into groups and
      controlling which groups can execute. All rules by default are in the
      "MAIN" agenda group, by simply using the "agenda-group" attribute you
      specify a different agenda group for the rule. A working memory
      initially only has focus on the "MAIN" agenda group, only when other
      groups are given the focus can their rules fire; this can be achieved by
      either using the method setFocus() or the rule attribute "auto-focus".
      "auto-focus" means that the rule automatically sets the focus to it's
      agenda group when the rule is matched and activated. It is this
      "auto-focus" that enables "B to C" to fire before "B to D".</p><div class="example"><a name="d0e6297"></a><p class="title"><b>Example&nbsp;10.18.&nbsp;Agenda Group State Example: Rule "B to C"</b></p><div class="example-contents"><pre class="programlisting">rule "B to C"
      agenda-group "B to C"
      auto-focus true       
  when
      State(name == "B", state == State.FINISHED )      
      c : State(name == "C", state == State.NOTRUN )
  then
      System.out.println(c.getName() + " finished" );
      c.setState( State.FINISHED );
      drools.setFocus( "B to D" );
end</pre></div></div><br class="example-break"><p>The rule "B to C" calls "drools.setFocus( "B to D" );" which gives
      the agenda group "B to D" focus allowing its active rules to fire; which
      allows the rule "B to D" to fire.</p><div class="example"><a name="d0e6304"></a><p class="title"><b>Example&nbsp;10.19.&nbsp;Agenda Group State Example: Rule "B to D"</b></p><div class="example-contents"><pre class="programlisting">rule "B to D"
      agenda-group "B to D"
  when
      State(name == "B", state == State.FINISHED )      
      d : State(name == "D", state == State.NOTRUN )
  then
      System.out.println(d.getName() + " finished" );
      d.setState( State.FINISHED );
end</pre></div></div><br class="example-break"><p>The example StateExampleWithDynamicRules adds another rule to the
      RuleBase after fireAllRules(), the rule it adds is just another State
      transition.</p><div class="example"><a name="d0e6311"></a><p class="title"><b>Example&nbsp;10.20.&nbsp;Dynamic State Example: Rule "D to E"</b></p><div class="example-contents"><pre class="programlisting">rule "D to E"
  when
      State(name == "D", state == State.FINISHED )      
      e : State(name == "E", state == State.NOTRUN )
  then
      System.out.println(e.getName() + " finished" );
      e.setState( State.FINISHED );
end</pre></div></div><br class="example-break"><p>It gives the following expected output:</p><div class="example"><a name="d0e6318"></a><p class="title"><b>Example&nbsp;10.21.&nbsp;Dynamic Sate Example Output</b></p><div class="example-contents"><pre class="programlisting">A finished
B finished
C finished
D finished
E finished
</pre></div></div><br class="example-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6323"></a>10.1.3.&nbsp;Banking Tutorial</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> BankingTutorial
<span class="bold"><strong>Main class:</strong></span> org.drools.tutorials.banking.*
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> org.drools.tutorials.banking.*
<span class="bold"><strong>Objective:</strong></span> tutorial that builds up knowledge of pattern matching, basic sorting and calculation rules.</pre><p>This tutorial will demonstrate the process of developing a complete
    personal banking application that will handle credits, debits, currencies
    and that will use a set of design patterns that have been created for the
    process. In order to make the examples documented here clear and modular,
    I will try and steer away from re-visiting existing code to add new
    functionality, and will instead extend and inject where
    appropriate.</p><p>The RuleRunner class is a simple harness to execute one or more drls
    against a set of data. It compiles the Packages and creates the RuleBase
    for each execution, this allows us to easy execute each scenario and see
    the outputs. In reality this is not a good solution for a production
    system where the RuleBase should be built just once and cached, but for
    the purposes of this tutorial it shall suffice.</p><div class="example"><a name="d0e6346"></a><p class="title"><b>Example&nbsp;10.22.&nbsp;Banking Tutorial : RuleRunner</b></p><div class="example-contents"><pre class="programlisting">public class RuleRunner {

    public RuleRunner() {
    }

    public void runRules(String[] rules,
                         Object[] facts) throws Exception {

        RuleBase ruleBase = RuleBaseFactory.newRuleBase();
        PackageBuilder builder = new PackageBuilder();

        for ( int i = 0; i &lt; rules.length; i++ ) {
            String ruleFile = rules[i];
            System.out.println( "Loading file: " + ruleFile );            
            builder.addPackageFromDrl(new InputStreamReader( RuleRunner.class.getResourceAsStream( ruleFile ) ) );
        }

        Package pkg = builder.getPackage();
        ruleBase.addPackage( pkg );
        WorkingMemory workingMemory = ruleBase.newStatefulSession();

        for ( int i = 0; i &lt; facts.length; i++ ) {
            Object fact = facts[i];
            System.out.println( "Inserting fact: " + fact );
            workingMemory.insert( fact );
        }

        workingMemory.fireAllRules();
    }
}</pre></div></div><br class="example-break"><p>This is our first Example1.java class it loads and executes a single
    drl file "Example.drl" but inserts no data.</p><div class="example"><a name="d0e6353"></a><p class="title"><b>Example&nbsp;10.23.&nbsp;Banking Tutorial : Java Example1</b></p><div class="example-contents"><pre class="programlisting">public class Example1 {
    public static void main(String[] args) throws Exception {
        new RuleRunner().runRules( new String[] { "Example1.drl" },
                                   new Object[0] );
    }
}</pre></div></div><br class="example-break"><p>And this is the first simple rule to execute. It has a single "eval"
    condition that will alway be true, thus this rul will always match and
    fire.</p><div class="example"><a name="d0e6360"></a><p class="title"><b>Example&nbsp;10.24.&nbsp;Banking Tutorial : Rule Example1</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 01"   
    when
        eval (1==1)
    then
        System.out.println("Rule 01 Works");
endh</pre></div></div><br class="example-break"><p>The output for the rule is below, the rule matches and executes the
    single print statement.</p><div class="example"><a name="d0e6367"></a><p class="title"><b>Example&nbsp;10.25.&nbsp;Banking Tutorial : Output Example1</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example1.drl
Rule 01 Works</pre></div></div><br class="example-break"><p>The next step is to assert some simple facts and print them out.
    </p><div class="example"><a name="d0e6374"></a><p class="title"><b>Example&nbsp;10.26.&nbsp;Banking Tutorial : Java Example2</b></p><div class="example-contents"><pre class="programlisting">public class Example2 {
    public static void main(String[] args) throws Exception {
        Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)};
        new RuleRunner().runRules( new String[] { "Example2.drl" },
                                   numbers );
    }
    
    private static Integer wrap(int i) {
        return new Integer(i);
    }
}</pre></div></div><br class="example-break"><p>This doesn&#8217;t use any specific facts but instead asserts a set of
    java.lang.Integer&#8217;s. This is not considered "best practice" as a number of
    a collection is not a fact, it is not a thing. A Bank acount has a number,
    its balance, thus the Account is the fact; but to get started asserting
    Integers shall suffice for demonstration purposes as the complexity is
    built up.</p><p>Now we will create a simple rule to print out these numbers.</p><div class="example"><a name="d0e6383"></a><p class="title"><b>Example&nbsp;10.27.&nbsp;Banking Tutorial : Rule Example2</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 02"   
    when
        Number( $intValue : intValue )
    then
        System.out.println("Number found with value: " + $intValue); 
end</pre></div></div><br class="example-break"><p>Once again, this rule does nothing special. It identifies any facts
    that are Numbers and prints out the values. Notice the user of interfaces
    here, we inserted Integers but the pattern matching engine is able to
    match the interfaces and super classes of the asserted objects.</p><p>The output shows the drl being loaded, the facts inserted and then
    the matched and fired rules. We can see that each inserted number is
    matched and fired and thus printed.</p><div class="example"><a name="d0e6392"></a><p class="title"><b>Example&nbsp;10.28.&nbsp;Banking Tutorial : Output Example2</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example2.drl
Inserting fact: 3
Inserting fact: 1
Inserting fact: 4
Inserting fact: 1
Inserting fact: 5
Number found with value: 5
Number found with value: 1
Number found with value: 4
Number found with value: 1
Number found with value: 3
</pre></div></div><br class="example-break"><p>here are probably a hundred and one better ways to sort numbers; but
    we will need to apply some cashflows in date order when we start looking
    at banking rules so let&#8217;s look at a simple rule based example.</p><div class="example"><a name="d0e6399"></a><p class="title"><b>Example&nbsp;10.29.&nbsp;Banking Tutorial : Java Example3</b></p><div class="example-contents"><pre class="programlisting">public class Example3 {
    public static void main(String[] args) throws Exception {
        Number[] numbers = new Number[] {wrap(3), wrap(1), wrap(4), wrap(1), wrap(5)};
        new RuleRunner().runRules( new String[] { "Example3.drl" },
                                   numbers );
    }
    
    private static Integer wrap(int i) {
        return new Integer(i);
    }
}</pre></div></div><br class="example-break"><p>Again we insert our Integers as before, this time the rule is
    slightly different:</p><div class="example"><a name="d0e6406"></a><p class="title"><b>Example&nbsp;10.30.&nbsp;Banking Tutorial : Rule Example3</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 03"   
    when
        $number : Number( )
        not Number( intValue &lt; $number.intValue )
    then
        System.out.println("Number found with value: " + $number.intValue() ); 
        retract( $number );
end</pre></div></div><br class="example-break"><p>The first line of the rules identifies a Number and extracts the
    value. The second line ensures that there does not exist a smaller number
    than the one found. By executing this rule, we might expect to find only
    one number - the smallest in the set. However, the retraction of the
    number after it has been printed, means that the smallest number has been
    removed, revealing the next smallest number, and so on. </p><p>So, the output we generate is, notice the numbers are now sorted
    numerically.</p><div class="example"><a name="d0e6415"></a><p class="title"><b>Example&nbsp;10.31.&nbsp;Banking Tutorial : Output Example3</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example3.drl
Inserting fact: 3
Inserting fact: 1
Inserting fact: 4
Inserting fact: 1
Inserting fact: 5
Number found with value: 1
Number found with value: 1
Number found with value: 3
Number found with value: 4
Number found with value: 5
</pre></div></div><br class="example-break"><p>Now we want to start moving towards our personal accounting rules.
    The first step is to create a Cashflow POJO.</p><div class="example"><a name="d0e6422"></a><p class="title"><b>Example&nbsp;10.32.&nbsp;Banking Tutoria : Class Cashflow</b></p><div class="example-contents"><pre class="programlisting">public class Cashflow {
    private Date   date;
    private double amount;

    public Cashflow() {
    }

    public Cashflow(Date date,
                    double amount) {
        this.date = date;
        this.amount = amount;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public double getAmount() {
        return amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    public String toString() {
        return "Cashflow[date=" + date + ",amount=" + amount + "]";
    }
}</pre></div></div><br class="example-break"><p>The Cashflow has two simple attributes, a date and an amount. I have
    added a toString method to print it and overloaded the constructor to set
    the values. The Example4 java code inserts 5 Cashflow objecst with varying
    dates and amounts.</p><div class="example"><a name="d0e6429"></a><p class="title"><b>Example&nbsp;10.33.&nbsp;Banking Tutorial : Java Example4</b></p><div class="example-contents"><pre class="programlisting">public class Example4 {    
    public static void main(String[] args) throws Exception {
        Object[] cashflows = {
            new Cashflow(new SimpleDate("01/01/2007"), 300.00),
            new Cashflow(new SimpleDate("05/01/2007"), 100.00),
            new Cashflow(new SimpleDate("11/01/2007"), 500.00),
            new Cashflow(new SimpleDate("07/01/2007"), 800.00),
            new Cashflow(new SimpleDate("02/01/2007"), 400.00),
        };
        
        new RuleRunner().runRules( new String[] { "Example4.drl" },
                                   cashflows );
    }
}</pre></div></div><br class="example-break"><p>SimpleDate is a simple class that extends Date and takes a String as
    input. It allows for pre-formatted Data classes, for convienience. The
    code is listed below</p><div class="example"><a name="d0e6436"></a><p class="title"><b>Example&nbsp;10.34.&nbsp;Banking Tutorial : Java SimpleDate</b></p><div class="example-contents"><pre class="programlisting">public class SimpleDate extends Date {
    private static final SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy");
    
    public SimpleDate(String datestr) throws Exception {             
        setTime(format.parse(datestr).getTime());
    }
}</pre></div></div><br class="example-break"><p>Now, let&#8217;s look at rule04.drl to see how we print the sorted
    Cashflows:</p><div class="example"><a name="d0e6443"></a><p class="title"><b>Example&nbsp;10.35.&nbsp;Banking Tutorial : Rule Example4</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 04"   
    when
        $cashflow : Cashflow( $date : date, $amount : amount )
        not Cashflow( date &lt; $date)
    then
        System.out.println("Cashflow: "+$date+" :: "+$amount);  
        retract($cashflow);
end</pre></div></div><br class="example-break"><p>Here, we identify a Cashflow and extract the date and the amount. In
    the second line of the rules we ensure that there is not a Cashflow with
    an earlier date than the one found. In the consequences, we print the
    Cashflow that satisfies the rules and then retract it, making way for the
    next earliest Cashflow. So, the output we generate is:</p><div class="example"><a name="d0e6450"></a><p class="title"><b>Example&nbsp;10.36.&nbsp;Banking Tutorial : Output Example4</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example4.drl
Inserting fact: Cashflow[date=Mon Jan 01 00:00:00 GMT 2007,amount=300.0]
Inserting fact: Cashflow[date=Fri Jan 05 00:00:00 GMT 2007,amount=100.0]
Inserting fact: Cashflow[date=Thu Jan 11 00:00:00 GMT 2007,amount=500.0]
Inserting fact: Cashflow[date=Sun Jan 07 00:00:00 GMT 2007,amount=800.0]
Inserting fact: Cashflow[date=Tue Jan 02 00:00:00 GMT 2007,amount=400.0]
Cashflow: Mon Jan 01 00:00:00 GMT 2007 :: 300.0
Cashflow: Tue Jan 02 00:00:00 GMT 2007 :: 400.0
Cashflow: Fri Jan 05 00:00:00 GMT 2007 :: 100.0
Cashflow: Sun Jan 07 00:00:00 GMT 2007 :: 800.0
Cashflow: Thu Jan 11 00:00:00 GMT 2007 :: 500.0
</pre></div></div><br class="example-break"><p>Here we extend our Cashflow to give a TypedCashflow which can be
    CREDIT or DEBIT. Ideally, we would just add this to the Cashflow type, but
    so that we can keep all the examples simple, we will go with the
    extensions.</p><div class="example"><a name="d0e6457"></a><p class="title"><b>Example&nbsp;10.37.&nbsp;Banking Tutoria : Class TypedCashflow</b></p><div class="example-contents"><pre class="programlisting">public class TypedCashflow extends Cashflow {
    public static final int CREDIT = 0;
    public static final int DEBIT  = 1;

    private int             type;

    public TypedCashflow() {
    }

    public TypedCashflow(Date date,
                         int type,
                         double amount) {
        super( date,
               amount );
        this.type = type;
    }

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public String toString() {
        return "TypedCashflow[date=" + getDate() + ",type=" + (type == CREDIT ? "Credit" : "Debit") + ",amount=" + getAmount() + "]";
    }
}</pre></div></div><br class="example-break"><p>There are lots of ways to improve this code, but for the sake of the
    example this will do.</p><p>Nows lets create the Example5 runner.</p><div class="example"><a name="d0e6466"></a><p class="title"><b>Example&nbsp;10.38.&nbsp;Banking Tutorial : Java Example5</b></p><div class="example-contents"><pre class="programlisting">public class Example5 {    
    public static void main(String[] args) throws Exception {      
        Object[] cashflows = {
            new TypedCashflow(new SimpleDate("01/01/2007"),    
                              TypedCashflow.CREDIT, 300.00),
            new TypedCashflow(new SimpleDate("05/01/2007"),
                              TypedCashflow.CREDIT, 100.00),
            new TypedCashflow(new SimpleDate("11/01/2007"),
                              TypedCashflow.CREDIT, 500.00),
            new TypedCashflow(new SimpleDate("07/01/2007"),
                              TypedCashflow.DEBIT, 800.00),
            new TypedCashflow(new SimpleDate("02/01/2007"),
                              TypedCashflow.DEBIT, 400.00),
        };
        
        new RuleRunner().runRules( new String[] { "Example5.drl" },
                                   cashflows );
    }
}</pre></div></div><br class="example-break"><p>Here, we simply create a set of Cashflows which are either CREDIT or
    DEBIT Cashflows and supply them and rule05.drl to the RuleEngine. </p><p>Now, let&#8217;s look at rule0 Example5.drl to see how we print the sorted
    Cashflows:</p><div class="example"><a name="d0e6475"></a><p class="title"><b>Example&nbsp;10.39.&nbsp;Banking Tutorial : Rule Example5</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 05"  
    when
        $cashflow : TypedCashflow( $date : date,
                                   $amount : amount,
                                   type == TypedCashflow.CREDIT )
        not TypedCashflow( date &lt; $date,
                           type == TypedCashflow.CREDIT )
    then
        System.out.println("Credit: "+$date+" :: "+$amount);   
        retract($cashflow);
end</pre></div></div><br class="example-break"><p>Here, we identify a Cashflow with a type of CREDIT and extract the
    date and the amount. In the second line of the rules we ensure that there
    is not a Cashflow of type CREDIT with an earlier date than the one found.
    In the consequences, we print the Cashflow that satisfies the rules and
    then retract it, making way for the next earliest Cashflow of type
    CREDIT.</p><p>So, the output we generate is</p><div class="example"><a name="d0e6484"></a><p class="title"><b>Example&nbsp;10.40.&nbsp;Banking Tutorial : Output Example5</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example5.drl
Inserting fact: TypedCashflow[date=Mon Jan 01 00:00:00 GMT 2007,type=Credit,amount=300.0]
Inserting fact: TypedCashflow[date=Fri Jan 05 00:00:00 GMT 2007,type=Credit,amount=100.0]
Inserting fact: TypedCashflow[date=Thu Jan 11 00:00:00 GMT 2007,type=Credit,amount=500.0]
Inserting fact: TypedCashflow[date=Sun Jan 07 00:00:00 GMT 2007,type=Debit,amount=800.0]
Inserting fact: TypedCashflow[date=Tue Jan 02 00:00:00 GMT 2007,type=Debit,amount=400.0]
Credit: Mon Jan 01 00:00:00 GMT 2007 :: 300.0
Credit: Fri Jan 05 00:00:00 GMT 2007 :: 100.0
Credit: Thu Jan 11 00:00:00 GMT 2007 :: 500.0
</pre></div></div><br class="example-break"><p>Here we are going to process both CREDITs and DEBITs on 2 bank
    accounts to calculate the account balance. In order to do this, I am going
    to create two separate Account Objects and inject them into the Cashflows
    before passing them to the Rule Engine. The reason for this is to provide
    easy access to the correct Bank Accounts without having to resort to
    Helper classes. Let&#8217;s take a look at the Account class first. This is a
    simple POJO with an account number and balance:</p><div class="example"><a name="d0e6491"></a><p class="title"><b>Example&nbsp;10.41.&nbsp;Banking Tutoria : Class Account</b></p><div class="example-contents"><pre class="programlisting">public class Account {
    private long   accountNo;
    private double balance = 0;

    public Account() {
    }

    public Account(long accountNo) {
        this.accountNo = accountNo;
    }

    public long getAccountNo() {
        return accountNo;
    }

    public void setAccountNo(long accountNo) {
        this.accountNo = accountNo;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public String toString() {
        return "Account[" + "accountNo=" + accountNo + ",balance=" + balance + "]";
    }
}</pre></div></div><br class="example-break"><p>Now let&#8217;s extend our TypedCashflow to give AllocatedCashflow
    (allocated to an account).</p><div class="example"><a name="d0e6498"></a><p class="title"><b>Example&nbsp;10.42.&nbsp;Banking Tutoria : Class AllocatedCashflow</b></p><div class="example-contents"><pre class="programlisting">public class AllocatedCashflow extends TypedCashflow {
    private Account account;

    public AllocatedCashflow() {
    }

    public AllocatedCashflow(Account account,
                             Date date,
                             int type,
                             double amount) {
        super( date,
               type,
               amount );
        this.account = account;
    }

    public Account getAccount() {
        return account;
    }

    public void setAccount(Account account) {
        this.account = account;
    }

    public String toString() {
        return "AllocatedCashflow[" + "account=" + account + ",date=" + getDate() + 
                                  ",type=" + (getType() == CREDIT ? "Credit" : "Debit") + 
                                  ",amount=" + getAmount() + "]";
    }
}</pre></div></div><br class="example-break"><p>Now, let&#8217;s java code for Example5 execution. Here we create two
    Account objects and inject one into each cashflow as appropriate. For
    simplicity I have simply included them in the constructor.</p><div class="example"><a name="d0e6505"></a><p class="title"><b>Example&nbsp;10.43.&nbsp;Banking Tutorial : Java Example5</b></p><div class="example-contents"><pre class="programlisting">public class Example6 {    
    public static void main(String[] args) throws Exception {      
        Account acc1 = new Account(1);
        Account acc2 = new Account(2);
           
        Object[] cashflows = {
            new AllocatedCashflow(acc1,new SimpleDate("01/01/2007"),
                                  TypedCashflow.CREDIT, 300.00),
            new AllocatedCashflow(acc1,new SimpleDate("05/02/2007"),
                                  TypedCashflow.CREDIT, 100.00),
            new AllocatedCashflow(acc2,new SimpleDate("11/03/2007"),
                                  TypedCashflow.CREDIT, 500.00),
            new AllocatedCashflow(acc1,new SimpleDate("07/02/2007"),
                                  TypedCashflow.DEBIT,  800.00),
            new AllocatedCashflow(acc2,new SimpleDate("02/03/2007"),
                                  TypedCashflow.DEBIT,  400.00),
            new AllocatedCashflow(acc1,new SimpleDate("01/04/2007"),    
                                  TypedCashflow.CREDIT, 200.00),
            new AllocatedCashflow(acc1,new SimpleDate("05/04/2007"),
                                  TypedCashflow.CREDIT, 300.00),
            new AllocatedCashflow(acc2,new SimpleDate("11/05/2007"),
                                  TypedCashflow.CREDIT, 700.00),
            new AllocatedCashflow(acc1,new SimpleDate("07/05/2007"),
                                  TypedCashflow.DEBIT,  900.00),
            new AllocatedCashflow(acc2,new SimpleDate("02/05/2007"),
                                  TypedCashflow.DEBIT,  100.00)           
        };
        
        new RuleRunner().runRules( new String[] { "Example6.drl" },
                                   cashflows );
    }
}</pre></div></div><br class="example-break"><p>Now, let&#8217;s look at rule Example06.drl to see how we apply each
    cashflow in date order and calculate and print the balance. </p><div class="example"><a name="d0e6512"></a><p class="title"><b>Example&nbsp;10.44.&nbsp;Banking Tutorial : Rule Example6</b></p><div class="example-contents"><pre class="programlisting">rule "Rule 06 - Credit"  
    when
        $cashflow : AllocatedCashflow( $account : account,
                                       $date : date, $amount : amount,
                                        type==TypedCashflow.CREDIT )
        not AllocatedCashflow( account == $account, date &lt; $date)
    then
        System.out.println("Credit: " + $date + " :: " + $amount);     
        $account.setBalance($account.getBalance()+$amount);
        System.out.println("Account: " + $account.getAccountNo() +
                           " - new balance: " + $account.getBalance());          
        retract($cashflow);
end

rule "Rule 06 - Debit"  
    when
        $cashflow : AllocatedCashflow( $account : account,
                            $date : date, $amount : amount,
                            type==TypedCashflow.DEBIT )
        not AllocatedCashflow( account == $account, date &lt; $date)
    then
        System.out.println("Debit: " + $date + " :: " + $amount);      
        $account.setBalance($account.getBalance() - $amount);
        System.out.println("Account: " + $account.getAccountNo() +
                           " - new balance: " + $account.getBalance());           
        retract($cashflow);
end</pre></div></div><br class="example-break"><p>Here, we have separate rules for CREDITs and DEBITs, however we do
    not specify a type when checking for earlier cashflows. This is so that
    all cashflows are applied in date order regardless of which type of
    cashflow type they are. In the rule section we identify the correct
    account to work with and in the consequences we update it with the
    cashflow amount.</p><div class="example"><a name="d0e6519"></a><p class="title"><b>Example&nbsp;10.45.&nbsp;Banking Tutorial : Output Example6</b></p><div class="example-contents"><pre class="programlisting">Loading file: Example6.drl
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Jan 01 00:00:00 GMT 2007,type=Credit,amount=300.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon Feb 05 00:00:00 GMT 2007,type=Credit,amount=100.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Sun Mar 11 00:00:00 GMT 2007,type=Credit,amount=500.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Wed Feb 07 00:00:00 GMT 2007,type=Debit,amount=800.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri Mar 02 00:00:00 GMT 2007,type=Debit,amount=400.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Sun Apr 01 00:00:00 BST 2007,type=Credit,amount=200.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Thu Apr 05 00:00:00 BST 2007,type=Credit,amount=300.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Fri May 11 00:00:00 BST 2007,type=Credit,amount=700.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=1,balance=0.0],date=Mon May 07 00:00:00 BST 2007,type=Debit,amount=900.0]
Inserting fact: AllocatedCashflow[account=Account[accountNo=2,balance=0.0],date=Wed May 02 00:00:00 BST 2007,type=Debit,amount=100.0]
Debit: Fri Mar 02 00:00:00 GMT 2007 :: 400.0
Account: 2 - new balance: -400.0
Credit: Sun Mar 11 00:00:00 GMT 2007 :: 500.0
Account: 2 - new balance: 100.0
Debit: Wed May 02 00:00:00 BST 2007 :: 100.0
Account: 2 - new balance: 0.0
Credit: Fri May 11 00:00:00 BST 2007 :: 700.0
Account: 2 - new balance: 700.0
Credit: Mon Jan 01 00:00:00 GMT 2007 :: 300.0
Account: 1 - new balance: 300.0
Credit: Mon Feb 05 00:00:00 GMT 2007 :: 100.0
Account: 1 - new balance: 400.0
Debit: Wed Feb 07 00:00:00 GMT 2007 :: 800.0
Account: 1 - new balance: -400.0
Credit: Sun Apr 01 00:00:00 BST 2007 :: 200.0
Account: 1 - new balance: -200.0
Credit: Thu Apr 05 00:00:00 BST 2007 :: 300.0
Account: 1 - new balance: 100.0
Debit: Mon May 07 00:00:00 BST 2007 :: 900.0
Account: 1 - new balance: -800.0
</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6524"></a>10.1.4.&nbsp;Fibonacci Example</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Fibonacci 
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.FibonacciExample
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> Fibonacci.drl
<span class="bold"><strong>Objective:</strong></span> Demonsrates Recursion, 'not' CEs and Cross Product Matching</pre><p>The Fibonacci Numbers, <a class="ulink" href="http://en.wikipedia.org/wiki/Fibonacci_number" target="_top">http://en.wikipedia.org/wiki/Fibonacci_number</a>,
    invented by Leonardo of Pisa, <a class="ulink" href="http://en.wikipedia.org/wiki/Fibonacci" target="_top">http://en.wikipedia.org/wiki/Fibonacci</a>,
    are obtained by starting with 0 and 1, and then produce the next Fibonacci
    number by adding the two previous Fibonacci numbers. The first Fibonacci
    numbers for n = 0, 1,... are: * 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,
    144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946... The Fibonacci
    Example demonstrates recursion and conflict resolution with Salience
    values.</p><p>A single fact Class is used in this example, Fibonacci. It has two
    fields, sequence and value. The sequence field is used to indicate the
    position of the object in the Fibonacci number sequence and the value
    field shows the value of that Fibonacci object for that sequence
    position.</p><div class="example"><a name="d0e6553"></a><p class="title"><b>Example&nbsp;10.46.&nbsp;Fibonacci Class</b></p><div class="example-contents"><pre class="programlisting">public static class Fibonacci {
    private int  sequence;
    private long value;

    ... setters and getters go here...
}</pre></div></div><br class="example-break"><p>Execute the example:</p><div class="orderedlist"><ol type="1"><li><p>Open the class org.drools.examples.FibonacciExample in your
          Eclipse IDE</p></li><li><p>Right-click the class an select "Run as..." -&gt; "Java
          application"</p></li></ol></div><p>And the Eclipse show the following output in it's console,
    "...snip..." shows repeated bits removed to save space:</p><div class="example"><a name="d0e6569"></a><p class="title"><b>Example&nbsp;10.47.&nbsp;Fibonacci Example Console Output</b></p><div class="example-contents"><pre class="programlisting">recurse for 50
recurse for 49
recurse for 48
recurse for 47
...snip...
recurse for 5
recurse for 4
recurse for 3
recurse for 2
1 == 1
2 == 1
3 == 2
4 == 3
5 == 5
6 == 8
...snip...
47 == 2971215073
48 == 4807526976
49 == 7778742049
50 == 12586269025
</pre></div></div><br class="example-break"><p>To kick this off from java we only insert a single Fibonacci object,
    with a sequence of 50, a recurse rule is then used to insert the other 49
    Fibonacci objects. This example doesn't use PropertyChangeSupport and uses
    the MVEL dialect, this means we can use the <span class="bold"><strong>modify</strong></span> keyword, which allows a block setter action
    which also notifies the engine of changes.</p><div class="example"><a name="d0e6579"></a><p class="title"><b>Example&nbsp;10.48.&nbsp;Fibonacci Example Execution</b></p><div class="example-contents"><pre class="programlisting">session.insert( new Fibonacci( 50 ) );
session.fireAllRules();</pre></div></div><br class="example-break"><p>The recurse rule is very simple, it matches each asserted Fibonacci
    object with a value of -1, it then creates and asserts a new Fibonacci
    object with a sequence of one less than the currently matched object. Each
    time a Fibonacci object is added, as long as one with a "sequence == 1"
    does not exist, the rule re-matches again and fires; causing the
    recursion. The 'not' conditional element is used to stop the rule matching
    once we have all 50 Fibonacci objects in memory. The rule also has a
    salience value, this is because we need to have all 50 Fibonacci objects
    asserted before we execute the Bootstrap rule.</p><div class="example"><a name="d0e6586"></a><p class="title"><b>Example&nbsp;10.49.&nbsp;Fibonacci Example : Rule "Recurse"</b></p><div class="example-contents"><pre class="programlisting">rule Recurse
    salience 10
    when
        f : Fibonacci ( value == -1 )
        not ( Fibonacci ( sequence == 1 ) )
    then
        insert( new Fibonacci( f.sequence - 1 ) );
        System.out.println( "recurse for " + f.sequence );
end</pre></div></div><br class="example-break"><p>The audit view shows the original assertion of the Fibonacci object
    with a sequence of 50, this was done from Java land. From there the audit
    view shows the continual recursion of the rule, each asserted Fibonacci
    causes the "Recurse" rule to become activate again, which then
    fires.</p><div class="figure"><a name="d0e6593"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/fibonacci1.png" alt="Fibonacci Example &#34;Recurse&#34; Audit View 1"></div></div><p class="title"><b>Figure&nbsp;10.6.&nbsp;Fibonacci Example "Recurse" Audit View 1</b></p></div><br class="figure-break"><p>When a Fibonacci with a sequence of 2 is asserted the "Bootstrap"
    rule is matched and activated along with the "Recurse" rule.</p><div class="example"><a name="d0e6601"></a><p class="title"><b>Example&nbsp;10.50.&nbsp;Fibonacci Example : Rule "Bootstrap"</b></p><div class="example-contents"><pre class="programlisting">rule Bootstrap
    when
        f : Fibonacci( sequence == 1 || == 2, value == -1 ) // this is a multi-restriction || on a single field
    then 
        modify ( f ){ value = 1 };
        System.out.println( f.sequence + " == " + f.value );
end</pre></div></div><br class="example-break"><p>At this point the Agenda looks like the figure shown below. However
    the "Bootstrap" rule does not fire as the "Recurse" rule has a higher
    salience.</p><div class="figure"><a name="d0e6608"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/fibonacci_agenda1.png" alt="Fibonacci Example &#34;Recurse&#34; Agenda View 1"></div></div><p class="title"><b>Figure&nbsp;10.7.&nbsp;Fibonacci Example "Recurse" Agenda View 1</b></p></div><br class="figure-break"><p>When a Fibonacci with a sequence of 1 is asserted the "Bootstrap"
    rule is matched again, causing two activations for this rule; note that
    the "Recurse" rule does not match and activate because the 'not
    conditional element stops the rule matching when a Fibonacci with a
    sequence of 1 exists.</p><div class="figure"><a name="d0e6616"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/fibonacci_agenda2.png" alt="Fibonacci Example &#34;Recurse&#34; Agenda View 2"></div></div><p class="title"><b>Figure&nbsp;10.8.&nbsp;Fibonacci Example "Recurse" Agenda View 2</b></p></div><br class="figure-break"><p>Once we have two Fibonacci objects both with values not equal to -1
    the "calculate" rule is able to match; remember it was the "Bootstrap"
    rule that set the Fibonacci's with sequences 1 and 2 to values of 1. At
    this point we have 50 Fibonacci objects in the Working Memory and we some
    how need to select the correct ones to calculate each of their values in
    turn. With three Fibonacci patterns in a rule with no field constriants to
    correctly constrain the available cross products we have 50x50x50 possible
    permutations, thats 125K possible rule firings. The "Calculate" rule uses
    the field constraints to correctly constraint the thee Fibonacci patterns
    and in the correct order; this technique is called "cross product
    matching". The first pattern finds any Fibonacci with a value != -1 and
    binds both the pattern and the field. The second Fibonacci does too but it
    adds an additional field constraint to make sure that its sequence is one
    greater than the Fibonacci bound to f1. When this rule first fires we know
    that only sequences 1 and 2 have values of 1 and the two constraints
    ensure that f1 references sequence 1 and f2 references sequence2. The
    final pattern finds the Fibonacci of a value == -1 with a sequence one
    greater than f2. At this point we have three Fibonacci objects correctly
    selected from the available cross products and we can do the maths
    calculating the value for Fibonacci sequence = 3.</p><div class="example"><a name="d0e6624"></a><p class="title"><b>Example&nbsp;10.51.&nbsp;Fibonacci Example : Rule "Calculate"</b></p><div class="example-contents"><pre class="programlisting">rule Calculate
    when
        f1 : Fibonacci( s1 : sequence, value != -1 ) // here we bind sequence
        f2 : Fibonacci( sequence == (s1 + 1 ), value != -1 ) // here we don't, just to demonstrate the different way bindings can be used
        f3 : Fibonacci( s3 : sequence == (f2.sequence + 1 ), value == -1 )              
    then    
        modify ( f3 ) { value = f1.value + f2.value };
        System.out.println( s3 + " == " + f3.value ); // see how you can access pattern and field  bindings
end 
</pre></div></div><br class="example-break"><p>The MVEL modify keyword updated the value of the Fibonacci object
    bound to f3, this means we have a new Fibonacci object with a value != -1,
    this allows the "Calculate" rule to rematch and calculate the next
    Fibonacci number. The Audit view below shows the how the firing of the
    last "Bootstrap" modifies the Fibonacci object enabling the "Calculate"
    rule to match, which then modifies another Fibonacci object allowing the
    "Calculate" rule to rematch. This continues till the value is set for all
    Fibonacci objects.</p><div class="figure"><a name="d0e6631"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/fibonacci4.png" alt="Fibonacci Example &#34;Bootstrap&#34; Audit View 1"></div></div><p class="title"><b>Figure&nbsp;10.9.&nbsp;Fibonacci Example "Bootstrap" Audit View 1</b></p></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6637"></a>10.1.5.&nbsp;Golfing Example</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Golfing
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.GolfingExample
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> golf.drl
<span class="bold"><strong>Objective:</strong></span> Configuration example that finds the solution from a large number of available cross products
</pre><p>The golf example solves a "riddle" style problem that is simple
    enough to state in sentences, but for which a conventional algorithmic
    solition is not obvious. It does this by searching for a suitable
    combination from a "space" of possible solutions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6658"></a>10.1.5.1.&nbsp;The riddle</h4></div></div></div><p>The problem is written as a riddle:</p><div class="orderedlist"><ol type="1"><li><p>A foursome of golfers is standing at a tee, in a line from
          left to right.</p></li><li><p>Each golfer wears different colored pants; one is wearing red
          pants.</p></li><li><p>The golfer to Fred&#8217;s immediate right is wearing blue
          pants.</p></li><li><p>Joe is second in line.</p></li><li><p>Bob is wearing plaid pants.</p></li><li><p>Tom isn&#8217;t in position one or four, and he isn&#8217;t wearing the
          hideous orange pants.</p></li></ol></div><p>The immediate thing about this riddle, is that a solution is not
      obvious (of course ! it wouldn't be a riddle otherwise !). It also isn't
      obvious how to write an algorithm to solve it (if it is for you - then
      you can take a break now, go have a coffee or someting to reward your
      uber intellect).</p><p>Instead of thinking about how to solve it, we can be lazy and use
      rules instead. So we don't attempt to solve it, we just state the
      problem in rules, and let the engine derive the solution.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6686"></a>10.1.5.2.&nbsp;Launching the example</h4></div></div></div><p>The supporting code is in the GolfingExample.java class. There is
      an inner class "Golfer" which represents a golf player, it has their
      name, position (1 to 4 meaning left to right), and their pants color, as
      simple properties.</p><pre class="programlisting">String[] names = new String[] { "Fred", "Joe", "Bob", "Tom" };
String[] colors = new String[] { "red", "blue", "plaid", "orange" };
int[] positions = new int[] { 1, 2, 3, 4 };
        
for ( int n = 0; n &lt; names.length; n++ ) {
    for ( int c = 0; c &lt; colors.length; c++ ) {
        for ( int p = 0; p &lt; positions.length; p++ ) {
            session.insert( new Golfer( names[n], colors[c], positions[p]) );
        }                
    }            
}      </pre><p>The above listing shows the interesting part of the supporting
      code. Note that we have arrays representing each name, color, and
      position. We then go through a nested loop inserting instances of Golfer
      - so in the working memory we will have all combinations of name, color
      and position. It is then the job of the rules to find the appropriate
      one.</p><p>Launching the code as a java application should yield the
      following output:</p><pre class="programlisting">Fred 1 orange
Joe 2 blue
Bob 4 plaid
Tom 3 red     </pre><p>This shows that the rule(s) have found a suitable solution.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6701"></a>10.1.5.3.&nbsp;The matching rule</h4></div></div></div><p>The solution in rules is quite simple, it is a single rule which
      expresses the constraints as stated in the riddle. Effectively, we can
      interpret the riddle as a series of constraints on our object model.
      Given that we have enough "combinations" in the working memory, all we
      have to do is express the constraints in a rule and the engine will
      match it with a solution (we don't really care how it does it, as long
      as it works !).</p><p>There is one rule in the solution, in golf.drl, called "find
      solution". The rule is made up of 5 patterns, with constraints that map
      to items in the riddle.</p><pre class="programlisting">$fred : Golfer( name == "Fred" )      </pre><p>In the above pattern, we are simply matching a Golfer who is
      called fred, and binding it to a variable called $fred. All that we know
      is that there is a golfer called fred.</p><pre class="programlisting">$joe : Golfer( name == "Joe",
               position == 2,
               position != $fred.position,
               color != $fred.color )      </pre><p>The next pattern says that we have a golfer named Joe, in position
      2 ("second in line"). Now, we also know that he must NOT be in the same
      position as fred (of course !) and have different color pants. So far,
      nothing that amazing.</p><pre class="programlisting">$bob : Golfer( name == "Bob",
               position != $fred.position,
               position != $joe.position,
               color == "plaid",
               color != $fred.color,
               color != $joe.color )      </pre><p>Refering to the above, we also know there is a golfer called Bob,
      who wears plaid pants - once again that all we know about him. but of
      course, we add in the constraints that he must be in a different
      position to fred, joe, and also have different colored pants.</p><pre class="programlisting">$tom : Golfer( name == "Tom",
               position != 1,
               position != 4,
               position != $fred.position,
               position != $joe.position,
               position != $bob.position,
               color != "orange,               
               color != $fred.color,
               color != $joe.color,
               color != $bob.color )      </pre><p>(referring to the above) We also know that there is a guy called
      Tom, who doesn't wear the Orange pants, AND he is not in position 1, or
      4. Of course we also add in the other constraints (he must be in a
      different position to the others so far, and have a different
      color).</p><pre class="programlisting">Golfer( position == ( $fred.position + 1 ),
        color == "blue",
        this in ( $joe, $bob, $tom ) )      </pre><p>Finally, we know that the golfer on the right of Fred (position +
      1), is in blue pants. We also add in the constraint that he must be
      either Joe, Bob or Tom (as Fred can't be beside himself, well he can I
      guess, but not in the sense we mean here !) - note the use of "this" to
      refer to the current pattern, we don't really care who "this" is, just
      who they are not. Maybe if Fred was really really happy they this
      wouldn't work, but lets assume otherwise for now.</p><p>Thats it ! We have expressed the rule as constraints that map to
      the ones expressed in the riddle, yet we haven't had to solve the
      riddle, the engine does that for us.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6730"></a>10.1.5.4.&nbsp;Conclustion</h4></div></div></div><p>This simple example shows how you can express a problem
      declaratively, and let the engine solve the problem for you, by making
      use of combinations. This is an often useful technique, as it allows you
      to express rules as a statement of the problem you are trying to
      solve.</p><p>Of course, care must be taken. Using combinatorics like this can
      cause performance problems when there are large numbers of facts (eg in
      this case, if there were a larger number of golfers, or colors/positions
      etc - possibilities). When the fact count grows, the combinations the
      engine has to deal with can explode exponentially, making this not very
      efficient. However, in cases where the rules are perhaps complex, the
      problem is hard, but the fact numbers are relatively low, this approach
      can be very very useful and help you solve problems that would otherwise
      be very hard.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6737"></a>10.1.6.&nbsp;Trouble Ticket</h3></div></div></div><p>The trouble ticket example shows how to use the duration attribute
    for temporal rules, and also includes an alternative version using a
    dsl.</p><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> TroubleTicket
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.TroubleTicketExample, org.drools.examples.TroubleTicketExampleWithDSL
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> TroubleTicket.drl, TroubleTicketWithDSL.dslr
<span class="bold"><strong>Objective:</strong></span> Show temporal rules in action
</pre><p>The trouble ticket example is based around the idea of raising a
    "ticket" (ie an issue) with a vendor (these are the vendors rules). Each
    customer has a subscription class assigned to it (eg Gold, Silver etc) and
    their class determines how the ticket is treated with respect to time, and
    escalating the issue. The normal drl version will be discussed here, but
    logically the DSL version is the same (it just uses a DSL defined language
    instead of the normal DRL).</p><p>We have 2 types of facts, Customer and Ticket. A Ticket belongs to
    one and only one customer. A Customer has a name and a "subscription" type
    (Gold, Silver or Platinum). A ticket also has a "status" - which
    determines (obviously) what state it is in. The state may be set
    externally, or by the rules engine (eg it starts out "New", and then the
    system user determines that it is "Done" at some later point). The rules
    exist to ensure that the tickets are escalated appropriately based on the
    customer subscription class.</p><p>Customers can choose Silver, Gold, or Platinum (in order of
    increasing responsiveness). Platinum subscriptions also come with a set of
    steak knives, and a personal butler to lodge the ticket for you (but
    obviously it costs more).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6764"></a>10.1.6.1.&nbsp;Executing the Example</h4></div></div></div><p>The example creates 4 customers, with their name and subscription
      class, it then creates 4 tickets for each of the customers, note that
      the ticket takes the customer in the constructor (that sets up the
      object relationship. The tickets and the customers are then inserted.
      Notice that we keep a fact handle - which we will use to notify the
      engine that that specific ticket changed later on. The last line has the
      all important fireAllRules(), which tells the engine to take action on
      the data it has.</p><div class="example"><a name="d0e6769"></a><p class="title"><b>Example&nbsp;10.52.&nbsp;Trouble Ticket Example : Creating and Inserting Facts</b></p><div class="example-contents"><pre class="programlisting">Customer a = new Customer( "A",
                           "Gold" );
Customer b = new Customer( "B",
                           "Platinum" );
Customer c = new Customer( "C",
                           "Silver" );
Customer d = new Customer( "D",
                           "Silver" );

Ticket t1 = new Ticket( a );
Ticket t2 = new Ticket( b );
Ticket t3 = new Ticket( c );
Ticket t4 = new Ticket( d );

session.insert( a );
session.insert( b );
session.insert( c );
session.insert( d );

session.insert( t1 );
session.insert( t2 );
FactHandle ft3 = session.insert( t3 );
session.insert( t4 );

session.fireAllRules();</pre></div></div><br class="example-break"><p>We have the "New Ticket" rule which has the highest priority
      (salience of 10 - the default is zero), The purpose of this is simply to
      log the fact that a new ticket has arrived in the system:</p><pre class="programlisting">rule "New Ticket"
 salience 10
 when
  customer : Customer( )
  ticket : Ticket( customer == customer, status == "New" )
  then
 System.out.println( "New : " + ticket );
end    </pre><p>Note that we are "joining" the ticket fact with the customer fact.
      It's not really needed in this case, as we don't do anything (yet) with
      the customer fact. If you look in the TroubleTicketExample.java, you
      will also see that the facts are being inserted into the engine - note
      that we assert BOTH Customer and Ticket object (even though the ticket
      belongs to a customer - this allows the engine to join the objects
      together how it wants - this is what is meant by "relational"
      programming - we let the rule engine define what the relationships are.
      For instance, although the code is structured so that a ticket belongs
      to a customer, we may be interested in looking at tickets from different
      customers of the same type in the future).</p><p>If we run the rules, we should expect that the "New Ticket" rule
      will be activated for all tickets, so looking at the audit log view (by
      opening the file which was saved automatically when the rules were
      run):</p><div class="figure"><a name="d0e6782"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/tt_audit_view.png" alt="Audit view"></div></div><p class="title"><b>Figure&nbsp;10.10.&nbsp;Audit view</b></p></div><br class="figure-break"><p>Referring to the above audit log, we can see each customer
      asserted, but nothing happens. As soon as the first ticket gets
      asserted, it joins it with the customer, and creates some activations:
      one is the "new ticket" rule, the other is for the appropriate priority
      (which we will show below). Note that items in the above view do not
      mean the rule fired at that point.</p><p>Also, don't forget to use "fireAllRules()" - a common mistake !
      (In this case we are using a statefull session, so this is
      necessary).</p><p>If we run the rules, we should expect that the "New Ticket" rule
      will be activated for all tickets, so looking at the audit log view (by
      opening the file which was saved automatically when the rules were
      run):</p><div class="figure"><a name="d0e6794"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/tt_audit_view.png" alt="Audit view"></div></div><p class="title"><b>Figure&nbsp;10.11.&nbsp;Audit view</b></p></div><br class="figure-break"><p>Referring to the above audit log, we can see each customer
      asserted, but nothing happens. As soon as the first ticket gets
      asserted, it joins it with the customer, and creates some activations:
      one is the "new ticket" rule, the other is for the appropriate priority
      (which we will show below). Note that items in the above view do not
      mean the rule fired at that point.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6802"></a>10.1.6.2.&nbsp;Platinum gets the best service</h4></div></div></div><p>All the wonderful platinum customers have to get great service, so
      first thing to note is that as soon as a ticket arrives, we escalate if
      it is for a platinum customer:</p><pre class="programlisting">rule "Platinum Priority"
 when
  customer : Customer( subscription == "Platinum" )
  ticket : Ticket( customer == customer, status == "New" )
 then;
  ticket.setStatus( "Escalate" );
  update( ticket );
end      </pre><p>Here we are joining Ticket to customer again (customer ==
      customer), but we are also checking that the customer is "Platinum".
      When this is the case, we set the ticket status to "Escalate" and call
      update (which tells the engine that the ticket has changed).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6811"></a>10.1.6.3.&nbsp;Silver and Gold</h4></div></div></div><p>For silver and gold class, its a similar story to platinum:</p><pre class="programlisting">rule "Silver Priority"
 duration 3000
 when
  customer : Customer( subscription == "Silver" )
  ticket : Ticket( customer == customer, status == "New" )
 then
  ticket.setStatus( "Escalate" );
  update( ticket );
end

rule "Gold Priority"
 duration 1000
 when
  customer : Customer( subscription == "Gold" )
  ticket : Ticket( customer == customer, status == "New" )
 then
  ticket.setStatus( "Escalate" );
  update( ticket );
end   </pre><p>In this case, note the use of "duration XXX" - XXX is the number
      of milliseconds to wait to check that this rule holds true. Should it do
      so, after XXX milliseconds, then the action takes effect. So in the
      above case, after 3 seconds the "Silver" priority kicks in, but after 1
      second "Gold" does. In both cases the tickets are escalated (just like
      with platinum. This is what we mean by temporal rules (rules that take
      effect over time).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6820"></a>10.1.6.4.&nbsp;Escalating</h4></div></div></div><p>The actual escalation of a ticket happens in a rule:</p><pre class="programlisting">rule "Escalate"
 when
  customer : Customer( )
  ticket : Ticket( customer == customer, status == "Escalate" )
 then
  sendEscalationEmail( customer, ticket );
end     </pre><p>In this case, the action is to call a function which sends an
      email (the function is defined down the bottom of the drl file). This
      rule reacts to the rules which update the ticket and set its status to
      escalate.</p></div><p>In the code that launches the example, we have a "sleep" to make
    sure all this happens (and print out the results). Note also that after
    the rules are fired, we modify the status of the Customer "C" to "Done" -
    and then tell the engine. This causes it to evaluate and fire the rule
    that looks for "tickets" that are "Done" (in which is just logs a
    message).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6831"></a>10.1.6.5.&nbsp;Running it</h4></div></div></div><p>Running the example (by launching the TroubleTicket.java class as
      an application) should yield the output:</p><pre class="programlisting">New : [Ticket [Customer D : Silver] : New]
New : [Ticket [Customer C : Silver] : New]
New : [Ticket [Customer B : Platinum] : New]
New : [Ticket [Customer A : Gold] : New]
Email : [Ticket [Customer B : Platinum] : Escalate]
[[ Sleeping 5 seconds ]]
Email : [Ticket [Customer A : Gold] : Escalate]
Done : [Ticket [Customer C : Silver] : Done]
Email : [Ticket [Customer D : Silver] : Escalate]
[[ awake ]]    </pre><div class="figure"><a name="d0e6838"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/tt_audit_firing.png" alt="Audit log"></div></div><p class="title"><b>Figure&nbsp;10.12.&nbsp;Audit log</b></p></div><br class="figure-break"><p>Referring to the above audit log, we can see the events as they
      happen. Once the rules start firing, the first items are the "Activation
      Executed" for the new tickets, as expected (they do nothing, just log
      the fact). Note the "Activation executed" item for the platinum ticket -
      that is the next one to go (remember it has the default salience, so it
      happens after the "New ticket" rule, but otherwise it is immediate -
      there is no "duration" delay for it). The platinum activation results in
      a Object modification (which is the escalation) - this in turn creates
      an activation record for the "escalate ticket" rule - which is what we
      wanted. Straight after that it executes the action to escalate the
      ticket.</p><p>The next event to occur is due to the: </p><pre class="programlisting">t3.setStatus( "Done" );

session.update( ft3,
                t3 );
</pre><p> in the code (outside of rules) - this simulates a customer
      service officer maarking a ticket as done (and of course, uses the fact
      handle we kept from before). This results in a cancelled activation (as
      we no longer have a New Silvert customer ticket - it is done) and a new
      activation to log the fact it was done.</p><p>In all the excitement, in parallel the engine has been watching
      the time pass, and it happens that the Gold tickets start to escalate,
      and then silver (as expected).</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6854"></a>10.1.7.&nbsp;Pricing Rule Decision Table Example</h3></div></div></div><p>The Pricing Rule decision table demonstrates the use of a decision
    table in a spreadsheet (XLS format) in calculating the retail cost of an
    insurance policy. The purpose of the set of rules provided is to calculate
    a base price, and an additional discount for a car driver applying for a
    specific policy. The drivers age, history and the policy type all
    contribute to what the basic premium is, and an additional chunk of rules
    deals with refining this with a subtractive percentage discount.</p><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Example Policy Pricing
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.PricingRuleDTExample
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> ExamplePolicyPricing.xls
<span class="bold"><strong>Objective:</strong></span> demonstrate spreadsheet based decision tables.    </pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6875"></a>10.1.7.1.&nbsp;Executing the example</h4></div></div></div><p>Open the PricingRuleDTExample.java and execute it as a Java
      application. It should produce the following console output:</p><pre class="programlisting">Cheapest possible
BASE PRICE IS: 120
DISCOUNT IS: 20     </pre><p>The code to the execute the example is very similar to the other
      examples. The rules are loaded, the facts inserted and a stateless
      session is used. What is different is how the rules are obtained:</p><pre class="programlisting">SpreadsheetCompiler compiler = new SpreadsheetCompiler();
String drl = compiler.compile(getSpreadsheetStream(), InputType.XLS);
</pre><p>Note the use of the SpreadsheetCompiler class. It is what takes
      the XLS (as a binary InputStream to the XLS file), and outputs ordinary
      DRL (which is then dealt with in the usual way). You can (if you like)
      also print out the DRL. If you use the BRMS, all this is of course taken
      care of for you.</p><p>There are 2 facts used in this example, Driver, and Policy. Both
      are used with their default values. The Driver is 30 years old, has had
      no prior claims and currently has a risk profile of LOW. The Policy
      being applied for is COMPREHENSIVE, and the policy has not yet been
      approved.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6890"></a>10.1.7.2.&nbsp;The decision table</h4></div></div></div><p>In this decision table, each row is a rule, and each column is a
      condition or an action.</p><div class="figure"><a name="d0e6895"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/DT_Config.png" alt="Decision table configuration"></div></div><p class="title"><b>Figure&nbsp;10.13.&nbsp;Decision table configuration</b></p></div><br class="figure-break"><p>Referring to the above, we have the RuleSet declaration, which
      provides the package name. There are also other optional items you can
      have here, such as Variables for global variables, and Imports for
      importing classes. In this case, the namespace of the rules is the same
      as the fact classes we are using, so we can omit it.</p><p>Moving further down, we can see the RuleTable declaration. The
      name after this (Pricing bracket) is used as the prefix for all the
      generated rules. Below that, we have CONDITION or ACTION - this
      indicates the purpose of the column (ie does it form part of the
      condition, or an action of a rule that will be generated).</p><p>You can see there is a Driver which is spanned across 3 cells,
      this means the template expressions below it apply to that fact. So we
      look at the drivers age range (which uses $1 and $2 with comma separated
      values), locationRiskProfile, and priorClaims in the respective columns.
      In the action columns, we are setting the policy base price, and then
      logging a message.</p><div class="figure"><a name="d0e6907"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/DT_Table1.png" alt="Base price calculation"></div></div><p class="title"><b>Figure&nbsp;10.14.&nbsp;Base price calculation</b></p></div><br class="figure-break"><p>Referring to the above, we can see there are broad category
      brackets (indicated by the comment in the left most column). As we know
      the details of our driver and their policy, we can tell (with a bit of
      thought) that they should match row number 18, as they have no prior
      accidents, and are 30 years old. This gives us a base price of
      120.</p><div class="figure"><a name="d0e6915"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/DT_Table2.png" alt="Discount calculation"></div></div><p class="title"><b>Figure&nbsp;10.15.&nbsp;Discount calculation</b></p></div><br class="figure-break"><p>Referring to the above, we are seeing if there is any discount we
      can give our driver. Based on the Age bracket, number of priot claims,
      and the policy type, a discount is provided. In our case, the drive is
      3, with no priors, and they are applying for COMPREHENSIVE, this means
      we can give a discount of 20%. Note that this is actually a separate
      table, but in the same worksheet. This different templates apply.</p><p>It is important to note that decision tables generate rules, this
      means they aren't simply top down logic, but more a means to capture
      data that generate rules (this is a subtle difference that confuses some
      people). The evaluation of the rules is not "top down" necessarily, all
      the normal indexing and mechanics of the rule engine still apply.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6925"></a>10.1.8.&nbsp;Shopping Example</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span>Shopping Example
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.ShoppingExample
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> Shopping.drl
<span class="bold"><strong>Objective:</strong></span> demonstrate truth maintenance, accumulate
</pre><p>The shopping example simulates a very simple shopping cart type
    application, where the idea is to track a users purchases in a stateful
    session, and apply discounts as appropriate.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6946"></a>10.1.8.1.&nbsp;Running the example</h4></div></div></div><p>The following is a listing of the interesting parts that are used
      to launch the example:</p><pre class="programlisting">Customer mark = new Customer( "mark",
                              0 );
session.insert( mark );
Product shoes = new Product( "shoes",
                             60 );
session.insert( shoes );
Product hat = new Product( "hat",
                           60 );
session.insert( hat );
session.insert( new Purchase( mark,
                              shoes ) );
FactHandle hatPurchaseHandle = session.insert( new Purchase( mark,
                                                             hat ) );
session.fireAllRules();
session.retract( hatPurchaseHandle );
System.out.println( "Customer mark has returned the hat" );
session.fireAllRules();      </pre><p>Refering the the above listing, we can see there is a Customer
      ("mark"), and there are 2 Products ("shoes" and "hat") which are
      available for Purchase. In this case, a Purchase combines a customer
      with a product (and a product has a price attribute).</p><p>Note that after we fireAllRules(), we then retract the purchase of
      a hat (but leave the purchase of shoes in). Running the example as a
      java application should see the following output:</p><pre class="programlisting">Customer mark just purchased hat
Customer mark just purchased shoes
Customer mark now has a shopping total of 120.0
Customer mark now has a discount of 10
Customer mark has returned the hat
Customer mark now has a discount of 0      </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6959"></a>10.1.8.2.&nbsp;Discounts and purchases</h4></div></div></div><p>We want to give discounts to customers who purchase stuff of
      enough value. This discount could also be removed should the customer
      decide not to purchase enough to fall within the threshold.</p><pre class="programlisting">rule "Purchase notification"
    salience 10

 when
  $c : Customer()
  $p : Purchase( customer == $c)	    
 then
     System.out.println( "Customer " + $c.name + " just purchased " + $p.product.name );
end 

rule "Discount removed notification"
 when
     $c : Customer()
  not Discount( customer == $c )
 then
  $c.discount = 0 ;
  System.out.println( "Customer " + $c.name + " now has a discount of " + $c.discount );
end

rule "Discount awarded notification"
 when
     $c : Customer()
     $d : Discount( customer == $c )
 then
  System.out.println( "Customer " + $c.name + " now has a discount of " + $d.amount );
end      </pre><p>The "Purchase notification" rule simply makes note of the purchase
      event for a given customer. The "Discount removed notification" rule
      removes the customer discount (by checking for the non existence of a
      discount for that customer). The "Discount awarded notification" simply
      makes not of the fact that the discount was applied.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6968"></a>10.1.8.3.&nbsp;Calculating the discount</h4></div></div></div><p>Calculating the discount is done with a single rule, using the
      higher order logic of "accumulate".</p><pre class="programlisting">rule "Apply 10% discount if total purcahses is over 100"
 no-loop true
 dialect "java"
    when
      $c : Customer()
      $i : Double(doubleValue  &gt; 100) from accumulate ( Purchase( customer == $c, $price : product.price ), 
                                                            sum( $price ) )
    then
      $c.setDiscount( 10 );
      insertLogical( new Discount($c, 10) );
      System.out.println( "Customer " + $c.getName() + " now has a shopping total of " + $i );
end      </pre><p>An interesting part of this rule is the "accumulate": this is
      saying to accumulate a total (sum) of the $price of a product
      (product.price) for all Purchase facts that belong to the customer ($c).
      The result of this is a Double. The rule then checks to see if this
      total is greater then 100. If it is, it applies the discount (of 10),
      and then inserts a logical fact of the Discount object.</p><p>The purpose of the logical insertion of the Discount, is to
      automatically retract the Discount object should the total of the
      purchases not add up to &gt; 100 (when the LHS is no longer satisified,
      restract the resulting logical assertions - this is what is meant by
      "truth maintenance"). The act of inserting the Discount, causes the
      "Discount awarded notification" rule to activate. However, should the
      discount fact be retracted, the "Discount removed notification" will
      activate, resulting in the customers discount being wiped out. In the
      example you can see this happen, as after the first fireAllRules(), a
      purchase is retracted, causing the total to fall below 100, which means
      the conditions that satisfied the "Apply 10% discount..." rule no longer
      apply, hence the logical fact of "Discount" is automatically
      retracted.</p></div></div><div class="section" lang="en"><div class="titlepage"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6980"></a>10.1.9.1.&nbsp;Pet Store Example</h4></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Pet Store 
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.PetStore
<span class="bold"><strong>Type:</strong></span> Java application
<span class="bold"><strong>Rules file:</strong></span> PetStore.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrate use of Agenda Groups, Global Variables and integration with a GUI (including callbacks from within the Rules)
</pre><p>The Pet Store example shows how to integrate Rules with a GUI (in
      this case a Swing based Desktop application). Within the rules file, it
      shows how to use agenda groups and auto-focus to control which of a set
      of rules is allowed to fire at any given time. It also shows mixing of
      Java and MVEL dialects within the rules, the use of accumulate functions
      and calling of Java functions from within the ruleset.</p><p>Like the rest of the the samples, all the Java Code is contained
      in one file. The PetStore.java contains the following principal classes
      (in addition to several minor classes to handle Swing Events)</p><p>
        </p><div class="itemizedlist"><ul type="disc"><li><p><span class="italic"> Petstore</span> - containing
            the main() method that we will look at shortly.</p></li><li><p><span class="italic">PetStoreUI</span> - responsible
            for creating and displaying the Swing based GUI. It contains
            several smaller classes , mainly for responding to various GUI
            events such as mouse and button clicks.</p></li><li><p><span class="italic">TabelModel</span> - for holding
            the table data. Think of it as a JavaBean that extends the Swing
            AbstractTableModel class.</p></li><li><p><span class="italic">CheckoutCallback</span> - Allows
            the GUI to interact with the Rules.</p></li><li><p><span class="italic">Ordershow </span> - the items
            that we wish to buy.</p></li><li><p><span class="italic">Purchase</span> - Details of the
            order and the products we are buying.</p></li><li><p><span class="italic">Product</span> - JavaBean
            holding details of the product available for purchase, and it's
            price.</p></li></ul></div><p>
      </p><p>Much of the Java code is either JavaBeans (simple enough to
      understand) or Swing based. We will touch on some Swing related points
      in the this tutorial , but a good place to get more Swing component
      information is <a class="ulink" href="???" target="_top"><code class="uri">http://java.sun.com/docs/books/tutorial/uiswing/</code>available
      at the Sun Swing website.<font color="red">&lt;citebiblioid&gt;&lt;/citebiblioid&gt;</font></a></p><p>There are two important Rules related pieces of Java code in
      <span class="italic">Petstore.java</span>.</p><p>
        </p><div class="example"><a name="d0e7056"></a><p class="title"><b>Example&nbsp;10.53.&nbsp;Creating the PetStore RuleBase - extract from PetStore.java
          main() method</b></p><div class="example-contents"><pre class="programlisting">PackageBuilder builder = new PackageBuilder();
builder.addPackageFromDrl( new InputStreamReader( 
PetStore.class.getResourceAsStream( "PetStore.drl" ) ) );
RuleBase ruleBase = RuleBaseFactory.newRuleBase();
ruleBase.addPackage( builder.getPackage() );

//RuleB
Vector stock = new Vector();
stock.add( new Product( "Gold Fish",5 ) );
stock.add( new Product( "Fish Tank", 25 ) );
stock.add( new Product( "Fish Food", 2 ) );

//The callback is responsible for populating working memory and
// fireing all rules
PetStoreUI ui = new PetStoreUI( stock, new CheckoutCallback( ruleBase ) );
ui.createAndShowGUI();
</pre></div></div><p><br class="example-break">
      </p><p>This code above loads the rules (drl) file from the classpath.
      Unlike other examples where the facts are asserted and fired straight
      away, this example defers this step to later. The way it does this is
      via the second last line where the PetStoreUI is created using a
      constructor the passes in the Vector called stock containing products ,
      and an instance of the CheckoutCallback class containing the RuleBase
      that we have just loaded.</p><p>The actual Javacode that fires the rules is within the <span class="italic">CheckoutCallBack.checkout()</span> method. This is
      triggered (eventually) when the 'Checkout' button is pressed by the
      user.</p><div class="example"><a name="d0e7069"></a><p class="title"><b>Example&nbsp;10.54.&nbsp;Firing the Rules - extract from the CheckOutCallBack.checkout()
        method</b></p><div class="example-contents"><pre class="programlisting">public String checkout(JFrame frame, List items) throws FactException {           
    Order order = new Order();

    //Iterate through list and add to cart
    for ( int i = 0; i &lt; items.size(); i++ ) {
        order.addItem( new Purchase( order, (Product) items.get( i ) ) );
    }

    //add the JFrame to the ApplicationData to allow for user interaction
    WorkingMemory workingMemory = ruleBase.newStatefulSession();
    workingMemory.setGlobal( "frame", frame );
    workingMemory.setGlobal( "textArea",  this.output );

    workingMemory.insert( new Product( "Gold Fish", 5 ) );
    workingMemory.insert( new Product( "Fish Tank", 25 ) );
    workingMemory.insert( new Product( "Fish Food",  2 ) );
    workingMemory.insert( new Product( "Fish Food Sample", 0 ) );            
           
    workingMemory.insert( order );
    workingMemory.fireAllRules();

    //returns the state of the cart
    return order.toString();
}
</pre></div></div><br class="example-break"><p>Two items get passed into this method; A handle to the JFrame
      Swing Component surrounding the output text frame (bottom of the GUI if
      / when you run the component). The second item is a list of order items;
      this comes from the TableModel the stores the information from the
      'Table' area at the top right section of the GUI.</p><p>The <span class="italic">for()</span> loop transforms the
      list of order items coming from the GUI into the Order JavaBean (also
      contained in the PetStore.java file). Note that it would be possible to
      refer to the Swing dataset directly within the rules, but it is better
      coding practice to do it this way (using Simple Java Objects). It means
      that we are not tied to Swing if we wanted to transform the sample into
      a Web application.</p><p>It is important to note that <span class="bold"><strong>all state in
      this example is stored in the Swing components, and that the rules are
      effectively stateless. </strong></span>Each time the 'Checkout' button is
      pressed, this code copies the contents of the Swing
      <span class="emphasis"><em>TableModel</em></span> into the Session / Working
      Memory.</p><p>Within this code, there are nine calls to the working memory. The
      first of these creates a new workingMemory (statefulSession) from the
      Rulebase - remember that we passed in this Rulebase when we created the
      CheckoutCallBack class in the <span class="italic">main()</span>
      method. The next two calls pass in two objects that we will hold as Gl
      obal variables in the rules - the Swing text area and Swing frame that
      we will use for writing messages later.</p><p>More inserts put information on products into the working memory,
      as well as the order list. The final call is the standard e <span class="italic">fireAllRules()</span>. Next, we look at what this
      method causes to happen within the Rules file.</p><p>
        </p><div class="example"><a name="d0e7101"></a><p class="title"><b>Example&nbsp;10.55.&nbsp;Package, Imports , Globals and Dialect - extract (1) from
          PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">package org.drools.examples

import org.drools.WorkingMemory
import org.drools.examples.PetStore.Order
import org.drools.examples.PetStore.Purchase
import org.drools.examples.PetStore.Product
import java.util.ArrayList
import javax.swing.JOptionPane;

import javax.swing.JFrame 
        
global JFrame frame 
global javax.swing.JTextArea textArea
 
dialect "mvel"
</pre></div></div><p><br class="example-break">
      </p><p>The first part of the <span class="italic">PetStore.drl</span> file contains the standard package
      and import statement to make various Java classes available to the
      rules. We've seen the dialect been defaulted to "mvel" before in other
      examples. What is new are the two globals <span class="emphasis"><em>frame and textArea.
      </em></span>These hold references to the Swing JFrame and Textarea
      components that were previous passed by the Java code calling the
      <span class="emphasis"><em>setGlobal() </em></span>method. Unlike normal variables in
      Rules , which expire as soon as the rule has fired, Global variables
      retain their value for the lifetime of the (Stateful in this case)
      Session.</p><p>The next extract (below) is from the <span class="bold"><strong>end</strong></span> of the PetStore.drl file. It contains two
      functions that are referenced by the rules that we will look at
      shortly.</p><p>
        </p><div class="example"><a name="d0e7125"></a><p class="title"><b>Example&nbsp;10.56.&nbsp;Java Functions in the Rules - extract (2) from
          PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">function void doCheckout(JFrame frame, WorkingMemory workingMemory) {
    Object[] options = {"Yes",
                        "No"};
                            
    int n = JOptionPane.showOptionDialog(frame,
                                         "Would you like to checkout?",
                                         "",
                                         JOptionPane.YES_NO_OPTION,
                                         JOptionPane.QUESTION_MESSAGE,
                                         null,
                                         options,
                                         options[0]);

    if (n == 0) {
        workingMemory.setFocus( "checkout" );
    }   
}

function boolean requireTank(JFrame frame, WorkingMemory workingMemory, Order order, Product fishTank, int total) {
    Object[] options = {"Yes",
                        "No"};
                            
    int n = JOptionPane.showOptionDialog(frame,
                                         "Would you like to buy a tank for your " + total + " fish?",
                                         "Purchase Suggestion",
                                         JOptionPane.YES_NO_OPTION,
                                         JOptionPane.QUESTION_MESSAGE,
                                         null,
                                         options,
                                         options[0]);
                                             
    System.out.print( "SUGGESTION: Would you like to buy a tank for your "
                      + total + " fish? - " );

    if (n == 0) {
        Purchase purchase = new Purchase( order, fishTank );
        workingMemory.insert( purchase );
        order.addItem( purchase );
        System.out.println( "Yes" );
    } else {
        System.out.println( "No" );
    }      
    return true;
}
</pre></div></div><p><br class="example-break">
      </p><p>Having these functions in the rules file makes the PetStore sample
      more compact - in real life you probably have the functions in a file of
      their own (within the same rules package), or as a static method on a
      standard Java class (and import them using the <span class="bold"><strong>import function my.package.Foo.hello
      </strong></span>syntax).</p><p>The above functions are</p><div class="itemizedlist"><ul type="disc"><li><p><span class="italic">doCheckout()</span> - Displays a
            dialog asking the user if they wish to checkout. If they do, focus
            is set to the <span class="italic">checkOut</span>
            agenda-group, allowing rules in that group to (potentially)
            fire.</p></li><li><p><span class="italic">requireTank()</span> - Displays
            a dialog asking the user if they wish to buy a tank. If so, a new
            FishTank <span class="italic">Product</span> added to the
            orderlist in working memory.</p></li></ul></div><p>We'll see later the rules that call these functions.The
      next set of examples are from the PetStore rules themselves. The first
      extract is the one that happens to fire first (partly because it has the
      <span class="italic">auto-focus</span> attibute set to
      true).</p><div class="example"><a name="d0e7160"></a><p class="title"><b>Example&nbsp;10.57.&nbsp;Putting each (individual) item into working memory - extract
          (3) from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">// insert each item in the shopping cart into the Working Memory 
rule "Explode Cart"
    agenda-group "init"
    auto-focus true    
    salience 10
    dialect "java"
when
    $order : Order( grossTotal == -1 )
    $item : Purchase() from $order.items
then
   insert( $item );
   drools.setFocus( "show items" );
   drools.setFocus( "evaluate" );
end

</pre></div></div><p><br class="example-break"></p><p>This rule matches against all orders that do not yet have an
      Order.grossTotal calculated . It loops for each purchase item in that
      order. Some of the <span class="italic">Explode Cart</span> Rule
      should be familiar ; the rule name, the salience (suggesting of the
      order that the rules should be fired in) and the dialect set to
      <span class="italic">java</span>. There are three new
      items:</p><p>
        </p><div class="itemizedlist"><ul type="disc"><li><p class="bold"><span class="bold"><strong>agenda-group "init"
            </strong></span>- the name of the agenda group. In this case, there is
            only one rule in the group. However, nothing in Java code / nor a
            rule sets the focus to this group , so it relies on the next
            attibute for it's chance to fire.</p></li><li><p><span class="bold"><strong>auto-focus true - </strong></span>This is
            the only rule in the sample, so when <span class="italic">fireAllRules()</span> is called from within the
            Java code, this rule is the first to get a chance to fire.</p></li><li><p><span class="bold"><strong>drools.setFocus() </strong></span>This sets
            the focus to the <span class="italic">show items </span>and
            <span class="italic">evaluate</span> agenda groups in turn
            , giving their rules a chance to fire. In practice , we loop
            through all items on the order, inserting them into memory, then
            firing the other rules after each insert.</p></li></ul></div><p>
      </p><p>The next two listings shows the rules within the <span class="italic">show items </span>and <span class="italic">evaluate</span> agenda groups. We look at them in the
      order that they are called.</p><div class="example"><a name="d0e7209"></a><p class="title"><b>Example&nbsp;10.58.&nbsp;Show Items in the GUI extract (4) from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">rule "Show Items"
    agenda-group "show items"
    dialect "mvel"
when
    $order : Order( )
    $p : Purchase( order == $order )
then
   textArea.append( $p.product + "\n");
end
</pre></div></div><p><br class="example-break"></p><p>The <span class="italic">show items</span> agenda-group has
      only one rule, also called <span class="italic">Show Items</span>
      (note the difference in case). For each purchase on the order currently
      in the working memory (session) it logs details to the text area (at the
      bottom of the GUI). The <span class="italic">textArea</span>
      variable used to do this is one of the Global Variables we looked at
      earlier.</p><p>The <span class="italic">evaluate</span> Agenda group also
      gains focus from the <span class="italic">explode cart
      </span>rule above. This Agenda group has two rules (below) <span class="italic">Free Fish Food Sample </span> and <span class="italic">Suggest Tank</span>.</p><p>
        </p><div class="example"><a name="d0e7241"></a><p class="title"><b>Example&nbsp;10.59.&nbsp;Evaluate Agenda Group extract (5) from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">// Free Fish Food sample when we buy a Gold Fish if we haven't already  bought 
// Fish Food and dont already have a Fish Food Sample
rule "Free Fish Food Sample"
    agenda-group "evaluate"
    dialect "mvel"
when
    $order : Order()
    not ( $p : Product( name == "Fish Food") &amp;&amp; Purchase( product == $p ) )
    not ( $p : Product( name == "Fish Food Sample") &amp;&amp; Purchase( product == $p ) )
    exists ( $p : Product( name == "Gold Fish") &amp;&amp; Purchase( product == $p ) )
    $fishFoodSample : Product( name == "Fish Food Sample" );
then
    System.out.println( "Adding free Fish Food Sample to cart" );
    purchase = new Purchase($order, $fishFoodSample);
    insert( purchase );
    $order.addItem( purchase ); 
end

// Suggest a tank if we have bought more than 5 gold fish and dont already have one
rule "Suggest Tank"
    agenda-group "evaluate"
    dialect "java"
when
    $order : Order()
    not ( $p : Product( name == "Fish Tank") &amp;&amp; Purchase( product == $p ) )
    ArrayList( $total : size &gt; 5 ) from collect( Purchase( product.name == "Gold Fish" ) )
    $fishTank : Product( name == "Fish Tank" )
then
    requireTank(frame, drools.getWorkingMemory(), $order, $fishTank, $total); 
end
</pre></div></div><p><br class="example-break">
      </p><p>The <span class="italic">Free Fish Food Sample</span> rule
      will only fire if</p><p>
        </p><div class="itemizedlist"><ul type="disc"><li><p>We <span class="italic">don't </span>already have any
            fish food.</p></li><li><p>We <span class="italic">don't</span> already have a
            free fish food sample.</p></li><li><p>We <span class="italic">do</span> have a Gold Fish in
            our order.</p></li></ul></div><p>
      </p><p>If the rule does fire, it creates a new product (Fish Food
      Sample), and adds it to the Order in working memory.</p><p>The <span class="italic">Suggest Tank</span> rule will only
      fire if</p><p>
        </p><div class="itemizedlist"><ul type="disc"><li><p>We <span class="italic">don't </span>already have a
            Fish Tank in our order</p></li><li><p>If we <span class="italic">can</span> find more than
            5 Gold Fish Products in our order.</p></li></ul></div><p>
      </p><p>If the rule does fire, it calls the <span class="italic">requireTank</span>() function that we looked at
      earlier (showing a Dialog to the user, and adding a Tank to the order /
      working memory if confirmed). When calling the <span class="italic">requireTank</span>() function the rule passes the
      global <span class="italic">frame</span> variable so that the
      function has a handle to the Swing GUI.</p><p>The next rule we look at is <span class="italic">do
      checkout.</span></p><div class="example"><a name="d0e7312"></a><p class="title"><b>Example&nbsp;10.60.&nbsp;Doing the Checkout - extract (6) from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">rule "do checkout"
    dialect "java"
    when
    then
        doCheckout(frame, drools.getWorkingMemory());
end</pre></div></div><p><br class="example-break"></p><p>The <span class="italic">do checkout</span> rule has
      <span class="bold"><strong>no agenda-group set and no auto-focus
      attribute</strong></span>. As such, is is deemed part of the default (MAIN)
      agenda-group - the same as the other non PetStore examples where agenda
      groups are not used. This group gets focus by default when all the
      rules/agenda-groups that explicity had focus set to them have run their
      course.</p><p>There is no LHS to the rule, so the RHS will always call the
      <span class="italic">doCheckout</span>() function. When calling
      the <span class="italic">doCheckout</span>() function the rule
      passes the global <span class="italic">frame</span> variable so
      the function has a handle to the Swing GUI. As we saw earlier, the
      <span class="italic">doCheckout</span>() function shows a
      confirmation dialog to the user. If confirmed, the function sets the
      focus to the <span class="italic">checkout</span> agenda-group,
      allowing the next lot of rules to fire.</p><p>
        </p><div class="example"><a name="d0e7344"></a><p class="title"><b>Example&nbsp;10.61.&nbsp;Checkout Rules- extract (7) from PetStore.drl</b></p><div class="example-contents"><pre class="programlisting">rule "Gross Total"
    agenda-group "checkout"
    dialect "mvel"
when
   $order : Order( grossTotal == -1)
   Number( total : doubleValue ) from accumulate( Purchase( $price : product.price ),
                 sum( $price ) )
then
    modify( $order ) { grossTotal = total };
    textArea.append( "\ngross total=" + total + "\n" );
end

rule "Apply 5% Discount"
    agenda-group "checkout"
dialect "mvel"
when
   $order : Order( grossTotal &gt;= 10 &amp;&amp; &lt; 20 )
then
   $order.discountedTotal = $order.grossTotal * 0.95;
   textArea.append( "discountedTotal total=" + $order.discountedTotal + "\n" );
end


rule "Apply 10% Discount"
    agenda-group "checkout"
dialect "mvel"
when
   $order : Order( grossTotal &gt;= 20 )
then
   $order.discountedTotal = $order.grossTotal * 0.90;
   textArea.append( "discountedTotal total=" + $order.discountedTotal + "\n" );
end
</pre></div></div><p><br class="example-break">
      </p><p>There are three rules in the <span class="italic">checkout</span> agenda-group</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>Gross Total </strong></span> - if we
            haven't already calculated the gross total, accumulates the
            product prices into a total, puts this total into working memory,
            and displays it via the Swing TextArea (using the <span class="italic">textArea </span>global variable yet
            again).</p></li><li><p><span class="bold"><strong>Apply 5% Discount</strong></span> - if our
            gross total is between 10 and 20, then calculate the discounted
            total and add it to working memory / display in the text
            area.</p></li><li><p><span class="bold"><strong>Apply 10% Discount</strong></span> - if our
            gross total is equal to or greater than 20, calculate the
            discounted total and add it to working memory / display in the
            text area.</p></li></ul></div><p>Now we've run through what happens in the code, lets
      have a look at what happens when we run the code for real. The <span class="italic">PetStore.java </span>example contains a <span class="italic">main()</span> method, so it can be run as a standard
      Java application (either from the command line or via the IDE). This
      assumes you have your classpath set correctly (see the start of the
      examples section for more information).s.</p><p>The first screen that we see is the Pet Store Demo. It has a List
      of available products (top left) , an empty list of selected products
      (top right), checkout and reset buttons (middle) and an empty system
      messages area (bottom).</p><div class="figure"><a name="d0e7385"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/1-PetStore-Start-Screen.png" alt="Figure 1 - PetStore Demo just after Launch"></div></div><p class="title"><b>Figure&nbsp;10.16.&nbsp;Figure 1 - PetStore Demo just after Launch</b></p></div><p><br class="figure-break">To get to this point, the following things have
      happened:</p><div class="orderedlist"><ol type="1"><li><p>The <span class="italic">main()</span> method has run
            and loaded the RuleBase <span class="bold"><strong>but not yet fired
            the rules</strong></span>. This is the only rules related code to run
            so far.</p></li><li><p>A new <span class="italic">PetStoreUI</span> class is
            created and given a handle to the RuleBase (for later use).</p></li><li><p>Various Swing Components do their stuff, and the above
            screen is shown and <span class="bold"><strong>waits for user
            input</strong></span>.</p></li></ol></div><p>Clicking on various products from the list might give
      you a screen similar to the one below.</p><div class="figure"><a name="d0e7417"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/2-stock-added-to-order-list.png" alt="Figure 2 - PetStore Demo with Products Selected"></div></div><p class="title"><b>Figure&nbsp;10.17.&nbsp;Figure 2 - PetStore Demo with Products Selected</b></p></div><p><br class="figure-break">Note that <span class="bold"><strong>no rules code has been fired
      here</strong></span>. This is only swing code, listening for the mouse click
      event, and added the clicked product to the
      <span class="emphasis"><em>TableModel</em></span> object for display in the top right hand
      section (as an aside , this is a classic use of the Model View
      Controller - MVC - design pattern).</p><p>It is only when we press the <span class="bold"><strong>Checkout</strong></span> that we fire our business rules, in
      roughly the same order that we walked through the code earlier.</p><p>
        </p><div class="orderedlist"><ol type="1"><li><p>The <span class="italic">CheckOutCallBack.checkout()</span> method is
            called (eventually) by the Swing class waiting for the click on
            the checkout button. This inserts the data from the
            <span class="emphasis"><em>TableModel</em></span> object (top right hand side of the
            GUI), and handles from the GUI into the session / working memory.
            It then fires the rules.</p></li><li><p>The <span class="italic">Explode Cart</span> rule is
            the first to fire, given that has <span class="italic">auto-focus </span>set to true. It loops through
            all the products in the cart, makes sure the products are in the
            working memory, then gives the <span class="italic">Show
            Items</span> and <span class="italic">Evaluation</span>
            agenda groups a chance to fire. The rules in these groups, add the
            contents of the cart to the text area (bottom), decide whether or
            not to give us free fish food and whether to ask if we want to buy
            a fish tank (Figure 3 below).</p></li></ol></div><p>

        </p><div class="figure"><a name="d0e7463"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/3-purchase-suggestion.png" alt="Figure 3 - Do we want to buy a fish tank?"></div></div><p class="title"><b>Figure&nbsp;10.18.&nbsp;Figure 3 - Do we want to buy a fish tank?</b></p></div><p><br class="figure-break">

        </p><div class="orderedlist"><ol type="1"><li><p>The <span class="italic">Do Checkout</span> rule is
            the next to fire as it (a) No other agenda group currently has
            focus and (b) it is part of the default (MAIN) agenda group. It
            always calls the<span class="italic"> doCheckout() function
            </span>which displays a 'Would you like to Checkout?' Dialog
            Box.</p></li><li><p>The <span class="italic">doCheckout() function</span>
            sets the focus to the <span class="italic">checkout
            </span>agenda-group, giving the rules in that group the option
            to fire.</p></li><li><p>The rules in the the <span class="italic">checkout</span> agenda-group, display the
            contents of the cart and apply the appropriate discount.</p></li><li><p><span class="bold"><strong>Swing then waits for user
            input</strong></span> to either checkout more products (and to cause
            the rules to fire again) or to close the GUI - Figure 4
            below.</p></li></ol></div><p>
      </p><p>
        </p><div class="figure"><a name="d0e7503"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/4-Petstore-final-screen.png" alt="Figure 4 - Petstore Demo after all rules have fired."></div></div><p class="title"><b>Figure&nbsp;10.19.&nbsp;Figure 4 - Petstore Demo after all rules have fired.</b></p></div><p><br class="figure-break">
      </p><p>Should we choose, we could add more System.out calls to
      demonstrate this flow of events. The current output of the console fo
      the above sample is as per the listing below.</p><p>
        </p><div class="example"><a name="d0e7514"></a><p class="title"><b>Example&nbsp;10.62.&nbsp;Console (System.out) from running the PetStore GUI</b></p><div class="example-contents"><pre class="programlisting">Adding free Fish Food Sample to cart 
SUGGESTION: Would you like to buy a tank for your 6 fish? - Yes</pre></div></div><p><br class="example-break">
      </p><p>Todo : Add Audit and Agenda Views for this sample.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7522"></a>10.1.10.&nbsp;Honest Politician Example</h3></div></div></div><p>The honest politician example demonstrates truth maintenance with
    logical assertions, the basic premise is that an object can only exist
    while a statement is true. A rule's consequence can logical insert an
    object with the insertLogical method, this means the object will only
    remain in the working memory as long as the rule that logically inserted
    it remains true, when the rule is no longer true the object is
    automatically retracted.</p><p>In this example there is Politician class with a name and a boolean
    value for honest state, four politicians with honest state set to true are
    inserted.</p><div class="example"><a name="d0e7530"></a><p class="title"><b>Example&nbsp;10.63.&nbsp;Politician Class</b></p><div class="example-contents"><pre class="programlisting">public class Politician {
    private String name;
    private boolean honest;
    ...
}</pre></div></div><p><br class="example-break"></p><div class="example"><a name="d0e7535"></a><p class="title"><b>Example&nbsp;10.64.&nbsp;Honest Politician Example Execution</b></p><div class="example-contents"><pre class="programlisting">Politician blair  = new Politician("blair", true);
Politician bush  = new Politician("bush", true);
Politician chirac  = new Politician("chirac", true);
Politician schroder   = new Politician("schroder", true);
        
session.insert( blair );
session.insert( bush );
session.insert( chirac );
session.insert( schroder );

session.fireAllRules();</pre></div></div><p><br class="example-break">The console out shows that while there is atleast one honest
    polician democracy lives, however as each politician is in turn corrupted
    by an evil corporation, when all politicians are dishonest democracy is
    dead.</p><div class="example"><a name="d0e7541"></a><p class="title"><b>Example&nbsp;10.65.&nbsp;Honest Politician Example Console Output</b></p><div class="example-contents"><pre class="programlisting">Hurrah!!! Democracy Lives
I'm an evil corporation and I have corrupted schroder
I'm an evil corporation and I have corrupted chirac
I'm an evil corporation and I have corrupted bush
I'm an evil corporation and I have corrupted blair
We are all Doomed!!! Democracy is Dead
</pre></div></div><p><br class="example-break">As soon as there is one ore more honest politcians in the
    working memory a new Hope object is logically asserted, this object will
    only exist while there is atleast one or more honest politicians, the
    moment all politicians are dishonest then the Hope object will be
    automatically retracted. This rule is given a salience of 10 to make sure
    it fires before any other rules, as at this stage the "Hope is Dead" rule
    is actually true.</p><div class="example"><a name="d0e7547"></a><p class="title"><b>Example&nbsp;10.66.&nbsp;Honest Politician Example : Rule "We have an honest
      politician"</b></p><div class="example-contents"><pre class="programlisting">rule "We have an honest Politician"
    salience 10
    when
        exists( Politician( honest == true ) )
    then
        insertLogical( new Hope() );
end</pre></div></div><br class="example-break"><p>As soon as a Hope object exists the "Hope Lives" rule matches, and
    fires, it has a salience of 10 so that it takes priority over "Corrupt the
    Honest".</p><div class="example"><a name="d0e7554"></a><p class="title"><b>Example&nbsp;10.67.&nbsp;Honest Politician Example : Rule "Hope Lives"</b></p><div class="example-contents"><pre class="programlisting">rule "Hope Lives"
    salience 10
    when
        exists( Hope() )
    then
        System.out.println("Hurrah!!! Democracy Lives");
end</pre></div></div><br class="example-break"><p>Now that hope exists and we have, at the start, four honest
    politicians we have 4 activations for this rule all in conflict. This rule
    iterates over those rules firing each one in turn, corrupting each
    politician so that they are no longer honest. When all four politicians
    have been corrupted we have no politicians with the property "honest ==
    true" thus the rule "We hvae an honest Politician" is no longer true and
    the object it logical inserts "new Hope()" is automatically
    retracted.</p><div class="example"><a name="d0e7561"></a><p class="title"><b>Example&nbsp;10.68.&nbsp;Honest Politician Example : Rule "Corrupt the Honest"</b></p><div class="example-contents"><pre class="programlisting">rule "Corrupt the Honest"
    when
        politician : Politician( honest == true )   
        exists( Hope() )
    then
        System.out.println( "I'm an evil corporation and I have corrupted " + politician.getName() );
        modify ( politician ) { honest = false };
end</pre></div></div><br class="example-break"><p>With Hope being automatically retracted, via the truth maintenance
    system, then Hope no longer exists in the system and this rule will match
    and fire.</p><div class="example"><a name="d0e7568"></a><p class="title"><b>Example&nbsp;10.69.&nbsp;Honest Politician Example : Rule "Hope is Dead"</b></p><div class="example-contents"><pre class="programlisting">rule "Hope is Dead"
    when
        not( Hope() )
    then
        System.out.println( "We are all Doomed!!! Democracy is Dead" );
end</pre></div></div><br class="example-break"><p>lets take a look the audit trail for this application:</p><div class="figure"><a name="d0e7575"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/honest_politician_audit.png" alt="Honest Politician Example Audit View"></div></div><p class="title"><b>Figure&nbsp;10.20.&nbsp;Honest Politician Example Audit View</b></p></div><br class="figure-break"><p>The moment we insert the first politician we have two activations,
    the "We have an honest Politician" is activated only once for the first
    inserted politician because it uses an existential 'exists' conditional
    element which only matches. the rule "Hope is Dead" is also activated at
    this stage, because as of yet we have not inserted the Hope object. "We
    have an honest Politician" fires first, as it has a higher salience over
    "Hope is Dead" which inserts the Hope object, that action is highlighted
    green above. The insertion of the Hope object activates "Hope Lives" and
    de-activates "Hope is Dead", it also actives "Corrupt the Honest" for each
    inserted honested politician. "Rule Hope Lives" executes printing
    "Hurrah!!! Democracy Lives". Then for each politician the rule "Corrupt
    the Honest" fires printing "I'm an evil corporation and I have corrupted
    X", where X is the name of the politician, and modifies the politicians
    honest value to false. When the last honest polician is corrupted Hope is
    automatically retracted, by the truth maintenance system, as shown by the
    blue highlighted area. The green highlighted area shows the origin of the
    currently selected blue highlighted area. Once Hope is retracted "Hope is
    dead" activates and fires printing "We are all Doomed!!! Democracy is
    Dead".</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7583"></a>10.1.11.&nbsp;Sudoku Example</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Sudoku
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.sudoku.Main
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> sudokuSolver.drl, sudokuValidator.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates the solving of logic problems, and complex pattern matching.e
</pre><p>This example demonstrates how Drools can be used to find a solution
    in a large potential solution space based on a number of constraints. We
    use the popular puzzle of Sudoku. This example also shows how Drools can
    be integrated into a graphical interface and how callbacks can be used to
    interact with a running Drools rules engine in order to update the
    graphical interface based on changes in the working memory at
    runtime.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7604"></a>10.1.11.1.&nbsp;Sudoku Overview</h4></div></div></div><p>Sudoku is a logic-based number placement puzzle. The objective is
      to fill a 9x9 grid so that each column, each row, and each of the nine
      3x3 zones contains the digits from 1 to 9 once and only once.</p><p>The puzzle setter provides a partially completed grid and the
      puzzle solver's task is to complete the grid with these
      constraints.</p><p>The general strategy to solve the problem is to ensure that when
      you insert a new number it should be unique in that particular
      region(blocks) and also in that particular row and column.</p><p>See </p><pre class="programlisting">URL: http://en.wikipedia.org/wiki/Sudoku</pre><p>
      for a more detailed description.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7618"></a>10.1.11.2.&nbsp;Running the Example</h4></div></div></div><p>Download and install drools-examples as described above and then
      execute java org.drools.examples.sudoku.Main (this example requires Java
      5).</p><p>A window will be displayed with a relatively simple partially
      filled grid. </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/sudoku1.png"></div></div><p>Click on the Solve button and the Drools-based engine will fill
      out the remaining values. The console will display detailed information
      of the rules which are executing to solve the puzzle in a human readable
      form.</p><p><code class="computeroutput">Rule #3 determined the value at (4,1) could not be
      4 as this value already exists in the same column at (8,1) Rule #3
      determined the value at (5,5) could not be 2 as this value already
      exists in the same row at (5,6) Rule #7 determined (3,5) is 2 as this is
      the only possible cell in the column that can have this value Rule #1
      cleared the other PossibleCellValues for (3,5) as a ResolvedCellValue of
      2 exists for this cell. Rule #1 cleared the other PossibleCellValues for
      (3,5) as a ResolvedCellValue of 2 exists for this cell. ... Rule #3
      determined the value at (1,1) could not be 1 as this value already
      exists in the same zone at (2,1) Rule #6 determined (1,7) is 1 as this
      is the only possible cell in the row that can have this value Rule #1
      cleared the other PossibleCellValues for (1,7) as a ResolvedCellValue of
      1 exists for this cell. Rule #6 determined (1,1) is 8 as this is the
      only possible cell in the row that can have this value
      </code></p><p>Once all of the activated rules for the solving logic have
      executed, the engine executes a second rule base to check that the
      solution is complete and valid. In this case it is, and the "Solve"
      button is disabled and displays the text "Solved (1052ms)". </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/sudoku2.png"></div></div><p>The example comes with a number of grids which can be loaded and
      solved. Click on File-&gt;Samples-&gt;Medium to load a more challenging
      grid. Note that the solve button is enabled when the new grid is loaded.
      </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/sudoku3.png"></div></div><p>Click on the "Solve" button again to solve this new grid.
      </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/sudoku4.png"></div></div><p>Now, let us load a Sudoku grid that is deliberately invalid. Click
      on File-&gt;Samples-&gt;!DELIBERATELY BROKEN!. Note that this grid
      starts with some issues, for example the value 5 appears twice in the
      first row. </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/sudoku5.png"></div></div><p>Nevertheless, click on the "Solve" button to apply the solving
      rules to this invalid Grid. Note that the "Solve" button is relabelled
      to indicate that the resulting solution is invalid. </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/sudoku6.png"></div></div><p>In addition, the validation rule set outputs all of the issues
      which are discovered to the console. </p><pre class="programlisting">
There are two cells on the same column with the same value at (6,0) and (4,0)
There are two cells on the same column with the same value at (4,0) and (6,0)
There are two cells on the same row with the same value at (2,4) and (2,2)
There are two cells on the same row with the same value at (2,2) and (2,4)
There are two cells on the same row with the same value at (6,3) and (6,8)
There are two cells on the same row with the same value at (6,8) and (6,3)
There are two cells on the same column with the same value at (7,4) and (0,4)
There are two cells on the same column with the same value at (0,4) and (7,4)
There are two cells on the same row with the same value at (0,8) and (0,0)
There are two cells on the same row with the same value at (0,0) and (0,8)
There are two cells on the same column with the same value at (1,2) and (3,2)
There are two cells on the same column with the same value at (3,2) and (1,2)
There are two cells in the same zone with the same value at (6,3) and (7,3)
There are two cells in the same zone with the same value at (7,3) and (6,3)
There are two cells on the same column with the same value at (7,3) and (6,3)
There are two cells on the same column with the same value at (6,3) and (7,3)   
      </pre><p>We will look at the solving rule set later in this section, but
      for the moment we should note that some theoretically solvable solutions
      can not be solved by the engine as it stands. Click on
      File-&gt;Samples-&gt;Hard 3 to load a sparsely populated Grid.
      </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/sudoku7.png"></div></div><p>Now click on the "Solve" button and note that the current rules
      are unable to complete the grid, even though (if you are a Sudoku
      afficiando) you may be able to see a way forward with the solution.
      </p><div class="screenshot"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/sudoku8.png"></div></div><p>At the present time, the solving functionality has been achieved
      by the use of ten rules. This rule set could be extended to enable the
      engine to tackle more complex logic for filling grids such as
      this.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7698"></a>10.1.11.3.&nbsp;Java Source and Rules Overview</h4></div></div></div><p>The Java source code can be found in the
      /src/main/java/org/drools/examples/sudoku directory, with the two DRL
      files defining the rules located in the
      /src/main/rules/org/drools/examples/sudoku directory.</p><p>org.drools.examples.sudoku.swing contains a set of classes which
      implement a framework for Sudoku puzzles. Note that this package does
      not have any dependencies on the Drools libraries. SudokuGridModel
      defines an interface which can be implemented to store a Sudoku puzzle
      as a 9x9 grid of Integer values, some of which may be null, indicating
      that the value for the cell has not yet been resolved. SudokuGridView is
      a Swing component which can visualise any implementation of
      SudokuGridModel. SudokuGridEvent and SudokuGridListener are used to
      communicate state changes between the model and the view, events are
      fired when a cell's value is resolved or changed. If you are familiar
      with the model-view-controller patterns in other Swing components such
      as JTable then this pattern should be familiar. SudokuGridSamples
      provides a number of partially filled Sudoku puzzles for demo
      purposes.</p><p>org.drools.examples.sudoku.rules contains an implementation of
      SudokuGridModel which is based on Drools. Two POJOs are used, both of
      which extend AbstractCellValue and represent a value for a specific cell
      in the grid, including the row and column location of the cell, an index
      of the 3x3 zone the cell is contained in and the value of the cell.
      PossibleCellValue indicates that we do not currently know for sure what
      the value in a cell is. There can be 2-9 PossibleCellValues for a given
      cell. ResolvedCellValue indicates that we have determined what the value
      for a cell must be. There can only be 1 ResolvedCellValue for a given
      cell. DroolsSudokuGridModel implements SudokuGridModel and is
      responsible for converting an initial two dimensional array of partially
      specified cells into a set of CellValue POJOs, creating a working memory
      based on solverSudoku.drl and inserting the CellValue POJOs into the
      working memory. When the solve() method is called it calls
      fireAllRules() on this working memory to try to solve the puzzle.
      DroolsSudokuGridModel attaches a WorkingMemoryListener to the working
      memory, which allows it to be called back on insert() and retract()
      events as the puzzle is solved. When a new ResolvedCellValue is inserted
      into the working memory, this call back allows the implementation to
      fire a SudokuGridEvent to its SudokuGridListeners which can then update
      themselves in realtime. Once all the rules fired by the solver working
      memory have executed, DroolsSudokuGridModel runs a second set of rules,
      based on validatorSudoku.drl which works with the same set of POJOs to
      determine if the resulting grid is a valid and full solution.</p><p>org.drools.examples.sudoku.Main implements a Java application
      which hooks the components desribed above together.</p><p>org.drools.examples.sudoku contains two DRL files.
      solverSudoku.drl defines the rules which attempt to solve a Sudoku
      puzzle and validator.drl defines the rules which determin whether the
      current state of the working memory represents a valid solution. Both
      use PossibleCellValue and ResolvedCellValue POJOs as their facts and
      both output information to the console as their rules fire. In a
      real-world situation we would insert() logging information and use the
      WorkingMemoryListener to display this information to a user rather than
      use the console in this fashion.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7711"></a>10.1.11.4.&nbsp;Sudoku Validator Rules (validatorSudoku.drl)</h4></div></div></div><p>We start with the validator rules as this rule set is shorter and
      simpler than the solver rule set.</p><p>The first rule simply checks that no PossibleCellValue objects
      remain in the working memory. Once the puzzle is solved, only
      ResolvedCellValue objects should be present, one for each cell.</p><p>The other three rules each match all of the ResolvedCellValue
      objects and store them in thenew_remote_sitetes instance variable
      $resolved. They then look respectively for ResolvedCellValues that
      contain the same value and are located, respectively, in the same row,
      column or 3x3 zone. If these rules are fired they add a message to a
      global List of Strings describing the reason the solution is invalid.
      DroolsSudokoGridModel injects this List before it runs the rule set and
      checks whether it is empty or not having called fireAllRules(). If it is
      not empty then it prints all the Strings in the list and sets a flag to
      indicate that the Grid is not solved.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7720"></a>10.1.11.5.&nbsp;Sudoku Solving Rules (solverSudoku.drl)</h4></div></div></div><p>Now let us look at the more complex rule set used to solve Sudoku
      puzzles.</p><p>Rule #1 is basically a "book-keeping" rule. Several of the other
      rules insert() ResolvedCellValues into the working memory at specific
      rows and columns once they have determined that a given cell must have a
      certain value. At this point, it is important to clear the working
      memory of any inserted PossibleCellValues at the same row and column
      with invalid values. This rule is therefore given a higher salience than
      the remaining rules to ensure that as soon as the LHS is true,
      activations for the rule move to the top of the agenda and are fired. In
      turn this prevents the spurious firing of other rules due to the
      combination of a ResolvedCellValue and one or more PossibleCellValues
      being present in the same cell. This rule also calls update() on the
      ResolvedCellValue, even though its value has not in fact been modified
      to ensure that Drools fires an event to any WorkingMemoryListeners
      attached to the working memory so that they can update themselves - in
      this case so that the GUI can display the new state of the grid.</p><p>Rule #2 identifies cells in the grid which have only one possible
      value. The first line of the when caluse matches all of the
      PossibleCellValue objects in the working memory. The second line
      demonstrates a use of the not keyword. This rule will only fire if no
      other PossibleCellValue objects exist in the working memory at the same
      row and column but with a different value. When the rule fires, the
      single PossibleCellValue at the row and column is retracted from the
      working memory and is replaced by a new ResolvedCellValue at the same
      row and column with the same value.</p><p>Rule #3 removes PossibleCellValues with a given value from a row
      when they have the same value as a ResolvedCellValue. In other words,
      when a cell is filled out with a resolved value, we need to remove the
      possibility of any other cell on the same row having this value. The
      first line of the when clause matches all ResolvedCellValue objects in
      the working memory. The second line matches PossibleCellValues which
      have both the same row and the same value as these ResolvedCellValue
      objects. If any are found, the rule activates and, when fired retracts
      the PossibleCellValue which can no longer be a solution for that
      cell.</p><p>Rules #4 and #5 act in the same way as Rule #3 but check for
      redundant PossibleCellValues in a given column and a given zone of the
      grid as a ResolvedCellValue respectively.</p><p>Rule #6 checks for the scenario where a possible cell value only
      appears once in a given row. The first line of the LHS matches against
      all PossibleCellValues in the working memory, storing the result in a
      number of local variables. The second line checks that no other
      PossibleCellValues with the same value exist on this row. The third to
      fifth lines check that there is not a ResolvedCellValue with the same
      value in the same zone, row or column so that this rule does not fire
      prematurely. Interestingly we could remove lines 3-5 and give rules
      #3,#4 and #5 a higher salience to make sure they always fired before
      rules #6,#7 and #8. When the rule fires, we know that $possible must
      represent the value for the cell so, as in Rule #2 we retract $possible
      and replace it with the equivalent, new ResolvedCellValue.</p><p>Rules #7 and #8 act in the same way as Rule #2 but check for
      single PossibleCellValues in a given column and a given zone of the grid
      respectively.</p><p>Rule #9 represents the most complex currently implemented rule.
      This rule implements the logic that, if we know that a pair of given
      values can only occur in two cells on a specific row, (for example we
      have determined the values of 4 and 6 can only appear in the first row
      in cells 0,3 and 0,5) and this pair of cells can not hold other values
      then, although we do not know which of the pair contains a four and
      which contains a six we know that the 4 and the 6 must be in these two
      cells and hence can remove the possibility of them occuring anywhere
      else in the same row (phew!). TODO: more detail here and I think the
      rule can be cleaned up in the DRL file before fully documenting
      it.</p><p>Rules #10 and #11 act in the same way as Rule #9 but check for the
      existance of only two possible values in a given column and zone
      respectively.</p><p>To solve harder grids, the rule set would need to be extended
      further with more complex rules that encapsulated more complex
      reasoning.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7743"></a>10.1.11.6.&nbsp;Suggestions for Future Developments</h4></div></div></div><p>There are a number of ways in which this example could be
      developed. The reader is encouraged to consider these as
      excercises.</p><div class="itemizedlist"><ul type="disc"><li><p>Agenda-group: agenda groups are a great declarative tool for
          phased execution. In this example, it is easy to see we have 2
          phases: "resolution" and "validation". Right now, they are executed
          by creating two separate rule bases, each for one "job". I think it
          would be better for us to define agenda-groups for all the rules,
          spliting them in "resolution" rules and "validation" rules, all
          loaded in a single rule base. The engine executes resolution and
          right after that, executes validation.</p></li><li><p>Auto-focus: auto focus is a great way of handling exceptions
          to the regular rules execution. In our case, if we detect an
          inconsistency, either in the input data or in the resolution rules,
          why should we spend time continuing the execution if it will be
          invalid anyway? I think it is better to simply (and immediatly)
          report the inconsistency as soon as it is found. To do that, since
          we now have a single rulebase with all rules, we simply need to
          define auto-focus attribute for all rules validating puzzle
          consistency.</p></li><li><p>Logical insert: an inconsistency only exists while wrong data
          is in the working memory. As so, we could state that the the
          validation rules logically insert inconsistencies and as soon as the
          offending data is retracted, the inconsistency no longer
          exists.</p></li><li><p>session.iterateObjects(): although a valid use case having a
          global list to add the found problems, I think it would be more
          interesting to ask the stateful session by the desired list of
          problems, using session.iterateObjects( new ClassObjectFilter(
          Inconsistency.class ) ); Having the inconsistency class can also
          allow us to paint in RED the offending cells in the GUI.</p></li><li><p>drools.halt(): even reporting the error as soon as it is
          found, we need a way to tell the engine to stop evaluating rules. We
          can do that creating a rule that in the presence of Inconsistencies,
          calls drools.halt() to stop evaluation.</p></li><li><p>queries: looking at the method getPossibleCellValues(int row,
          int col) in DroolsSudokuGridModel, we see it iterating over all
          CellValues and looking for the few it wants. That, IMO, is a great
          opportunity to teach drools queries. We just define a query to
          return the objects we want and iterate over it. Clean and nice.
          Other queries may be defined as needed.</p></li><li><p>session.iterateObjects(): although a valid use case having a
          global list to add the found problems, I think it would be more
          interesting to ask the stateful session by the desired list of
          problems, using session.iterateObjects( new ClassObjectFilter(
          Inconsistency.class ) ); Having the inconsistency class can also
          allow us to paint in RED the offending cells in the GUI.</p></li><li><p>Globals as services: the main objective of this change is to
          attend the next change I will propose, but it is nice by its own I
          guess. :) In order to teach the use of "globals" as services, it
          would be nice to setup a call back, so that each rule that finds the
          ResolvedCellValue for a given cell can call, to notify and update
          the corresponding cell in the GUI, providing immediate feedback for
          the user. Also, the last found cell could have its number painted in
          a different color to facilitate the identification of the rules
          conclusions.</p></li><li><p>Step by step execution: now that we have immediate user
          feedback, we can make use of the restricted run feature in drools.
          I.e., we could add a button in the GUI, so that the user clicks and
          causes the execution of a single rule, by calling fireAllRules( 1 ).
          This way, the user can see, step by step, what the engine is
          doing.</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7777"></a>10.1.12.1.&nbsp;Number Guess</h4></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Number Guess 
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.NumberGuessExample
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> NumberGuess.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrate use of Rule Flow to organise Rules
</pre><p>The "Number Guess" example shows the use of RuleFlow, a way of
      controlling the order in which rules are fired. It uses widely
      understood workflow diagrams to make clear the order that groups of
      rules will be executed.</p><div class="example"><a name="d0e7798"></a><p class="title"><b>Example&nbsp;10.70.&nbsp;Creating the Number Guess RuleBase - extract 1 from
        NumberGuessExample.java main() method</b></p><div class="example-contents"><pre class="programlisting">final PackageBuilder builder = new PackageBuilder();

builder.addPackageFromDrl( new InputStreamReader( 
         ShoppingExample.class.getResourceAsStream( "NumberGuess.drl" ) ) );
builder.addRuleFlow( new InputStreamReader( 
         ShoppingExample.class.getResourceAsStream( "NumberGuess.rfm" ) ) );

final RuleBase ruleBase = RuleBaseFactory.newRuleBase();
ruleBase.addPackage( builder.getPackage() );

</pre></div></div><br class="example-break"><p>The creation of the package, and the loading of the rules (using
      the addPackageFromDrl() method ) is the same as the previous examples.
      There is a additional line to add the RuleFlow (NumberGuess.rfm) as you
      have the option of specifying different ruleflows for the same RuleBase.
      Otherwise the RuleBase is created in the same manner as before .</p><div class="example"><a name="d0e7805"></a><p class="title"><b>Example&nbsp;10.71.&nbsp;Starting the RuleFlow - extract 2 from NumberGuessExample.java
        main() method</b></p><div class="example-contents"><pre class="programlisting">final StatefulSession session = ruleBase.newStatefulSession();

session.insert( new GameRules( 100,  5 ) );
session.insert( new RandomNumber() );
session.insert( new Game() );

session.startProcess( "Number Guess" );
session.fireAllRules();

session.dispose();

</pre></div></div><br class="example-break"><p>Once we have a RuleBase we can use it to obtain a stateful
      session. Into our session we insert our facts (standard Java Objects).
      For simplicity in this sample, these classes are all contained within
      our NumberGuessExample.java file. The GameRules class provides the
      maximum range and the number of guesses allowed. The RandomNumber class
      automatically generates a number between 0 and 100 and makes it
      available to our rules after insertion (via the getValue() method). The
      Game class keeps track of the guesses we have made before, and the
      number of guesses we have made.</p><p>Note that before we call the standard fireAllRules() method, we
      also start the process that we loaded earlier (via the startProcess()
      method). We explain where to obtain the parameter we pass ("Number
      Guess" - the id of the ruleflow) when we talk about the RuleFlow file
      and the graphical RuleFlow editor below.</p><p>Before we finish we our Java code , we note that In 'real life' we
      would examine the final state of the objects (e.g. how many guesses it
      took, so that we could add it to a high score table). For this example
      we are content to ensure the working memory session is cleared by
      calling the dispose() method.</p><div class="figure"><a name="d0e7816"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/numberguess-ruleflow.png" alt="RuleFlow for the NumberGuess Example"></div></div><p class="title"><b>Figure&nbsp;10.21.&nbsp;RuleFlow for the NumberGuess Example</b></p></div><br class="figure-break"><p>If you open the NumberGuess.rf file open in the Drools IDE (and
      have the JBoss Rules extensions installed correctly in Eclipse) you
      should see the above diagram, similar to a standard flowchart. Its icons
      are similar (but not exactly the same) as the JBoss jBPM workflow
      product. Should you wish to edit the diagram, a menu of available
      components should be available to the left of the diagram in the IDE,
      which is call the pallete. This diagram is saved in a (almost human)
      readable xml format, using xstream.</p><p>If it is not already open, ensure the properties view is visible
      in the IDE. It can opened by selecting Window -&gt; Show View -&gt;
      Other and then select the Properties view. If you do this <span class="bold"><strong>before</strong></span> you select any item on the RuleFlow (or
      click on blank space in the RuleFlow) you should be presented with the
      following set of properties.</p><div class="figure"><a name="d0e7829"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/numberguess-ruleflow-properties.png" alt="Properties for the Number Guess RuleFlow"></div></div><p class="title"><b>Figure&nbsp;10.22.&nbsp;Properties for the Number Guess RuleFlow</b></p></div><br class="figure-break"><p>Keep an eye on the properties view as we progress through the
      example RuleFlow as it gives valuable information. In this case it
      provides us with the ID of the RuleFlow process that we used in our
      earlier code example when we called session.startprocess().</p><p>To give an overview of each of the node types (boxes) in the
      NumberGuess RuleFlow.</p><p>
        </p><div class="itemizedlist"><ul type="disc"><li><p>The Start and End nodes (green arrow and red box) are where
            the RuleFlow starts and ends.</p></li><li><p>RuleFlowGroup (simple yellow box). These map to the
            RuleFlowGroups in our rules (DRL) file that we will look at later.
            For example when the flow reaches the 'Too High' RuleFlowGroup,
            only those rules marked with an attribute of <span class="bold"><strong>ruleflow-group "Too High" </strong></span> can potentially
            fire.</p></li><li><p>Action Nodes (yellow box with cog like icon). These can
            perform standard Java method calls. Most action nodes in this
            example call System.out.println to give an indication to the user
            of what is going on.</p></li><li><p>Split and Join Nodes (Blue Ovals) such as "Guess Correct"
            and "More Guesses Join" where the flow of control can split
            (according to various conditions) and / or rejoin.</p></li><li><p>Arrows that indicate the flow between the various
            nodes.</p></li></ul></div><p>
      </p><p>These various nodes work together with the Rules to make the
      Number Guess game work. For example, the "Guess" RuleFlowGroup allows
      only the rule "Get user Guess" to fire (details below) as only that Rule
      has a matching attribute of <span class="bold"><strong>ruleflow-group
      "Guess"</strong></span></p><div class="example"><a name="d0e7865"></a><p class="title"><b>Example&nbsp;10.72.&nbsp;A Rule that will fire only a specific point in the RuleFlow -
        extract from NumberGuess.drl</b></p><div class="example-contents"><pre class="programlisting">rule "Get user Guess"
 ruleflow-group "Guess"
 no-loop
 when    
     $r : RandomNumber()
     rules : GameRules( allowed : allowedGuesses )
     game : Game( guessCount &lt; allowed )
     not ( Guess() )
 then
     System.out.println( "You have " + ( rules.allowedGuesses - game.guessCount ) 
     + " out of " + rules.allowedGuesses + " guesses left.\nPlease enter your guess 
     from 0 to " + rules.maxRange );
        br = new BufferedReader( new InputStreamReader( System.in ) );
        modify ( game ) { guessCount = game.guessCount + 1 }
        i = br.readLine();        
    insert( new Guess( i ) );
end</pre></div></div><br class="example-break"><p>The rest of this rule is fairly standard : The <span class="bold"><strong>LHS (when)</strong></span> section of the rule states that it
      will be activated for each <span class="emphasis"><em>RandomNumber</em></span> object
      inserted into the working memory where <span class="emphasis"><em>guessCount</em></span>
      is less than the <span class="emphasis"><em>allowedGuesses</em></span> ( read from the
      GameRules Class) and where the user has not guessed the correct
      number.</p><p>The <span class="bold"><strong>RHS (consequence, then)</strong></span>
      prints a message to the user, then awaits user input from
      <span class="emphasis"><em>System.in. </em></span> After getting this input (as System.in
      blocks until the &lt;return&gt; key is pressed) it updates/modifes the
      guess count, the actual guess and makes both available in the working
      memory.</p><p>The rest of the Rules file is fairly standard ; the package
      declares the dialect is set to MVEL, various Java classes are imported.
      In total, there are five rules in this file:</p><div class="orderedlist"><ol type="1"><li><p>Get User Guess, the Rule we examined above.</p></li><li><p>A Rule to record the highest guess.</p></li><li><p>A Rule to record the lowest guess.</p></li><li><p>A Rule to inspect the guess and retract it from memory if
            incorrect.</p></li><li><p>A Rule that notifies the user that all guesses have been
            used up.</p></li></ol></div><p>One point of integration between the standard Rules and
      the RuleFlow is via the 'ruleflow-group' attribute on the rules (as
      dicussed above). A <span class="bold"><strong>second point of integration
      between the Rules File (drl) and the Rules Flow .rf files </strong></span>is
      that the Split Nodes (the blue ovals) can use values in working memory
      (as updated by the Rules) to decide which flow of action to take. To see
      how this works click on the "Guess Correct Node" ; then within the
      properties view, open the constraints editor (the button at the right
      that appears once you click on the 'Constraints' property line). You
      should see something similar to the Diagram below.</p><div class="figure"><a name="d0e7915"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/numberguess-editconstraints.png" alt="Edit Constraints for the GuessCorrect Node"></div></div><p class="title"><b>Figure&nbsp;10.23.&nbsp;Edit Constraints for the GuessCorrect Node</b></p></div><br class="figure-break"><p>Click on 'Edit' beside 'To node Too High' and you see a dialog
      like the one below. The values in the 'Textual Editor' follow the
      standard Rule Format (LHS) and can refer to objects in working memory.
      The consequence (RHS) is that the flow of control follows this node
      (i.e. To node Too high') if the LHS expression evaluates to true.</p><div class="figure"><a name="d0e7923"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/numberguess-constraint-toohigh.png" alt="Constraints Editor for the GuessCorrect Node / value too high"></div></div><p class="title"><b>Figure&nbsp;10.24.&nbsp;Constraints Editor for the GuessCorrect Node / value too
        high</b></p></div><br class="figure-break"><p>Since the NumberGuess.java example contains a main() method, it
      can be run as a standard Java application (either from the command line
      or via the IDE). A typical game might result in the interaction below
      (the numbers in bold are typed in by the user).</p><div class="example"><a name="d0e7931"></a><p class="title"><b>Example&nbsp;10.73.&nbsp;Example Console output where the Number Guess Example beat the
        human!</b></p><div class="example-contents"><pre class="programlisting">You have 5 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>50</strong></span>
Your guess was too high
You have 4 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>25</strong></span>
Your guess was too low
You have 3 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>37</strong></span>
Your guess was too low
You have 2 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>44</strong></span>
Your guess was too low
You have 1 out of 5 guesses left.
Please enter your guess from 0 to 100
<span class="bold"><strong>47</strong></span>
Your guess was too low
You have no more guesses
The correct guess was 48 

</pre></div></div><br class="example-break"><p>A summary of what is happening in this sample is:</p><p>
        </p><div class="orderedlist"><ol type="1"><li><p>Main() method of NumberGuessExample.java loads RuleBase,
            gets a StatefulSession and inserts Game, GameRules and
            RandomNumber (containing the target number) objects into it. This
            method sets the process flow we are going to use, and fires all
            rules. Control passes to the RuleFlow.</p></li><li><p>The NumberGuess.rf RuleFlow begins at the Start node.</p></li><li><p>Control passes (via the "more guesses" join node) to the
            Guess Node..</p></li><li><p>At the Guess node, the appropriate RuleFlowGroup ("Get user
            Guess") is enabled. In this case the Rule "Guess" (in the
            NumberGuess.drl file) is triggered. This rule displays a message
            to the user, takes the response, and puts it into memory. Flow
            passes to the next Rule Flow Node.</p></li><li><p>At the next node , "Guess Correct", constraints inspect the
            current session and decide which path we take next.</p><p>If the guess in step 4 was too high / too low flow procees
            along a path which has (i) An action node with normal Java code
            prints a too high / too low statement and (ii) a RuleFlowGroup
            causes a highest guess / lowest guess Rule to be triggered in the
            Rules file. Flow passes from these nodes to step 6.</p><p>If the guess in step 4 just right we proceed along the path
            towards the end of the Rule Flow. Before we get there, an action
            node with normal Java code prints a statement "you guessed
            correctly". There is a join node here (just before the Rule Flow
            End) so that our no-more-guesses path (step 7) can also terminate
            the RuleFlow.</p></li><li><p>Control passes as per the RuleFlow via a join node, a guess
            incorrect RuleFlowGroup (triggers a rule to retract a guess from
            working memory) onto the "more guesses" decision node.</p></li><li><p>The "more guesses" decision node (right hand side of
            ruleflow) uses constraints (again looking at values that the Rules
            have put into the working memory) to decide if we have more
            guesses and if so, goto step 3. If not we proceed to the end of
            the workflow, via a RuleFlowGroup that triggers a rule stating
            "you have no more guesses".</p></li><li><p>The Loop 3-7 continues until the number is guessed
            correctly, or we run out of guesses.</p></li></ol></div><p>
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7985"></a>10.1.13.&nbsp;Miss Manners and Benchmarking</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Miss Manners
<span class="bold"><strong>Main class:</strong></span> org.drools.benchmark.manners.MannersBenchmark
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> manners.drl
<span class="bold"><strong>Objective:</strong></span> Advanced walkthrough on the Manners benchmark, covers Depth conflict resolution in depth.</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8004"></a>10.1.13.1.&nbsp;Introduction</h4></div></div></div><p>Miss Manners is throwing a party and being the good host she wants
      to arrange good seating. Her initial design arranges everyone in male
      female pairs, but then she worries about people have things to talk
      about; what is a good host to do? So she decides to note the hobby of
      each guest so she can then arrange guests in not only male and female
      pairs but also ensure that a guest has someone to talk about a common
      hobby, from either their left or right side.</p><div class="figure"><a name="d0e8009"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Examples/guests_at_table.png" align="middle" alt="Miss Manners' Guests"></div></div><p class="title"><b>Figure&nbsp;10.25.&nbsp;Miss Manners' Guests</b></p></div><br class="figure-break"><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8017"></a>10.1.13.1.1.&nbsp;BenchMarking</h5></div></div></div><p>5 benchmarks were established in the 1991 paper "Effects of
        Database Size on Rule System Performance: Five Case Studies" by Brant,
        Timothy Grose, Bernie Lofaso, &amp; Daniel P. Miranker.</p><div class="itemizedlist"><ul type="disc"><li><p>Manners</p><div class="itemizedlist"><ul type="circle"><li><p>Uses a depth-first search approach to determine the
                seating arrangements of boy/girl and one common hobby for
                dinner guests</p></li></ul></div></li><li><p>Waltz</p><div class="itemizedlist"><ul type="circle"><li><p>line labeling for simple scenes by constraint
                propagation</p></li></ul></div></li><li><p>WaltzDB</p><div class="itemizedlist"><ul type="circle"><li><p>More general version of Walts to be able to adapt to a
                database of facts</p></li></ul></div></li><li><p>ARP</p><div class="itemizedlist"><ul type="circle"><li><p>Route planner for a robotic air vehicle using the A*
                search algorithm</p></li></ul></div></li><li><p>Weavera</p><div class="itemizedlist"><ul type="circle"><li><p>VLSI router for channels and boxes using a black-board
                technique</p></li></ul></div></li></ul></div><p>Manners has become the de facto rule engine benchmark; however
        it's behavior is now well known and many engines optimize for this
        thus negating its usefulness as a benchmark which is why Waltz is
        becoming more favorable. These 5 benchmarks are also published at the
        University of Texas <a class="ulink" href="http://www.cs.utexas.edu/ftp/pub/ops5-benchmark-suite/" target="_top">http://www.cs.utexas.edu/ftp/pub/ops5-benchmark-suite/</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8063"></a>10.1.13.1.2.&nbsp;Miss Manners Execution Flow</h5></div></div></div><p>After the first Seating arrangement has been assigned a
        depth-first recursion occurs which repeatedly assigns correct Seating
        arrangements until the last seat is assigned. Manners uses a Context
        instance to control execution flow; the activity diagram is
        partitioned to show the relation of the rule execution to the current
        Context state.</p><div class="figure"><a name="d0e8068"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Examples/manners_activity_diagram.png" align="middle" alt="Manners Activity Diagram"></div></div><p class="title"><b>Figure&nbsp;10.26.&nbsp;Manners Activity Diagram</b></p></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8076"></a>10.1.13.1.3.&nbsp;The Data and Results</h5></div></div></div><p>Before going deeper into the rules lets first take a look at the
        asserted data and the resulting Seating arrangement. The data is a
        simple set of 5 guests who should be arranged in male/female pairs
        with common hobbies.</p><p><span class="bold"><strong>The Data</strong></span></p><p>Each line of the results list is printed per execution of the
        &#8220;Assign Seat&#8221; rule. They key bit to notice is that each line has pid
        one greater than the last, the significance of this will be explained
        in t he &#8220;Assign Seating&#8221; rule description. The 'l' and the 'r' refer
        to the left and right, 's' is sean and 'n' is the guest name. In my
        actual implementation I used longer notation, 'leftGuestName', but
        this is not practice in a printed article. I found the notation of
        left and right preferable to the original OPS5 '1' and '2</p><div class="literallayout"><p>(guest&nbsp;(name&nbsp;n1)&nbsp;(sex&nbsp;m)&nbsp;(hobby&nbsp;&nbsp;h1)&nbsp;&nbsp;)<br>
(guest&nbsp;(name&nbsp;n2)&nbsp;(sex&nbsp;f)&nbsp;(hobby&nbsp;&nbsp;h1)&nbsp;&nbsp;)<br>
(guest&nbsp;(name&nbsp;n2)&nbsp;(sex&nbsp;f)&nbsp;(hobby&nbsp;&nbsp;h3)&nbsp;&nbsp;)<br>
(guest&nbsp;(name&nbsp;n3)&nbsp;(sex&nbsp;m)&nbsp;(hobby&nbsp;&nbsp;h3)&nbsp;&nbsp;)<br>
(guest&nbsp;(name&nbsp;n4)&nbsp;(sex&nbsp;m)&nbsp;(hobby&nbsp;&nbsp;h1)&nbsp;&nbsp;)<br>
(guest&nbsp;(name&nbsp;n4)&nbsp;(sex&nbsp;f)&nbsp;(hobby&nbsp;&nbsp;h2)&nbsp;&nbsp;)<br>
(guest&nbsp;(name&nbsp;n4)&nbsp;(sex&nbsp;f)&nbsp;(hobby&nbsp;&nbsp;h3)&nbsp;&nbsp;)<br>
(guest&nbsp;(name&nbsp;n5)&nbsp;(sex&nbsp;f)&nbsp;(hobby&nbsp;&nbsp;h2)&nbsp;&nbsp;)<br>
(guest&nbsp;(name&nbsp;n5)&nbsp;(sex&nbsp;f)&nbsp;(hobby&nbsp;&nbsp;h1)&nbsp;&nbsp;)<br>
(last_seat&nbsp;(seat&nbsp;5)&nbsp;&nbsp;)</p></div><p><span class="bold"><strong>The Results</strong></span></p><div class="literallayout"><p>[Seating&nbsp;id=1,&nbsp;pid=0,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=1,&nbsp;rn=n5]&nbsp;<br>
[Seating&nbsp;id=2,&nbsp;pid=1,&nbsp;done=false,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=2,&nbsp;rn=n4]&nbsp;<br>
[Seating&nbsp;id=3,&nbsp;pid=2,&nbsp;done=false,&nbsp;ls=2,&nbsp;ln=n4,&nbsp;rs=3,&nbsp;rn=n3]&nbsp;<br>
[Seating&nbsp;id=4,&nbsp;pid=3,&nbsp;done=false,&nbsp;ls=3,&nbsp;rn=n3,&nbsp;rs=4,&nbsp;rn=n2]&nbsp;<br>
[Seating&nbsp;id=5,&nbsp;pid=4,&nbsp;done=false,&nbsp;ls=4,&nbsp;ln=n2,&nbsp;rs=5,&nbsp;rn=n1]</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8093"></a>10.1.13.2.&nbsp;Indepth look</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8096"></a>10.1.13.2.1.&nbsp;Cheating</h5></div></div></div><p>Manners has been around a long time and is a contrived benchmark
        meant to exercise the cross product joins and agenda, many people not
        understanding this tweak the example to achieve better perfmance,
        making their use of the Manners benchmark pointless. Known cheats to
        Miss Manners are:</p><div class="itemizedlist"><ul type="disc"><li><p>Using arrays for a guests hobbies, instead of asserting each
            one as a single fact. This massively reduces the cross
            products.</p></li><li><p>The altering of the sequence of data can also reducing the
            amount of matching increase execution speed</p></li><li><p>Changing NOT CE (conditional element) such that the test
            algorithm only uses the "first-best-match". Basically, changing
            the test algorithm to backward chaining. the results are only
            comparable to other backward chaining rule engines or ports of
            Manners.</p></li><li><p>Removing the context so the rule engine matches the guests
            and seats pre-maturely. A proper port will prevent facts from
            matching using the context start.</p></li><li><p>Any change which prevents the rule engine from performing
            combinatorial pattern matching</p></li><li><p>If no facts are retracted in the reasoning cycle, as a
            result of NOT CE, the port is incorrect.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8120"></a>10.1.13.2.2.&nbsp;Conflict Resolution</h5></div></div></div><p>Manners benchmark was written for OPS5 which has two conflict
        resolution strategies, LEX and MEA; LEX is a chain of several
        strategies including Salience, Recency, Complexity. The Recency part
        of the strategy drives the depth first (LIFO) firing order. The Clips
        manual documents the recency strategy as:</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top">&nbsp;</td><td width="80%" valign="top"><p>Every fact and instance is marked internally with a &#8220;time tag&#8221;
          to indicate its relative recency with respect to every other fact
          and instance in the system. The pattern entities associated with
          each rule activation are sorted in descending order for determining
          placement. An activation with a more recent pattern entities is
          placed before activations with less recent pattern entities. To
          determine the placement order of two activations, compare the sorted
          time tags of the two activations one by one starting with the
          largest time tags. The comparison should continue until one
          activation&#8217;s time tag is greater than the other activation&#8217;s
          corresponding time tag. The activation with the greater time tag is
          placed before the other activation on the agenda. If one activation
          has more pattern entities than the other activation and the compared
          time tags are all identical, then the activation with more time tags
          is placed before the other activation on the agenda.</p></td><td width="10%" valign="top">&nbsp;</td></tr><tr><td width="10%" valign="top">&nbsp;</td><td colspan="2" align="right" valign="top">--<span class="attribution">Clips Reference Manual</span></td></tr></table></div><p>However Jess and Clips both use the Depth strategy, which is
        simpler and lighter, which Drools also adopted. The Clips manual
        documents the Depth strategy as:</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top">&nbsp;</td><td width="80%" valign="top"><p>Newly activated rules are placed above all rules of the same
          salience. For example, given that fact-a activates rule-1 and rule-2
          and fact-b activates rule-3 and rule-4, then if fact-a is asserted
          before fact-b, rule-3 and rule-4 will be above rule-1 and rule-2 on
          the agenda. However, the position of rule-1 relative to rule-2 and
          rule-3 relative to rule-4 will be arbitrary.</p></td><td width="10%" valign="top">&nbsp;</td></tr><tr><td width="10%" valign="top">&nbsp;</td><td colspan="2" align="right" valign="top">--<span class="attribution">Clips Reference Manual</span></td></tr></table></div><p>The initial Drools implementation for the Depth strategy would
        not work for manners without the use of salience on the "make_path"
        rule, the Clips support team had this to say:</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top">&nbsp;</td><td width="80%" valign="top"><p>The default conflict resolution strategy for CLIPS, depth, is
          different than the default conflict resolution strategy used by
          OPS5. Therefore if you directly translate an OPS5 program to CLIPS,
          but use the default depth conflict resolution strategy, you're only
          likely to get the correct behavior by coincidence. The lex and mea
          conflict resolution strategies are provided in CLIPS to allow you to
          quickly convert and correctly run an OPS5 program in CLIPS</p></td><td width="10%" valign="top">&nbsp;</td></tr><tr><td width="10%" valign="top">&nbsp;</td><td colspan="2" align="right" valign="top">--<span class="attribution">Clips Support Forum</span></td></tr></table></div><p>Investigation into the Clips code reveals there is undocumented
        functionality in the Depth strategy. There is an accumulated time tag
        used in this strategy; it's not an extensively fact by fact comparison
        as in the recency strategy, it simply adds the total of all the time
        tags for each activation and compares.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8146"></a>10.1.13.2.3.&nbsp;Assign First Seat</h5></div></div></div><p>Once the context is changed to START_UP Activations are created
        for all asserted Guests; because all Activations are created as the
        result of a single Working Memory action, they all have the same
        Activation time tag. The last asserted Guest would have a higher fact
        time tag and its Activation would fire, becuase it has the highest
        accumulated fact time tag. The execution order in this rule has little
        importance, but has a big impact in the rule "Assign Seat". The
        Activation fires and asserts the first Seating arrangement, a Path and
        then sets the Context's state to create Activation for "Assign
        Seat".</p><pre class="programlisting">rule assignFirstSeat
    when
        context : Context( state == Context.START_UP )
        guest : Guest()
        count : Count()
    then
        String guestName = guest.getName();        

        insert( new Seating( count.getValue(), 1, true, 1, guestName, 1, guestName) );        
        insert( new Path( count.getValue(), 1, guestName ) );        

        count.setValue(  count.getValue() + 1 );        
        update( count );
        context.setState( Context.ASSIGN_SEATS );       
        update( context );
end</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8153"></a>10.1.13.2.4.&nbsp;Assign Seat</h5></div></div></div><p>This rule determines each of the Seating arrangements. The Rule
        creates cross product solutions for ALL asserted Seating arrangements
        against ALL the asserted guests; accept against itself or any already
        assigned Chosen solutions.</p><pre class="programlisting">rule findSeating
   when 
       context : Context( state == Context.ASSIGN_SEATS )
       $s      : Seating( pathDone == true )
       $g1     : Guest( name == $s.rightGuestName )
       $g2     : Guest( sex != $g1.sex, hobby == $g1.hobby )
       count   : Count()
       not ( Path( id == $s.id, guestName == $g2.name) )
       not ( Chosen( id == $s.id, guestName == $g2.name, hobby == $g1.hobby) )
   then
       int rightSeat = $s.getRightSeat();
       int seatId = $s.getId();
       int countValue = count.getValue();
       
       insert( new Seating( countValue, seatId, false, rightSeat, $s.getRightGuestName(), rightSeat + 1, $g2.getName() ) );                                
       insert( new Path( countValue, rightSeat + 1, $g2.getName() ) );       
       insert( new Chosen( seatId, $g2.getName(), $g1.getHobby() ) );

       count.setValue(  countValue + 1 );
       update( count );       
       context.setState( Context.MAKE_PATH );
       update( context );
end</pre><p>However, as can be seen from the printed results shown earlier,
        it is essential that only the Seating with the highest pid cross
        product be chosen &#8211; yet how can this be possible if we have
        Activations, of the same time tag, for nearly all existing Seating and
        Guests. For example on the third iteration of "Assing Seat" these are
        the produced Activations, remember this is from a very small data set
        and with larger data sets there would be many more possible Activated
        Seating solutions, with multiple solutions per pid:</p><div class="literallayout"><p>=&gt;[ActivationCreated(35):&nbsp;rule=findSeating&nbsp;<br>
[fid:19:33]:[Seating&nbsp;id=3,&nbsp;pid=2,&nbsp;done=true,&nbsp;ls=2,&nbsp;ln=n4,&nbsp;rs=3,&nbsp;rn=n3]&nbsp;<br>
[fid:4:4]:[Guest&nbsp;name=n3,&nbsp;sex=m,&nbsp;hobbies=h3]&nbsp;<br>
[fid:3:3]:[Guest&nbsp;name=n2,&nbsp;sex=f,&nbsp;hobbies=h3]<br>
<br>
=&gt;[ActivationCreated(35):&nbsp;rule=findSeating&nbsp;<br>
[fid:15:23]:[Seating&nbsp;id=2,&nbsp;pid=1,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=2,&nbsp;rn=n4]&nbsp;<br>
[fid:5:5]:[Guest&nbsp;name=n4,&nbsp;sex=m,&nbsp;hobbies=h1]&nbsp;<br>
[fid:2:2]:[Guest&nbsp;name=n2,&nbsp;sex=f,&nbsp;hobbies=h1]&nbsp;<br>
<br>
=&gt;[ActivationCreated(35):&nbsp;rule=findSeating&nbsp;<br>
[fid:13:13]:[Seating&nbsp;id=1,&nbsp;pid=0,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=1,&nbsp;rn=n5]&nbsp;<br>
[fid:9:9]:[Guest&nbsp;name=n5,&nbsp;sex=f,&nbsp;hobbies=h1]&nbsp;<br>
[fid:1:1]:[Guest&nbsp;name=n1,&nbsp;sex=m,&nbsp;hobbies=h1]</p></div><p>The creation of all these redundant Activations might seem
        pointless, but it must be remembered that Manners is not about good
        rule design; it's purposefully designed as a bad ruleset to fully
        stress test the cross product matching process and the agenda, which
        this clearly does. Notice that each Activation has the same time tag
        of 35, as they were all activated by the change in Context to
        ASSIGN_SEATS. With OPS5 and LEX it would correctly fire the Activation
        with the last asserted Seating. With Depth the accumulated fact time
        tag ensures the Activation with the last asserted Seating
        fires.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8166"></a>10.1.13.2.5.&nbsp;Make Path and Path Done</h5></div></div></div><p>"Make Path" must always fires before "Path Done". A Path is
        asserted for each Seating arrangement up to the last asserted Seating.
        Notice that "Path Done" is a subset of "Make Path", so how do we
        ensure that "Make Path" fires first?</p><pre class="programlisting">rule makePath
    when 
        Context( state == Context.MAKE_PATH )
        Seating( seatingId:id, seatingPid:pid, pathDone == false )
        Path( id == seatingPid, pathGuestName:guestName, pathSeat:seat )
        not Path( id == seatingId, guestName == pathGuestName )
    then
        insert( new Path( seatingId, pathSeat, pathGuestName ) );
end</pre><pre class="programlisting">rule pathDone
    when
        context : Context( state == Context.MAKE_PATH ) 
        seating : Seating( pathDone == false ) 
    then
        seating.setPathDone( true ); 
        update( seating );
        
        context.setState( Context.CHECK_DONE ); 
        update( context );
end</pre><div class="figure"><a name="d0e8175"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Examples/make_path.png" align="middle" alt="Rete Diagram"></div></div><p class="title"><b>Figure&nbsp;10.27.&nbsp;Rete Diagram</b></p></div><br class="figure-break"><p>Both rules end up on the Agenda in conflict and with identical
        activation time tags, however the accumulate fact time tag is greater
        for "Make Path" so it gets priority.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8185"></a>10.1.13.2.6.&nbsp;Continue and Are We Done</h5></div></div></div><p>"Are We Done" only activates when the last seat is assigned, at
        which point both rules will be activated. For the same reason that
        "Make Path" always wins over "Path Done" "Are We Done" will take
        priority over "Continue".</p><pre class="programlisting">rule areWeDone
    when
        context : Context( state == Context.CHECK_DONE ) 
        LastSeat( lastSeat: seat )
        Seating( rightSeat == lastSeat ) 
    then
        context.setState(Context.PRINT_RESULTS ); 
        update( context );
end
</pre><pre class="programlisting">rule continue
    when
        context : Context( state == Context.CHECK_DONE ) 
    then
        context.setState( Context.ASSIGN_SEATS ); 
        update( context );
end
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8194"></a>10.1.13.3.&nbsp;Output Summary</h4></div></div></div><div class="literallayout"><p><span class="bold"><strong>Assign&nbsp;First&nbsp;seat</strong></span><br>
=&gt;[fid:13:13]:[Seating&nbsp;id=1,&nbsp;pid=0,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=1,&nbsp;rn=n5]<br>
=&gt;[fid:14:14]:[Path&nbsp;id=1,&nbsp;seat=1,&nbsp;guest=n5]<br>
<br>
==&gt;[ActivationCreated(16):&nbsp;rule=findSeating<br>
[fid:13:13]:[Seating&nbsp;id=1,&nbsp;pid=0,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=1,&nbsp;rn=n5]<br>
[fid:9:9]:[Guest&nbsp;name=n5,&nbsp;sex=f,&nbsp;hobbies=h1]<br>
[fid:1:1]:[Guest&nbsp;name=n1,&nbsp;sex=m,&nbsp;hobbies=h1]<br>
<br>
==&gt;[ActivationCreated(16):&nbsp;rule=findSeating<br>
[fid:13:13]:[Seating&nbsp;id=1&nbsp;,&nbsp;pid=0,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=1,&nbsp;rn=n5]<br>
[fid:9:9]:[Guest&nbsp;name=n5,&nbsp;sex=f,&nbsp;hobbies=h1]<br>
[fid:5:5]:[Guest&nbsp;name=n4,&nbsp;sex=m,&nbsp;hobbies=h1]*<br>
<br>
<span class="bold"><strong>Assign&nbsp;Seating</strong></span><br>
=&gt;[fid:15:17]&nbsp;:[Seating&nbsp;id=2&nbsp;,&nbsp;pid=1&nbsp;,&nbsp;done=false,&nbsp;ls=1,&nbsp;lg=n5,&nbsp;rs=2,&nbsp;rn=n4]<br>
=&gt;[fid:16:18]:[Path&nbsp;id=2,&nbsp;seat=2,&nbsp;guest=n4]<br>
=&gt;[fid:17:19]:[Chosen&nbsp;id=1,&nbsp;name=n4,&nbsp;hobbies=h1]<br>
<br>
=&gt;[ActivationCreated(21):&nbsp;rule=makePath&nbsp;<br>
[fid:15:17]&nbsp;:&nbsp;[Seating&nbsp;id=2,&nbsp;pid=1,&nbsp;done=false,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=2,&nbsp;rn=n4]<br>
[fid:14:14]&nbsp;:&nbsp;[Path&nbsp;id=1,&nbsp;seat=1,&nbsp;guest=n5]*<br>
<br>
==&gt;[ActivationCreated(21):&nbsp;rule=pathDone<br>
[Seating&nbsp;id=2,&nbsp;pid=1,&nbsp;done=false,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=2,&nbsp;rn=n4]*<br>
<br>
<span class="bold"><strong>Make&nbsp;Path</strong></span><br>
=&gt;[fid:18:22:[Path&nbsp;id=2,&nbsp;seat=1,&nbsp;guest=n5]]<br>
<br>
<span class="bold"><strong>Path&nbsp;Done</strong></span><br>
<br>
<span class="bold"><strong>Continue&nbsp;Process</strong></span><br>
=&gt;[ActivationCreated(25):&nbsp;rule=findSeating<br>
[fid:15:23]:[Seating&nbsp;id=2,&nbsp;pid=1,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=2,&nbsp;rn=n4]<br>
[fid:7:7]:[Guest&nbsp;name=n4,&nbsp;sex=f,&nbsp;hobbies=h3]<br>
[fid:4:4]&nbsp;:&nbsp;[Guest&nbsp;name=n3,&nbsp;sex=m,&nbsp;hobbies=h3]*<br>
<br>
=&gt;[ActivationCreated(25):&nbsp;rule=findSeating<br>
[fid:15:23]:[Seating&nbsp;id=2,&nbsp;pid=1,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=2,&nbsp;rn=n4]<br>
[fid:5:5]:[Guest&nbsp;name=n4,&nbsp;sex=m,&nbsp;hobbies=h1]<br>
[fid:2:2]:[Guest&nbsp;name=n2,&nbsp;sex=f,&nbsp;hobbies=h1],&nbsp;[fid:12:20]&nbsp;:&nbsp;[Count&nbsp;value=3]<br>
<br>
=&gt;[ActivationCreated(25):&nbsp;rule=findSeating<br>
[fid:13:13]:[Seating&nbsp;id=1,&nbsp;pid=0,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=1,&nbsp;rn=n5]<br>
[fid:9:9]:[Guest&nbsp;name=n5,&nbsp;sex=f,&nbsp;hobbies=h1]<br>
[fid:1:1]:[Guest&nbsp;name=n1,&nbsp;sex=m,&nbsp;hobbies=h1]<br>
<br>
<span class="bold"><strong>Assign&nbsp;Seating</strong></span><br>
=&gt;[fid:19:26]:[Seating&nbsp;id=3,&nbsp;pid=2,&nbsp;done=false,&nbsp;ls=2,&nbsp;lnn4,&nbsp;rs=3,&nbsp;rn=n3]]<br>
=&gt;[fid:20:27]:[Path&nbsp;id=3,&nbsp;seat=3,&nbsp;guest=n3]]<br>
=&gt;[fid:21:28]:[Chosen&nbsp;id=2,&nbsp;name=n3,&nbsp;hobbies=h3}]<br>
<br>
=&gt;[ActivationCreated(30):&nbsp;rule=makePath<br>
[fid:19:26]:[Seating&nbsp;id=3,&nbsp;pid=2,&nbsp;done=false,&nbsp;ls=2,&nbsp;ln=n4,&nbsp;rs=3,&nbsp;rn=n3]<br>
[fid:18:22]:[Path&nbsp;id=2,&nbsp;seat=1,&nbsp;guest=n5]*<br>
<br>
=&gt;[ActivationCreated(30):&nbsp;rule=makePath&nbsp;<br>
[fid:19:26]:[Seating&nbsp;id=3,&nbsp;pid=2,&nbsp;done=false,&nbsp;ls=2,&nbsp;ln=n4,&nbsp;rs=3,&nbsp;rn=n3]<br>
[fid:16:18]:[Path&nbsp;id=2,&nbsp;seat=2,&nbsp;guest=n4]*<br>
<br>
=&gt;[ActivationCreated(30):&nbsp;rule=done&nbsp;<br>
[fid:19:26]:[Seating&nbsp;id=3,&nbsp;pid=2,&nbsp;done=false,&nbsp;ls=2,&nbsp;ln=n4,&nbsp;rs=3,&nbsp;rn=n3]*<br>
<br>
<span class="bold"><strong>Make&nbsp;Path</strong></span><br>
=&gt;[fid:22:31]:[Path&nbsp;id=3,&nbsp;seat=1,&nbsp;guest=n5]<br>
<br>
<span class="bold"><strong>Make&nbsp;Path&nbsp;</strong></span><br>
=&gt;[fid:23:32]&nbsp;[Path&nbsp;id=3,&nbsp;seat=2,&nbsp;guest=n4]<br>
<br>
<span class="bold"><strong>Path&nbsp;Done</strong></span><br>
<br>
<span class="bold"><strong>Continue&nbsp;Processing</strong></span><br>
=&gt;[ActivationCreated(35):&nbsp;rule=findSeating<br>
[fid:19:33]:[Seating&nbsp;id=3,&nbsp;pid=2,&nbsp;done=true,&nbsp;ls=2,&nbsp;ln=n4,&nbsp;rs=3,&nbsp;rn=n3]<br>
[fid:4:4]:[Guest&nbsp;name=n3,&nbsp;sex=m,&nbsp;hobbies=h3]<br>
[fid:3:3]:[Guest&nbsp;name=n2,&nbsp;sex=f,&nbsp;hobbies=h3],&nbsp;[fid:12:29]*<br>
<br>
=&gt;[ActivationCreated(35):&nbsp;rule=findSeating&nbsp;<br>
[fid:15:23]:[Seating&nbsp;id=2,&nbsp;pid=1,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=2,&nbsp;rn=n4]&nbsp;<br>
[fid:5:5]:[Guest&nbsp;name=n4,&nbsp;sex=m,&nbsp;hobbies=h1]<br>
[fid:2:2]:[Guest&nbsp;name=n2,&nbsp;sex=f,&nbsp;hobbies=h1]<br>
<br>
=&gt;[ActivationCreated(35):&nbsp;rule=findSeating&nbsp;<br>
[fid:13:13]:[Seating&nbsp;id=1,&nbsp;pid=0,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=1,&nbsp;rn=n5]&nbsp;<br>
[fid:9:9]:[Guest&nbsp;name=n5,&nbsp;sex=f,&nbsp;hobbies=h1],&nbsp;[fid:1:1]&nbsp;:&nbsp;[Guest&nbsp;name=n1,&nbsp;sex=m,&nbsp;hobbies=h1]<br>
<br>
<span class="bold"><strong>Assign&nbsp;Seating</strong></span><br>
=&gt;[fid:24:36]:[Seating&nbsp;id=4,&nbsp;pid=3,&nbsp;done=false,&nbsp;ls=3,&nbsp;ln=n3,&nbsp;rs=4,&nbsp;rn=n2]]<br>
=&gt;[fid:25:37]:[Path&nbsp;id=4,&nbsp;seat=4,&nbsp;guest=n2]]<br>
=&gt;[fid:26:38]:[Chosen&nbsp;id=3,&nbsp;name=n2,&nbsp;hobbies=h3]<br>
<br>
==&gt;[ActivationCreated(40):&nbsp;rule=makePath&nbsp;<br>
[fid:24:36]:[Seating&nbsp;id=4,&nbsp;pid=3,&nbsp;done=false,&nbsp;ls=3,&nbsp;ln=n3,&nbsp;rs=4,&nbsp;rn=n2]<br>
[fid:23:32]:[Path&nbsp;id=3,&nbsp;seat=2,&nbsp;guest=n4]*<br>
<br>
==&gt;[ActivationCreated(40):&nbsp;rule=makePath&nbsp;<br>
[fid:24:36]:[Seating&nbsp;id=4,&nbsp;pid=3,&nbsp;done=false,&nbsp;ls=3,&nbsp;ln=n3,&nbsp;rs=4,&nbsp;rn=n2]&nbsp;<br>
[fid:20:27]:[Path&nbsp;id=3,&nbsp;seat=3,&nbsp;guest=n3]*<br>
<br>
=&gt;[ActivationCreated(40):&nbsp;rule=makePath&nbsp;<br>
[fid:24:36]:[Seating&nbsp;id=4,&nbsp;pid=3,&nbsp;done=false,&nbsp;ls=3,&nbsp;ln=n3,&nbsp;rs=4,&nbsp;rn=n2]<br>
[fid:22:31]:[Path&nbsp;id=3,&nbsp;seat=1,&nbsp;guest=n5]*<br>
<br>
=&gt;[ActivationCreated(40):&nbsp;rule=done&nbsp;<br>
[fid:24:36]:[Seating&nbsp;id=4,&nbsp;pid=3,&nbsp;done=false,&nbsp;ls=3,&nbsp;ln=n3,&nbsp;rs=4,&nbsp;rn=n2]*<br>
<br>
<span class="bold"><strong>Make&nbsp;Path&nbsp;</strong></span><br>
=&gt;fid:27:41:[Path&nbsp;id=4,&nbsp;seat=2,&nbsp;guest=n4]<br>
<br>
<span class="bold"><strong>Make&nbsp;Path</strong></span><br>
=&gt;fid:28:42]:[Path&nbsp;id=4,&nbsp;seat=1,&nbsp;guest=n5]]<br>
<br>
<span class="bold"><strong>Make&nbsp;Path</strong></span><br>
=&gt;fid:29:43]:[Path&nbsp;id=4,&nbsp;seat=3,&nbsp;guest=n3]]<br>
<br>
<span class="bold"><strong>Path&nbsp;Done</strong></span><br>
<br>
<span class="bold"><strong>Continue&nbsp;&nbsp;Processing</strong></span><br>
=&gt;[ActivationCreated(46):&nbsp;rule=findSeating&nbsp;<br>
[fid:15:23]:[Seating&nbsp;id=2,&nbsp;pid=1,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=2,&nbsp;rn=n4]&nbsp;<br>
[fid:5:5]:[Guest&nbsp;name=n4,&nbsp;sex=m,&nbsp;hobbies=h1],&nbsp;[fid:2:2]<br>
[Guest&nbsp;name=n2,&nbsp;sex=f,&nbsp;hobbies=h1]<br>
<br>
=&gt;[ActivationCreated(46):&nbsp;rule=findSeating&nbsp;<br>
[fid:24:44]:[Seating&nbsp;id=4,&nbsp;pid=3,&nbsp;done=true,&nbsp;ls=3,&nbsp;ln=n3,&nbsp;rs=4,&nbsp;rn=n2]<br>
[fid:2:2]:[Guest&nbsp;name=n2,&nbsp;sex=f,&nbsp;hobbies=h1]<br>
[fid:1:1]:[Guest&nbsp;name=n1,&nbsp;sex=m,&nbsp;hobbies=h1]*<br>
<br>
=&gt;[ActivationCreated(46):&nbsp;rule=findSeating&nbsp;<br>
[fid:13:13]:[Seating&nbsp;id=1,&nbsp;pid=0,&nbsp;done=true,&nbsp;ls=1,&nbsp;ln=n5,&nbsp;rs=1,&nbsp;rn=n5]<br>
[fid:9:9]:[Guest&nbsp;name=n5,&nbsp;sex=f,&nbsp;hobbies=h1]<br>
[fid:1:1]:[Guest&nbsp;name=n1,&nbsp;sex=m,&nbsp;hobbies=h1]<br>
<br>
<span class="bold"><strong>Assign&nbsp;Seating</strong></span><br>
=&gt;[fid:30:47]:[Seating&nbsp;id=5,&nbsp;pid=4,&nbsp;done=false,&nbsp;ls=4,&nbsp;ln=n2,&nbsp;rs=5,&nbsp;rn=n1]<br>
=&gt;[fid:31:48]:[Path&nbsp;id=5,&nbsp;seat=5,&nbsp;guest=n1]<br>
=&gt;[fid:32:49]:[Chosen&nbsp;id=4,&nbsp;name=n1,&nbsp;hobbies=h1]<br>
</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8249"></a>10.1.14.&nbsp;Conways Game Of Life Example</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> Conways Game Of Life
<span class="bold"><strong>Main class:</strong></span> org.drools.examples.conway.ConwayAgendaGroupRun org.drools.examples.conway.ConwayRuleFlowGroupRun
<span class="bold"><strong>Type:</strong></span> java application
<span class="bold"><strong>Rules file:</strong></span> conway-ruleflow.drl conway-agendagroup.drl
<span class="bold"><strong>Objective:</strong></span> Demonstrates 'accumulate', 'collect' and 'from'</pre><p>Conway's Game Of Life, <a class="ulink" href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life" target="_top">http://en.wikipedia.org/wiki/Conway's_Game_of_Life</a>
    <a class="ulink" href="http://www.math.com/students/wonders/life/life.html" target="_top">http://www.math.com/students/wonders/life/life.html</a>,
    is a famous cellular automaton conceived in the early 1970's by
    mathematician John Conway. While the system is well known as "Conway's
    Game Of Life", it really isn't a game at all. Conway's system is more like
    a life simulation. Don't be intimidated. The system is terribly simple and
    terribly interesting. Math and Computer Science students alike have
    marvelled over Conway's system for more than 30 years now. The application
    represented here is a Swing based implementation of Conway's Game of Life.
    The rules that govern the system are implemented as business rules using
    Drools. This document will explain the rules that drive the simulation and
    discuss the Drools specific parts of the implementation.</p><p>We'll first introduce the grid view, shown below, to help
    visualisation of the problem; this is where the life simuation takes
    place. Initially the grid is empty, meaning that there are no live cells
    in the system; ech cell can be considered "LIVE" or "DEAD", live cells
    have a green ball in them. Pre-selected patterns of live cells can be
    selected from the "Pattern" drop down or cells can be doubled-clicked to
    toggle them between LIVE and DEAD. It's important to understand that each
    cell is related to it's neighbour cells, which is a core part of the
    game's rules and will be explained in a moment. Neighbors include not only
    cells to the left, right, top and bottom but also cells that are connected
    diagonally. Each cell has a total of 8 neighbors except the 4 corner cells
    and all of the other cells along the 4 edges. Corner cells have 3
    neighbors and other edge cells have 5 neighbors.</p><div class="figure"><a name="d0e8278"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/conway1.jpg" alt="Conways Example : Starting a new game"></div></div><p class="title"><b>Figure&nbsp;10.28.&nbsp;Conways Example : Starting a new game</b></p></div><br class="figure-break"><p>So what are the basic rules that govern this game? Each generation,
    i.e. completion iteration and evalution of all cells, the system evolves
    and cells may be born or killed, there are a very simple set of rules that
    govern what the next generation will look like.</p><div class="itemizedlist"><ul type="disc"><li><p>If a live cell has fewer than 2 live neighbors, it dies of
        loneliness</p></li><li><p>If a live cell has more than 3 live neighbors, it dies from
        overcrowding</p></li><li><p>If a dead cell has exactly 3 live neighbors, it comes to
        life</p></li></ul></div><p>That is all there is to it. Any cell that doesn't meet any of those
    criteria is left as is for the next generation. With those simple rules in
    mind, go back and play with the system a little bit more and step through
    some generations one at a time and notice these rules taking their
    effect.</p><p>The screnshot below shows an example generation, with a number of
    live cells. Don't worry about matching the exact patterns represented in
    the screen shot. Just get some groups of cells added to the grid. Once you
    have groups of live cells in the grid, or select a pre-designed pattern,
    click the "Next Generation" button and notice what happens. Some of the
    live cells are killed (the green ball disappears) and some dead cells come
    to life (a green ball appears). Cycle through several generations and see
    if you notice any patterns. If you click on the "Start" button, the system
    will evolve itself so you don't need to click the "Next Generation" button
    over and over. Play with the system a little and then come back here for
    more details of how the application works.</p><div class="figure"><a name="d0e8300"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/conway2.jpg" alt="Conways Example : A running game"></div></div><p class="title"><b>Figure&nbsp;10.29.&nbsp;Conways Example : A running game</b></p></div><br class="figure-break"><p>Now lets delve into the code, as this is an advanced example we'll
    assume that by now you know your way around the Drools framework and able
    to connect many of the dots, so we'll just focus at a hgh level
    overview.The example has two ways to execute, one way uses AgendaGroups to
    manage execution flow the other uses RuleFlowGroups to manage execution
    flow - so it's a great way to see the differences. - that's
    ConwayAgendaGroupRun and ConwayRuleFlowGroupRun respectively. For this
    example I'll cover the ruleflow version, as its what most people will
    use.</p><p>All the Cells are inserted into the session and the rules in the
    ruleflow-group "register neighbor" are allowed to execute by the ruleflow
    process. What this group of rules does is for each cell it registers the
    north east, north, north west and west cells using a Neighbor relation
    class, notice this relation is bi-drectional which is why we don't have to
    do any rules for southern facing cells. Note that the constraints make
    sure we stay one column back from the end and 1 row back from the top. By
    the time all activations have fired for these rules all cells are related
    to all their neighboring cells.</p><div class="example"><a name="d0e8310"></a><p class="title"><b>Example&nbsp;10.74.&nbsp;Conways Example : Register all Cell Neighbour relations</b></p><div class="example-contents"><pre class="programlisting">rule "register north east"
    ruleflow-group "register neighbor"
when
    CellGrid( $numberOfColumns : numberOfColumns )
    $cell: Cell( $row : row &gt; 0, $col : col &lt; ( $numberOfColumns - 1 ) )            
    $northEast : Cell( row  == ($row - 1), col == ( $col + 1 ) )    
then                    
    insert( new Neighbor( $cell, $northEast ) );
    insert( new Neighbor( $northEast, $cell ) );        
end

rule "register north"
    ruleflow-group "register neighbor"  
when
    $cell: Cell( $row : row &gt; 0, $col : col )   
    $north : Cell( row  == ($row - 1), col == $col )    
then        
    insert( new Neighbor( $cell, $north ) );
    insert( new Neighbor( $north, $cell ) );        
end

rule "register north west"
    ruleflow-group "register neighbor"
when
    $cell: Cell( $row : row &gt; 0, $col : col &gt; 0 )           
    $northWest : Cell( row  == ($row - 1), col == ( $col - 1 ) )                        
then        
    insert( new Neighbor( $cell, $northWest ) );
    insert( new Neighbor( $northWest, $cell ) );        
end

rule "register west"
    ruleflow-group "register neighbor"
when
    $cell: Cell( $row : row &gt;= 0, $col : col &gt; 0 )          
    $west : Cell( row  == $row, col == ( $col - 1 ) )                       
then        
    insert( new Neighbor( $cell, $west ) );
    insert( new Neighbor( $west, $cell ) );         
end</pre></div></div><br class="example-break"><p>Once all the cells are inserted some java code applies the pattern
    to the grid setting certain cells to Live. Then when the user clicks
    "start" or "next generation" it executes the "Generation" ruleflow. This
    ruleflow is responsible for the management of all changes of cells in each
    generation cycle.</p><div class="figure"><a name="d0e8317"></a><div class="figure-contents"><div class="mediaobject"><img src="../shared/images/Chapter-Examples/conway_ruleflow_generation.png" alt="Conways Example : ruleflow &#34;Generation&#34;"></div></div><p class="title"><b>Figure&nbsp;10.30.&nbsp;Conways Example : ruleflow "Generation"</b></p></div><br class="figure-break"><p>The ruleflow process first enters the "evaluate" group, this means
    any active rule in that group can fire. The rules in this group apply the
    main game of life rules discussed in the beginning of the example, where
    it determines what cells will be killed and which ones given life. We use
    the "phase" attribute to drives the reasoning of the Cell by specific
    groups of rules; typical the phase is tied to a RuleFlowGroup. in the
    ruleflow process definition. Notice that it doesn't actually change the
    state of any Cells at this point; this is because it's evaluating the Grid
    in turn and it must complete the full evaluation until those changes can
    be applied. To achieve this it sets the cell to a "phase" which is either
    Phase.KILL or Phase.BIRTH, which is used later to control actions applied
    to the Cell and when.</p><div class="example"><a name="d0e8325"></a><p class="title"><b>Example&nbsp;10.75.&nbsp;Conways Example : Evaluate Cells with state changes</b></p><div class="example-contents"><pre class="programlisting">rule "Kill The Lonely"
    ruleflow-group "evaluate"
    no-loop
when
#   A live cell has fewer than 2 live neighbors
    theCell: Cell(liveNeighbors &lt; 2, cellState == CellState.LIVE, phase == Phase.EVALUATE)
then
    theCell.setPhase(Phase.KILL);
    update( theCell );
end

rule "Kill The Overcrowded"
    ruleflow-group "evaluate"
    no-loop
when
#   A live cell has more than 3 live neighbors
    theCell: Cell(liveNeighbors &gt; 3, cellState == CellState.LIVE, phase == Phase.EVALUATE)
then
    theCell.setPhase(Phase.KILL);
    update( theCell );
end

rule "Give Birth"
    ruleflow-group "evaluate"
    no-loop
when
#   A dead cell has 3 live neighbors
    theCell: Cell(liveNeighbors == 3, cellState == CellState.DEAD, phase == Phase.EVALUATE)
then
    theCell.setPhase(Phase.BIRTH);
    update( theCell );
end
</pre></div></div><br class="example-break"><p>Once all Cells in the grid have been evaluated we first clear any
    calculation activations, that occured from any previous data changes, via
    the "reset calculate" rule, which clears any activations in the
    "calculate" group. We then enter a split which allows any activations in
    the "kill" groups and "birth" groups to fire, these rules are responsible
    for applying the state change.</p><div class="example"><a name="d0e8332"></a><p class="title"><b>Example&nbsp;10.76.&nbsp;Conways Example : Apply the state changes</b></p><div class="example-contents"><pre class="programlisting">rule "reset calculate"
    ruleflow-group "reset calculate"
when
then
    WorkingMemory wm = drools.getWorkingMemory();
    wm.clearRuleFlowGroup( "calculate" );
end

rule "kill"
    ruleflow-group "kill"
    no-loop
when
    theCell: Cell(phase == Phase.KILL)
then
    theCell.setCellState(CellState.DEAD);
    theCell.setPhase(Phase.DONE);   
    update( theCell );
end 
 
rule "birth"
    ruleflow-group "birth"
    no-loop
when
    theCell: Cell(phase == Phase.BIRTH)
then
    theCell.setCellState(CellState.LIVE);
    theCell.setPhase(Phase.DONE);
    update( theCell );  
end </pre></div></div><br class="example-break"><p>At this stage a number of Cells have been modified with the state
    changed to either LIVE or DEAD, this is where we get to see the power of
    the Neighbour cell and relational programming. When a cell becomes LIVE or
    DEAD we use the Neigbor relation drive the iteration over all surrounding
    Cells increasing or decreasing the LIVE neighbour count, any cell who has
    their count changed is also set to to the EVALUATE phase, to make sure
    they are reasoned over duing the evaluate stage of the ruleflow process.
    Notice that we don't have to do any iteration ourselves, by simpy applying
    the relations in the rules we can get the rule engine to do all the hard
    work for us in a minimal amount of code - very nice :) Once the live count
    for all Cells has been determiend and set the ruleflow process comes to
    and end; the user can either tell it to evaluate another generation, of if
    "start" was clicked the engine will start the ruleflow process
    again.</p><div class="example"><a name="d0e8339"></a><p class="title"><b>Example&nbsp;10.77.&nbsp;Conways Example : Evaluate Cells with state changes</b></p><div class="example-contents"><pre class="programlisting">rule "Calculate Live"
    ruleflow-group "calculate"
    lock-on-active  
when
    theCell: Cell(cellState == CellState.LIVE)
    Neighbor(cell == theCell, $neighbor : neighbor) 
then
    $neighbor.setLiveNeighbors( $neighbor.getLiveNeighbors() + 1 );
    $neighbor.setPhase( Phase.EVALUATE );   
    update( $neighbor );
end 

rule "Calculate Dead"
    ruleflow-group "calculate"
    lock-on-active  
when
    theCell: Cell(cellState == CellState.DEAD)
    Neighbor(cell == theCell, $neighbor : neighbor )
then
    $neighbor.setLiveNeighbors( $neighbor.getLiveNeighbors() - 1 );
    $neighbor.setPhase( Phase.EVALUATE );
    update( $neighbor );    
end </pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8344"></a>10.1.15.&nbsp;Insurance Company Risk Factor and Policy price (using BRMS)</h3></div></div></div><pre class="programlisting"><span class="bold"><strong>Name:</strong></span> drools-insurance 
<span class="bold"><strong>Type:</strong></span> java web application
<span class="bold"><strong>Rules file:</strong></span> exported repository from brms, repository_export.xml
<span class="bold"><strong>Objective:</strong></span> Demonstrates how to use, organize, deploy and execute a rulebase from BRMS</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8360"></a>10.1.15.1.&nbsp;BRMS editors</h4></div></div></div><p>The BRMS has many GUI editors, and textual editors. This discusses
      a few example rules using some of the GUI features:</p><div class="figure"><a name="d0e8365"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Examples/BRMS_Guided.png" align="middle" alt="Guided editor"></div></div><p class="title"><b>Figure&nbsp;10.31.&nbsp;Guided editor</b></p></div><br class="figure-break"><p>The above example shows the guided editor in action. This is a
      slightly more complex example, as a few bound variables are used. We are
      binding "$driver" to the Driver fact, and also binding driverId to the
      id field of the driver (which is then used in the SupplementalInfo fact
      - to join the driverId with the actual driver id). Note the use of the
      ruleflow-group to specify what step of the processing this rule applies
      to.</p><div class="figure"><a name="d0e8373"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Examples/BRMS_DSL.png" align="middle" alt="DSL Editor"></div></div><p class="title"><b>Figure&nbsp;10.32.&nbsp;DSL Editor</b></p></div><br class="figure-break"><p>The above shows the editor using a DSL. In this case the "guided
      editor" was used - this is not a text area, but only provides text boxes
      to "fill in the blanks" as specified in the DSL configuration. Note you
      can also use text based DSLs where there is not this restriction.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8381"></a>10.1.15.2.&nbsp;Introduction</h4></div></div></div><p>Insurance, in law and economics, is a form of risk management
      primarily used to hedge against the risk of a contingent loss. Insurance
      is defined as the equitable transfer of the risk of a loss, from one
      entity to another, in exchange for a premium. Insurer, in economics, is
      the company that sells the insurance. Insurance rate is a factor used to
      determine the amount, called the premium, to be charged for a certain
      amount of insurance coverage. Risk management, the practice of
      appraising and controlling risk, has evolved as a discrete field of
      study and practice.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8386"></a>10.1.15.3.&nbsp;The insurance logic</h4></div></div></div><p>If you have a poor driving record, you may need to look into high
      risk auto insurance. Accidents increase these rates as well. If you have
      a low experience for example less than 3 years as a licensed driver,
      insurance companies believe that the chances that you will be involved
      in a traffic accident are higher than someone more expert.</p><p>Who you are also plays a factor. Men are considered more of a risk
      than women. Teens are considered more of a risk than adults as well if
      you have some younger driver in family like your 20 years old son.
      </p><pre class="programlisting">
rule "Young male single driver"
ruleflow-group "risk assessment"
when
 $driver : Driver( genre == Driver.MALE, age &lt; 25, maritalState == Driver.SINGLE )
then 
 $driver.updateInsuranceFactor(1.6);
end

rule "no expert driver"
ruleflow-group "risk assessment"
when
 $driver : Driver ( licenceYears &lt; 3 )
then
 $driver.updateInsuranceFactor(1.2);
end
</pre><p>Extra coverage over glasses, additional car and accessories, like
      your expansive "pimped" sound system will increase your insurance final
      price, not the risk factor. </p><pre class="programlisting">
ruleflow-group "insurancecalcule"
salience 20
when
 not Rejection()
 $driver : Driver ( driverID : id )
 $access : AccessoriesCoverage ( driverId == driverID)
 $policy : Policy( approved == true )
then
 $policy.setInsurancePrice( $policy.getInsurancePrice() + 
  ($access.getAlarmSystemValue() * 0.10) + 
  ($access.getArmorValue() * 0.20) +
  ($access.getSoundSystemValue() * 0.30 ));
</pre><p>This example uses the previously explained <span class="bold"><strong>RuleFlow</strong></span> feature, the following diagram gives you
      an overview of the insurance factor and calculate logic: As you can see,
      we first calculate the insurance factor, if the driver matches with some
      rejection condition we don't execute the group that contains the Policy
      price calculus, just returning and not approved policy </p><p>
          </p><pre class="programlisting">
ruleflow-group "insurancecalcule"
salience 10
when
 not Rejection()
 $driver : Driver(ifactor : insuranceFactor)
 $policy : Policy( approved == true, bp : basePrice, ip : insurancePrice )
then
 $policy.setInsurancePrice((bp * ifactor) + ip);
</pre><p>
        </p><div class="figure"><a name="d0e8410"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Examples/insurance-ruleflow.png" align="middle" alt="The insurance rule flow"></div></div><p class="title"><b>Figure&nbsp;10.33.&nbsp;The insurance rule flow</b></p></div><p><br class="figure-break"></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8416"></a>10.1.15.4.&nbsp;Downloading and installing the BRMS</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Download the latest version of BRMS from
          http://cruisecontrol.jboss.com/cc/artifacts/jboss-rules</p></li><li><p>Deploy BRMS WAR file into JBoss4.2 AS or JBossWeb, other
          containers can be used as well possibly with some tweaking of
          dependencies (check this url if you using a different application
          server
          http://wiki.jboss.org/wiki/Wiki.jsp?page=JBRMSjsfdependencies).</p></li><li><p>Check you can access and run the BRMS.</p></li><li><p>Check out the demo project from the Drools subversion
          repository
          http://anonsvn.labs.jboss.com/labs/jbossrules/trunk/drools-examples/drools-insurance/</p></li><li><p>Import the demo business rules insurance repository file into
          BRMS, the compressed can be found at "files" folder in the demo
          project. To do this, open the "files" directory, unzip the file
          there locally, and then go to the "Admin" section and "Manage
          import/export" of the BRMS, select the file, and press "Import" -
          follow instructions.</p></li><li><p>Navigate through the BRMS web application to see how things
          are placed and organized and try to create some rules.</p></li><li><p>Go to the "Packages" feature and build the package (you should
          see no errors).</p></li><li><p>Now go to the "Deployment" feature, when you click on the
          package, it will show you one snapshot (which was part of the
          import, you can create more if you like from the previous
          step).</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8444"></a>10.1.15.5.&nbsp;Deploying the insurance example in your application
      server</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Go into your downloaded project and execute </p><pre class="programlisting">mvn clean package</pre></li><li><p>You should see the RuleAgent downloadomg the pre-compiled
          package from brms, if something goes wrong and all tests fails,
          check if the BRMS is up and running and try rebuild the package
          snapshot. </p><pre class="programlisting">Running org.acme.insurance.test.DriverTest
RuleAgent(insuranceconfig) INFO (Wed Sep 18 14:11:44 BRT 2007): Configuring with newInstance=true, secondsToRefresh=30
RuleAgent(insuranceconfig) INFO (Wed Sep 18 14:11:44 BRT 2007): Configuring package provider : URLScanner monitoring URLs:  
                          http://localhost:8080/drools-jbrms/org.drools.brms.JBRMS/package/org.acme.insurance.base/InsuranceDemo

RuleAgent(insuranceconfig) INFO (Wed Sep 18 14:11:45 BRT 2007): Applying changes to the rulebase.
RuleAgent(insuranceconfig) INFO (Wed Sep 18 14:11:45 BRT 2007): Creating a new rulebase as per settings.
RuleAgent(insuranceconfig) INFO (Wed Sep 18 14:11:45 BRT 2007): Adding package called org.acme.insurance.base

... snip ...

Insurance calculate
Insurance Calcule: 0.0
Driver wants non related expenses coverage: 1.05
Driver wants glass coverage: 1.1025
Driver wants extra assistence: 1.1576250000000001
Driver wants an extra Car: 1.2155062500000002
Driver Single Young Male Driver factor: 1.9448100000000004
New Licenced driver 2.333772
approve: 0.0
Policy aproved focusing insurance calcule agenda-group
Insurance calculate
Insurance Calcule: 0.0
Night Vehicle Place: 1.44
Day Vehicle Place: 1.656
approve: 0.0
Policy aproved focusing insurance calcule agenda-group
Insurance calculate
Insurance extra itens percent: 545.0
Insurance Calcule: 545.0
Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.028 sec

Results :
Tests run: 16, Failures: 0, Errors: 0, Skipped: 0
</pre></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8458"></a>10.1.15.6.&nbsp;Running the example from the web page</h4></div></div></div><p>After running and packing you are able to deploy the war into your
      application server, just following the previous instructions for BRMS,
      then point your browser to the example url, that should be something
      like this http://localhost:8080/drools-insurance. Just play around the
      example and change some values and press the execute button, after the
      rules fired the result will be displayed in the bottom of the
      page.</p><div class="figure"><a name="d0e8464"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="../shared/images/Chapter-Examples/insurance-website.png" align="middle" alt="The insurance web page"></div></div><p class="title"><b>Figure&nbsp;10.34.&nbsp;The insurance web page</b></p></div><p><br class="figure-break"></p></div></div></div></div></div><div class="index"><div class="titlepage"><div><div><h2 class="title"><a name="d0e8471"></a>Index</h2></div></div></div><div class="index"><div class="indexdiv"><h3></h3><dl><dt>, <a class="indexterm" href="#d0e1622">Building the Source</a></dt></dl></div><div class="indexdiv"><h3>A</h3><dl><dt>ant, <a class="indexterm" href="#d0e1509">Setup from source</a></dt></dl></div><div class="indexdiv"><h3>B</h3><dl><dt>BeanShell, <a class="indexterm" href="#d0e476">Why use a Rule Engine?</a></dt></dl></div><div class="indexdiv"><h3>C</h3><dl><dt>Collection, <a class="indexterm" href="#d0e3417">Contains Operator</a>, <a class="indexterm" href="#d0e3433">not contains</a></dt></dl></div><div class="indexdiv"><h3>D</h3><dl><dt>declaration, <a class="indexterm" href="#d0e3563">Bound Variable Restriction</a></dt><dt>docbook, <a class="indexterm" href="#d0e1654">Building the Manual</a></dt><dt>Domain Specific Languages, <a class="indexterm" href="#d0e4238">Domain Specific Languages</a></dt><dt>DSL, <a class="indexterm" href="#d0e4258">Editing and managing a DSL</a></dt></dl></div><div class="indexdiv"><h3>E</h3><dl><dt>eclipse, <a class="indexterm" href="#d0e1509">Setup from source</a>, <a class="indexterm" href="#d0e1729">Generating Eclipse Projects</a>, <a class="indexterm" href="#d0e1758">Importing Eclipse Projects</a></dt></dl></div><div class="indexdiv"><h3>H</h3><dl><dt>html, <a class="indexterm" href="#d0e1654">Building the Manual</a></dt></dl></div><div class="indexdiv"><h3>I</h3><dl><dt>Inference Engine, <a class="indexterm" href="#d0e379">Introduction and Background</a></dt></dl></div><div class="indexdiv"><h3>L</h3><dl><dt>Leaps, <a class="indexterm" href="#d0e379">Introduction and Background</a></dt><dt>Logical Object, <a class="indexterm" href="#d0e1195">Truth Maintenance with  Logical Objects</a></dt></dl></div><div class="indexdiv"><h3>M</h3><dl><dt>maven, <a class="indexterm" href="#d0e1509">Setup from source</a>, <a class="indexterm" href="#d0e1729">Generating Eclipse Projects</a></dt></dl></div><div class="indexdiv"><h3>P</h3><dl><dt>path, <a class="indexterm" href="#d0e1509">Setup from source</a></dt><dt>Pattern Matching, <a class="indexterm" href="#d0e379">Introduction and Background</a></dt><dt>Predicate, <a class="indexterm" href="#d0e3660">Inline Eval Constraints</a></dt><dt>Production Memory, <a class="indexterm" href="#d0e379">Introduction and Background</a></dt></dl></div><div class="indexdiv"><h3>R</h3><dl><dt>regular expression, <a class="indexterm" href="#d0e3377">Matches Operator</a>, <a class="indexterm" href="#d0e3397">Not Matches Operator</a></dt><dt>Rete, <a class="indexterm" href="#d0e379">Introduction and Background</a></dt><dt>Return Value, <a class="indexterm" href="#d0e3592">Return Value Restriction</a></dt></dl></div><div class="indexdiv"><h3>S</h3><dl><dt>subversion, <a class="indexterm" href="#d0e1509">Setup from source</a>, <a class="indexterm" href="#d0e1568">Source Checkout</a></dt></dl></div><div class="indexdiv"><h3>T</h3><dl><dt>TortoiseSVN, <a class="indexterm" href="#d0e1509">Setup from source</a></dt></dl></div><div class="indexdiv"><h3>W</h3><dl><dt>WorkingMemory, <a class="indexterm" href="#d0e379">Introduction and Background</a></dt></dl></div><div class="indexdiv"><h3>X</h3><dl><dt>XML, <a class="indexterm" href="#d0e4611">XML Rule Language</a></dt><dt>XML Rule, <a class="indexterm" href="#d0e4631">The XML format</a></dt></dl></div></div></div></div></body></html>